<?php
/**
 * GetNetworkWirelessSsids200ResponseInner
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Model;

use \ArrayAccess;
use \Meraki\ObjectSerializer;

/**
 * GetNetworkWirelessSsids200ResponseInner Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class GetNetworkWirelessSsids200ResponseInner implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'getNetworkWirelessSsids_200_response_inner';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'number' => 'int',
        'name' => 'string',
        'enabled' => 'bool',
        'splash_page' => 'string',
        'ssid_admin_accessible' => 'bool',
        'local_auth' => 'bool',
        'auth_mode' => 'string',
        'encryption_mode' => 'string',
        'wpa_encryption_mode' => 'string',
        'radius_servers' => '\Meraki\Model\GetNetworkWirelessSsids200ResponseInnerRadiusServersInner[]',
        'radius_accounting_servers' => '\Meraki\Model\GetNetworkWirelessSsids200ResponseInnerRadiusAccountingServersInner[]',
        'radius_accounting_enabled' => 'bool',
        'radius_enabled' => 'bool',
        'radius_attribute_for_group_policies' => 'string',
        'radius_failover_policy' => 'string',
        'radius_load_balancing_policy' => 'string',
        'ip_assignment_mode' => 'string',
        'admin_splash_url' => 'string',
        'splash_timeout' => 'string',
        'walled_garden_enabled' => 'bool',
        'walled_garden_ranges' => 'string[]',
        'min_bitrate' => 'int',
        'band_selection' => 'string',
        'per_client_bandwidth_limit_up' => 'int',
        'per_client_bandwidth_limit_down' => 'int',
        'visible' => 'bool',
        'available_on_all_aps' => 'bool',
        'availability_tags' => 'string[]',
        'per_ssid_bandwidth_limit_up' => 'int',
        'per_ssid_bandwidth_limit_down' => 'int',
        'mandatory_dhcp_enabled' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'number' => null,
        'name' => null,
        'enabled' => null,
        'splash_page' => null,
        'ssid_admin_accessible' => null,
        'local_auth' => null,
        'auth_mode' => null,
        'encryption_mode' => null,
        'wpa_encryption_mode' => null,
        'radius_servers' => null,
        'radius_accounting_servers' => null,
        'radius_accounting_enabled' => null,
        'radius_enabled' => null,
        'radius_attribute_for_group_policies' => null,
        'radius_failover_policy' => null,
        'radius_load_balancing_policy' => null,
        'ip_assignment_mode' => null,
        'admin_splash_url' => null,
        'splash_timeout' => null,
        'walled_garden_enabled' => null,
        'walled_garden_ranges' => null,
        'min_bitrate' => null,
        'band_selection' => null,
        'per_client_bandwidth_limit_up' => null,
        'per_client_bandwidth_limit_down' => null,
        'visible' => null,
        'available_on_all_aps' => null,
        'availability_tags' => null,
        'per_ssid_bandwidth_limit_up' => null,
        'per_ssid_bandwidth_limit_down' => null,
        'mandatory_dhcp_enabled' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'number' => false,
        'name' => false,
        'enabled' => false,
        'splash_page' => false,
        'ssid_admin_accessible' => false,
        'local_auth' => false,
        'auth_mode' => false,
        'encryption_mode' => false,
        'wpa_encryption_mode' => false,
        'radius_servers' => false,
        'radius_accounting_servers' => false,
        'radius_accounting_enabled' => false,
        'radius_enabled' => false,
        'radius_attribute_for_group_policies' => false,
        'radius_failover_policy' => false,
        'radius_load_balancing_policy' => false,
        'ip_assignment_mode' => false,
        'admin_splash_url' => false,
        'splash_timeout' => false,
        'walled_garden_enabled' => false,
        'walled_garden_ranges' => false,
        'min_bitrate' => false,
        'band_selection' => false,
        'per_client_bandwidth_limit_up' => false,
        'per_client_bandwidth_limit_down' => false,
        'visible' => false,
        'available_on_all_aps' => false,
        'availability_tags' => false,
        'per_ssid_bandwidth_limit_up' => false,
        'per_ssid_bandwidth_limit_down' => false,
        'mandatory_dhcp_enabled' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'number' => 'number',
        'name' => 'name',
        'enabled' => 'enabled',
        'splash_page' => 'splashPage',
        'ssid_admin_accessible' => 'ssidAdminAccessible',
        'local_auth' => 'localAuth',
        'auth_mode' => 'authMode',
        'encryption_mode' => 'encryptionMode',
        'wpa_encryption_mode' => 'wpaEncryptionMode',
        'radius_servers' => 'radiusServers',
        'radius_accounting_servers' => 'radiusAccountingServers',
        'radius_accounting_enabled' => 'radiusAccountingEnabled',
        'radius_enabled' => 'radiusEnabled',
        'radius_attribute_for_group_policies' => 'radiusAttributeForGroupPolicies',
        'radius_failover_policy' => 'radiusFailoverPolicy',
        'radius_load_balancing_policy' => 'radiusLoadBalancingPolicy',
        'ip_assignment_mode' => 'ipAssignmentMode',
        'admin_splash_url' => 'adminSplashUrl',
        'splash_timeout' => 'splashTimeout',
        'walled_garden_enabled' => 'walledGardenEnabled',
        'walled_garden_ranges' => 'walledGardenRanges',
        'min_bitrate' => 'minBitrate',
        'band_selection' => 'bandSelection',
        'per_client_bandwidth_limit_up' => 'perClientBandwidthLimitUp',
        'per_client_bandwidth_limit_down' => 'perClientBandwidthLimitDown',
        'visible' => 'visible',
        'available_on_all_aps' => 'availableOnAllAps',
        'availability_tags' => 'availabilityTags',
        'per_ssid_bandwidth_limit_up' => 'perSsidBandwidthLimitUp',
        'per_ssid_bandwidth_limit_down' => 'perSsidBandwidthLimitDown',
        'mandatory_dhcp_enabled' => 'mandatoryDhcpEnabled'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'number' => 'setNumber',
        'name' => 'setName',
        'enabled' => 'setEnabled',
        'splash_page' => 'setSplashPage',
        'ssid_admin_accessible' => 'setSsidAdminAccessible',
        'local_auth' => 'setLocalAuth',
        'auth_mode' => 'setAuthMode',
        'encryption_mode' => 'setEncryptionMode',
        'wpa_encryption_mode' => 'setWpaEncryptionMode',
        'radius_servers' => 'setRadiusServers',
        'radius_accounting_servers' => 'setRadiusAccountingServers',
        'radius_accounting_enabled' => 'setRadiusAccountingEnabled',
        'radius_enabled' => 'setRadiusEnabled',
        'radius_attribute_for_group_policies' => 'setRadiusAttributeForGroupPolicies',
        'radius_failover_policy' => 'setRadiusFailoverPolicy',
        'radius_load_balancing_policy' => 'setRadiusLoadBalancingPolicy',
        'ip_assignment_mode' => 'setIpAssignmentMode',
        'admin_splash_url' => 'setAdminSplashUrl',
        'splash_timeout' => 'setSplashTimeout',
        'walled_garden_enabled' => 'setWalledGardenEnabled',
        'walled_garden_ranges' => 'setWalledGardenRanges',
        'min_bitrate' => 'setMinBitrate',
        'band_selection' => 'setBandSelection',
        'per_client_bandwidth_limit_up' => 'setPerClientBandwidthLimitUp',
        'per_client_bandwidth_limit_down' => 'setPerClientBandwidthLimitDown',
        'visible' => 'setVisible',
        'available_on_all_aps' => 'setAvailableOnAllAps',
        'availability_tags' => 'setAvailabilityTags',
        'per_ssid_bandwidth_limit_up' => 'setPerSsidBandwidthLimitUp',
        'per_ssid_bandwidth_limit_down' => 'setPerSsidBandwidthLimitDown',
        'mandatory_dhcp_enabled' => 'setMandatoryDhcpEnabled'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'number' => 'getNumber',
        'name' => 'getName',
        'enabled' => 'getEnabled',
        'splash_page' => 'getSplashPage',
        'ssid_admin_accessible' => 'getSsidAdminAccessible',
        'local_auth' => 'getLocalAuth',
        'auth_mode' => 'getAuthMode',
        'encryption_mode' => 'getEncryptionMode',
        'wpa_encryption_mode' => 'getWpaEncryptionMode',
        'radius_servers' => 'getRadiusServers',
        'radius_accounting_servers' => 'getRadiusAccountingServers',
        'radius_accounting_enabled' => 'getRadiusAccountingEnabled',
        'radius_enabled' => 'getRadiusEnabled',
        'radius_attribute_for_group_policies' => 'getRadiusAttributeForGroupPolicies',
        'radius_failover_policy' => 'getRadiusFailoverPolicy',
        'radius_load_balancing_policy' => 'getRadiusLoadBalancingPolicy',
        'ip_assignment_mode' => 'getIpAssignmentMode',
        'admin_splash_url' => 'getAdminSplashUrl',
        'splash_timeout' => 'getSplashTimeout',
        'walled_garden_enabled' => 'getWalledGardenEnabled',
        'walled_garden_ranges' => 'getWalledGardenRanges',
        'min_bitrate' => 'getMinBitrate',
        'band_selection' => 'getBandSelection',
        'per_client_bandwidth_limit_up' => 'getPerClientBandwidthLimitUp',
        'per_client_bandwidth_limit_down' => 'getPerClientBandwidthLimitDown',
        'visible' => 'getVisible',
        'available_on_all_aps' => 'getAvailableOnAllAps',
        'availability_tags' => 'getAvailabilityTags',
        'per_ssid_bandwidth_limit_up' => 'getPerSsidBandwidthLimitUp',
        'per_ssid_bandwidth_limit_down' => 'getPerSsidBandwidthLimitDown',
        'mandatory_dhcp_enabled' => 'getMandatoryDhcpEnabled'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const SPLASH_PAGE_BILLING = 'Billing';
    public const SPLASH_PAGE_CISCO_ISE = 'Cisco ISE';
    public const SPLASH_PAGE_CLICK_THROUGH_SPLASH_PAGE = 'Click-through splash page';
    public const SPLASH_PAGE_FACEBOOK_WI_FI = 'Facebook Wi-Fi';
    public const SPLASH_PAGE_GOOGLE_APPS_DOMAIN = 'Google Apps domain';
    public const SPLASH_PAGE_GOOGLE_O_AUTH = 'Google OAuth';
    public const SPLASH_PAGE_MICROSOFT_ENTRA_ID = 'Microsoft Entra ID';
    public const SPLASH_PAGE_NONE = 'None';
    public const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_ACTIVE_DIRECTORY = 'Password-protected with Active Directory';
    public const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_LDAP = 'Password-protected with LDAP';
    public const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_MERAKI_RADIUS = 'Password-protected with Meraki RADIUS';
    public const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_CUSTOM_RADIUS = 'Password-protected with custom RADIUS';
    public const SPLASH_PAGE_SMS_AUTHENTICATION = 'SMS authentication';
    public const SPLASH_PAGE_SPONSORED_GUEST = 'Sponsored guest';
    public const SPLASH_PAGE_SYSTEMS_MANAGER_SENTRY = 'Systems Manager Sentry';
    public const AUTH_MODE__8021X_ENTRA = '8021x-entra';
    public const AUTH_MODE__8021X_GOOGLE = '8021x-google';
    public const AUTH_MODE__8021X_LOCALRADIUS = '8021x-localradius';
    public const AUTH_MODE__8021X_MERAKI = '8021x-meraki';
    public const AUTH_MODE__8021X_NAC = '8021x-nac';
    public const AUTH_MODE__8021X_RADIUS = '8021x-radius';
    public const AUTH_MODE_IPSK_WITH_NAC = 'ipsk-with-nac';
    public const AUTH_MODE_IPSK_WITH_RADIUS = 'ipsk-with-radius';
    public const AUTH_MODE_IPSK_WITH_RADIUS_EASY_PSK = 'ipsk-with-radius-easy-psk';
    public const AUTH_MODE_IPSK_WITHOUT_RADIUS = 'ipsk-without-radius';
    public const AUTH_MODE_OPEN = 'open';
    public const AUTH_MODE_OPEN_ENHANCED = 'open-enhanced';
    public const AUTH_MODE_OPEN_WITH_NAC = 'open-with-nac';
    public const AUTH_MODE_OPEN_WITH_RADIUS = 'open-with-radius';
    public const AUTH_MODE_PSK = 'psk';
    public const ENCRYPTION_MODE_WEP = 'wep';
    public const ENCRYPTION_MODE_WPA = 'wpa';
    public const WPA_ENCRYPTION_MODE_WPA1_AND_WPA2 = 'WPA1 and WPA2';
    public const WPA_ENCRYPTION_MODE_WPA1_ONLY = 'WPA1 only';
    public const WPA_ENCRYPTION_MODE_WPA2_ONLY = 'WPA2 only';
    public const WPA_ENCRYPTION_MODE_WPA3_192_BIT_SECURITY = 'WPA3 192-bit Security';
    public const WPA_ENCRYPTION_MODE_WPA3_TRANSITION_MODE = 'WPA3 Transition Mode';
    public const WPA_ENCRYPTION_MODE_WPA3_ONLY = 'WPA3 only';
    public const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_AIRESPACE_ACL_NAME = 'Airespace-ACL-Name';
    public const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_ARUBA_USER_ROLE = 'Aruba-User-Role';
    public const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_FILTER_ID = 'Filter-Id';
    public const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_REPLY_MESSAGE = 'Reply-Message';
    public const RADIUS_FAILOVER_POLICY_ALLOW_ACCESS = 'Allow access';
    public const RADIUS_FAILOVER_POLICY_DENY_ACCESS = 'Deny access';
    public const RADIUS_LOAD_BALANCING_POLICY_ROUND_ROBIN = 'Round robin';
    public const RADIUS_LOAD_BALANCING_POLICY_STRICT_PRIORITY_ORDER = 'Strict priority order';
    public const IP_ASSIGNMENT_MODE_BRIDGE_MODE = 'Bridge mode';
    public const IP_ASSIGNMENT_MODE_ETHERNET_OVER_GRE = 'Ethernet over GRE';
    public const IP_ASSIGNMENT_MODE_LAYER_3_ROAMING = 'Layer 3 roaming';
    public const IP_ASSIGNMENT_MODE_LAYER_3_ROAMING_WITH_A_CONCENTRATOR = 'Layer 3 roaming with a concentrator';
    public const IP_ASSIGNMENT_MODE_NAT_MODE = 'NAT mode';
    public const IP_ASSIGNMENT_MODE_VPN = 'VPN';
    public const BAND_SELECTION__5_GHZ_BAND_ONLY = '5 GHz band only';
    public const BAND_SELECTION_DUAL_BAND_OPERATION = 'Dual band operation';
    public const BAND_SELECTION_DUAL_BAND_OPERATION_WITH_BAND_STEERING = 'Dual band operation with Band Steering';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSplashPageAllowableValues()
    {
        return [
            self::SPLASH_PAGE_BILLING,
            self::SPLASH_PAGE_CISCO_ISE,
            self::SPLASH_PAGE_CLICK_THROUGH_SPLASH_PAGE,
            self::SPLASH_PAGE_FACEBOOK_WI_FI,
            self::SPLASH_PAGE_GOOGLE_APPS_DOMAIN,
            self::SPLASH_PAGE_GOOGLE_O_AUTH,
            self::SPLASH_PAGE_MICROSOFT_ENTRA_ID,
            self::SPLASH_PAGE_NONE,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_ACTIVE_DIRECTORY,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_LDAP,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_MERAKI_RADIUS,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_CUSTOM_RADIUS,
            self::SPLASH_PAGE_SMS_AUTHENTICATION,
            self::SPLASH_PAGE_SPONSORED_GUEST,
            self::SPLASH_PAGE_SYSTEMS_MANAGER_SENTRY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthModeAllowableValues()
    {
        return [
            self::AUTH_MODE__8021X_ENTRA,
            self::AUTH_MODE__8021X_GOOGLE,
            self::AUTH_MODE__8021X_LOCALRADIUS,
            self::AUTH_MODE__8021X_MERAKI,
            self::AUTH_MODE__8021X_NAC,
            self::AUTH_MODE__8021X_RADIUS,
            self::AUTH_MODE_IPSK_WITH_NAC,
            self::AUTH_MODE_IPSK_WITH_RADIUS,
            self::AUTH_MODE_IPSK_WITH_RADIUS_EASY_PSK,
            self::AUTH_MODE_IPSK_WITHOUT_RADIUS,
            self::AUTH_MODE_OPEN,
            self::AUTH_MODE_OPEN_ENHANCED,
            self::AUTH_MODE_OPEN_WITH_NAC,
            self::AUTH_MODE_OPEN_WITH_RADIUS,
            self::AUTH_MODE_PSK,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getEncryptionModeAllowableValues()
    {
        return [
            self::ENCRYPTION_MODE_WEP,
            self::ENCRYPTION_MODE_WPA,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getWpaEncryptionModeAllowableValues()
    {
        return [
            self::WPA_ENCRYPTION_MODE_WPA1_AND_WPA2,
            self::WPA_ENCRYPTION_MODE_WPA1_ONLY,
            self::WPA_ENCRYPTION_MODE_WPA2_ONLY,
            self::WPA_ENCRYPTION_MODE_WPA3_192_BIT_SECURITY,
            self::WPA_ENCRYPTION_MODE_WPA3_TRANSITION_MODE,
            self::WPA_ENCRYPTION_MODE_WPA3_ONLY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusAttributeForGroupPoliciesAllowableValues()
    {
        return [
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_AIRESPACE_ACL_NAME,
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_ARUBA_USER_ROLE,
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_FILTER_ID,
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_REPLY_MESSAGE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusFailoverPolicyAllowableValues()
    {
        return [
            self::RADIUS_FAILOVER_POLICY_ALLOW_ACCESS,
            self::RADIUS_FAILOVER_POLICY_DENY_ACCESS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusLoadBalancingPolicyAllowableValues()
    {
        return [
            self::RADIUS_LOAD_BALANCING_POLICY_ROUND_ROBIN,
            self::RADIUS_LOAD_BALANCING_POLICY_STRICT_PRIORITY_ORDER,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getIpAssignmentModeAllowableValues()
    {
        return [
            self::IP_ASSIGNMENT_MODE_BRIDGE_MODE,
            self::IP_ASSIGNMENT_MODE_ETHERNET_OVER_GRE,
            self::IP_ASSIGNMENT_MODE_LAYER_3_ROAMING,
            self::IP_ASSIGNMENT_MODE_LAYER_3_ROAMING_WITH_A_CONCENTRATOR,
            self::IP_ASSIGNMENT_MODE_NAT_MODE,
            self::IP_ASSIGNMENT_MODE_VPN,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getBandSelectionAllowableValues()
    {
        return [
            self::BAND_SELECTION__5_GHZ_BAND_ONLY,
            self::BAND_SELECTION_DUAL_BAND_OPERATION,
            self::BAND_SELECTION_DUAL_BAND_OPERATION_WITH_BAND_STEERING,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('number', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('enabled', $data ?? [], null);
        $this->setIfExists('splash_page', $data ?? [], null);
        $this->setIfExists('ssid_admin_accessible', $data ?? [], null);
        $this->setIfExists('local_auth', $data ?? [], null);
        $this->setIfExists('auth_mode', $data ?? [], null);
        $this->setIfExists('encryption_mode', $data ?? [], null);
        $this->setIfExists('wpa_encryption_mode', $data ?? [], null);
        $this->setIfExists('radius_servers', $data ?? [], null);
        $this->setIfExists('radius_accounting_servers', $data ?? [], null);
        $this->setIfExists('radius_accounting_enabled', $data ?? [], null);
        $this->setIfExists('radius_enabled', $data ?? [], null);
        $this->setIfExists('radius_attribute_for_group_policies', $data ?? [], null);
        $this->setIfExists('radius_failover_policy', $data ?? [], null);
        $this->setIfExists('radius_load_balancing_policy', $data ?? [], null);
        $this->setIfExists('ip_assignment_mode', $data ?? [], null);
        $this->setIfExists('admin_splash_url', $data ?? [], null);
        $this->setIfExists('splash_timeout', $data ?? [], null);
        $this->setIfExists('walled_garden_enabled', $data ?? [], null);
        $this->setIfExists('walled_garden_ranges', $data ?? [], null);
        $this->setIfExists('min_bitrate', $data ?? [], null);
        $this->setIfExists('band_selection', $data ?? [], null);
        $this->setIfExists('per_client_bandwidth_limit_up', $data ?? [], null);
        $this->setIfExists('per_client_bandwidth_limit_down', $data ?? [], null);
        $this->setIfExists('visible', $data ?? [], null);
        $this->setIfExists('available_on_all_aps', $data ?? [], null);
        $this->setIfExists('availability_tags', $data ?? [], null);
        $this->setIfExists('per_ssid_bandwidth_limit_up', $data ?? [], null);
        $this->setIfExists('per_ssid_bandwidth_limit_down', $data ?? [], null);
        $this->setIfExists('mandatory_dhcp_enabled', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getSplashPageAllowableValues();
        if (!is_null($this->container['splash_page']) && !in_array($this->container['splash_page'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'splash_page', must be one of '%s'",
                $this->container['splash_page'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAuthModeAllowableValues();
        if (!is_null($this->container['auth_mode']) && !in_array($this->container['auth_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_mode', must be one of '%s'",
                $this->container['auth_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getEncryptionModeAllowableValues();
        if (!is_null($this->container['encryption_mode']) && !in_array($this->container['encryption_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'encryption_mode', must be one of '%s'",
                $this->container['encryption_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getWpaEncryptionModeAllowableValues();
        if (!is_null($this->container['wpa_encryption_mode']) && !in_array($this->container['wpa_encryption_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'wpa_encryption_mode', must be one of '%s'",
                $this->container['wpa_encryption_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRadiusAttributeForGroupPoliciesAllowableValues();
        if (!is_null($this->container['radius_attribute_for_group_policies']) && !in_array($this->container['radius_attribute_for_group_policies'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'radius_attribute_for_group_policies', must be one of '%s'",
                $this->container['radius_attribute_for_group_policies'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRadiusFailoverPolicyAllowableValues();
        if (!is_null($this->container['radius_failover_policy']) && !in_array($this->container['radius_failover_policy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'radius_failover_policy', must be one of '%s'",
                $this->container['radius_failover_policy'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRadiusLoadBalancingPolicyAllowableValues();
        if (!is_null($this->container['radius_load_balancing_policy']) && !in_array($this->container['radius_load_balancing_policy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'radius_load_balancing_policy', must be one of '%s'",
                $this->container['radius_load_balancing_policy'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getIpAssignmentModeAllowableValues();
        if (!is_null($this->container['ip_assignment_mode']) && !in_array($this->container['ip_assignment_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ip_assignment_mode', must be one of '%s'",
                $this->container['ip_assignment_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getBandSelectionAllowableValues();
        if (!is_null($this->container['band_selection']) && !in_array($this->container['band_selection'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'band_selection', must be one of '%s'",
                $this->container['band_selection'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets number
     *
     * @return int|null
     */
    public function getNumber()
    {
        return $this->container['number'];
    }

    /**
     * Sets number
     *
     * @param int|null $number Unique identifier of the SSID
     *
     * @return self
     */
    public function setNumber($number)
    {
        if (is_null($number)) {
            throw new \InvalidArgumentException('non-nullable number cannot be null');
        }
        $this->container['number'] = $number;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name The name of the SSID
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets enabled
     *
     * @return bool|null
     */
    public function getEnabled()
    {
        return $this->container['enabled'];
    }

    /**
     * Sets enabled
     *
     * @param bool|null $enabled Whether or not the SSID is enabled
     *
     * @return self
     */
    public function setEnabled($enabled)
    {
        if (is_null($enabled)) {
            throw new \InvalidArgumentException('non-nullable enabled cannot be null');
        }
        $this->container['enabled'] = $enabled;

        return $this;
    }

    /**
     * Gets splash_page
     *
     * @return string|null
     */
    public function getSplashPage()
    {
        return $this->container['splash_page'];
    }

    /**
     * Sets splash_page
     *
     * @param string|null $splash_page The type of splash page for the SSID
     *
     * @return self
     */
    public function setSplashPage($splash_page)
    {
        if (is_null($splash_page)) {
            throw new \InvalidArgumentException('non-nullable splash_page cannot be null');
        }
        $allowedValues = $this->getSplashPageAllowableValues();
        if (!in_array($splash_page, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'splash_page', must be one of '%s'",
                    $splash_page,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['splash_page'] = $splash_page;

        return $this;
    }

    /**
     * Gets ssid_admin_accessible
     *
     * @return bool|null
     */
    public function getSsidAdminAccessible()
    {
        return $this->container['ssid_admin_accessible'];
    }

    /**
     * Sets ssid_admin_accessible
     *
     * @param bool|null $ssid_admin_accessible SSID Administrator access status
     *
     * @return self
     */
    public function setSsidAdminAccessible($ssid_admin_accessible)
    {
        if (is_null($ssid_admin_accessible)) {
            throw new \InvalidArgumentException('non-nullable ssid_admin_accessible cannot be null');
        }
        $this->container['ssid_admin_accessible'] = $ssid_admin_accessible;

        return $this;
    }

    /**
     * Gets local_auth
     *
     * @return bool|null
     */
    public function getLocalAuth()
    {
        return $this->container['local_auth'];
    }

    /**
     * Sets local_auth
     *
     * @param bool|null $local_auth Extended local auth flag for Enterprise NAC
     *
     * @return self
     */
    public function setLocalAuth($local_auth)
    {
        if (is_null($local_auth)) {
            throw new \InvalidArgumentException('non-nullable local_auth cannot be null');
        }
        $this->container['local_auth'] = $local_auth;

        return $this;
    }

    /**
     * Gets auth_mode
     *
     * @return string|null
     */
    public function getAuthMode()
    {
        return $this->container['auth_mode'];
    }

    /**
     * Sets auth_mode
     *
     * @param string|null $auth_mode The association control method for the SSID
     *
     * @return self
     */
    public function setAuthMode($auth_mode)
    {
        if (is_null($auth_mode)) {
            throw new \InvalidArgumentException('non-nullable auth_mode cannot be null');
        }
        $allowedValues = $this->getAuthModeAllowableValues();
        if (!in_array($auth_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_mode', must be one of '%s'",
                    $auth_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_mode'] = $auth_mode;

        return $this;
    }

    /**
     * Gets encryption_mode
     *
     * @return string|null
     */
    public function getEncryptionMode()
    {
        return $this->container['encryption_mode'];
    }

    /**
     * Sets encryption_mode
     *
     * @param string|null $encryption_mode The psk encryption mode for the SSID
     *
     * @return self
     */
    public function setEncryptionMode($encryption_mode)
    {
        if (is_null($encryption_mode)) {
            throw new \InvalidArgumentException('non-nullable encryption_mode cannot be null');
        }
        $allowedValues = $this->getEncryptionModeAllowableValues();
        if (!in_array($encryption_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'encryption_mode', must be one of '%s'",
                    $encryption_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['encryption_mode'] = $encryption_mode;

        return $this;
    }

    /**
     * Gets wpa_encryption_mode
     *
     * @return string|null
     */
    public function getWpaEncryptionMode()
    {
        return $this->container['wpa_encryption_mode'];
    }

    /**
     * Sets wpa_encryption_mode
     *
     * @param string|null $wpa_encryption_mode The types of WPA encryption
     *
     * @return self
     */
    public function setWpaEncryptionMode($wpa_encryption_mode)
    {
        if (is_null($wpa_encryption_mode)) {
            throw new \InvalidArgumentException('non-nullable wpa_encryption_mode cannot be null');
        }
        $allowedValues = $this->getWpaEncryptionModeAllowableValues();
        if (!in_array($wpa_encryption_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'wpa_encryption_mode', must be one of '%s'",
                    $wpa_encryption_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['wpa_encryption_mode'] = $wpa_encryption_mode;

        return $this;
    }

    /**
     * Gets radius_servers
     *
     * @return \Meraki\Model\GetNetworkWirelessSsids200ResponseInnerRadiusServersInner[]|null
     */
    public function getRadiusServers()
    {
        return $this->container['radius_servers'];
    }

    /**
     * Sets radius_servers
     *
     * @param \Meraki\Model\GetNetworkWirelessSsids200ResponseInnerRadiusServersInner[]|null $radius_servers List of RADIUS 802.1X servers to be used for authentication
     *
     * @return self
     */
    public function setRadiusServers($radius_servers)
    {
        if (is_null($radius_servers)) {
            throw new \InvalidArgumentException('non-nullable radius_servers cannot be null');
        }
        $this->container['radius_servers'] = $radius_servers;

        return $this;
    }

    /**
     * Gets radius_accounting_servers
     *
     * @return \Meraki\Model\GetNetworkWirelessSsids200ResponseInnerRadiusAccountingServersInner[]|null
     */
    public function getRadiusAccountingServers()
    {
        return $this->container['radius_accounting_servers'];
    }

    /**
     * Sets radius_accounting_servers
     *
     * @param \Meraki\Model\GetNetworkWirelessSsids200ResponseInnerRadiusAccountingServersInner[]|null $radius_accounting_servers List of RADIUS accounting 802.1X servers to be used for authentication
     *
     * @return self
     */
    public function setRadiusAccountingServers($radius_accounting_servers)
    {
        if (is_null($radius_accounting_servers)) {
            throw new \InvalidArgumentException('non-nullable radius_accounting_servers cannot be null');
        }
        $this->container['radius_accounting_servers'] = $radius_accounting_servers;

        return $this;
    }

    /**
     * Gets radius_accounting_enabled
     *
     * @return bool|null
     */
    public function getRadiusAccountingEnabled()
    {
        return $this->container['radius_accounting_enabled'];
    }

    /**
     * Sets radius_accounting_enabled
     *
     * @param bool|null $radius_accounting_enabled Whether or not RADIUS accounting is enabled
     *
     * @return self
     */
    public function setRadiusAccountingEnabled($radius_accounting_enabled)
    {
        if (is_null($radius_accounting_enabled)) {
            throw new \InvalidArgumentException('non-nullable radius_accounting_enabled cannot be null');
        }
        $this->container['radius_accounting_enabled'] = $radius_accounting_enabled;

        return $this;
    }

    /**
     * Gets radius_enabled
     *
     * @return bool|null
     */
    public function getRadiusEnabled()
    {
        return $this->container['radius_enabled'];
    }

    /**
     * Sets radius_enabled
     *
     * @param bool|null $radius_enabled Whether RADIUS authentication is enabled
     *
     * @return self
     */
    public function setRadiusEnabled($radius_enabled)
    {
        if (is_null($radius_enabled)) {
            throw new \InvalidArgumentException('non-nullable radius_enabled cannot be null');
        }
        $this->container['radius_enabled'] = $radius_enabled;

        return $this;
    }

    /**
     * Gets radius_attribute_for_group_policies
     *
     * @return string|null
     */
    public function getRadiusAttributeForGroupPolicies()
    {
        return $this->container['radius_attribute_for_group_policies'];
    }

    /**
     * Sets radius_attribute_for_group_policies
     *
     * @param string|null $radius_attribute_for_group_policies RADIUS attribute used to look up group policies
     *
     * @return self
     */
    public function setRadiusAttributeForGroupPolicies($radius_attribute_for_group_policies)
    {
        if (is_null($radius_attribute_for_group_policies)) {
            throw new \InvalidArgumentException('non-nullable radius_attribute_for_group_policies cannot be null');
        }
        $allowedValues = $this->getRadiusAttributeForGroupPoliciesAllowableValues();
        if (!in_array($radius_attribute_for_group_policies, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'radius_attribute_for_group_policies', must be one of '%s'",
                    $radius_attribute_for_group_policies,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_attribute_for_group_policies'] = $radius_attribute_for_group_policies;

        return $this;
    }

    /**
     * Gets radius_failover_policy
     *
     * @return string|null
     */
    public function getRadiusFailoverPolicy()
    {
        return $this->container['radius_failover_policy'];
    }

    /**
     * Sets radius_failover_policy
     *
     * @param string|null $radius_failover_policy Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
     *
     * @return self
     */
    public function setRadiusFailoverPolicy($radius_failover_policy)
    {
        if (is_null($radius_failover_policy)) {
            throw new \InvalidArgumentException('non-nullable radius_failover_policy cannot be null');
        }
        $allowedValues = $this->getRadiusFailoverPolicyAllowableValues();
        if (!in_array($radius_failover_policy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'radius_failover_policy', must be one of '%s'",
                    $radius_failover_policy,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_failover_policy'] = $radius_failover_policy;

        return $this;
    }

    /**
     * Gets radius_load_balancing_policy
     *
     * @return string|null
     */
    public function getRadiusLoadBalancingPolicy()
    {
        return $this->container['radius_load_balancing_policy'];
    }

    /**
     * Sets radius_load_balancing_policy
     *
     * @param string|null $radius_load_balancing_policy Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
     *
     * @return self
     */
    public function setRadiusLoadBalancingPolicy($radius_load_balancing_policy)
    {
        if (is_null($radius_load_balancing_policy)) {
            throw new \InvalidArgumentException('non-nullable radius_load_balancing_policy cannot be null');
        }
        $allowedValues = $this->getRadiusLoadBalancingPolicyAllowableValues();
        if (!in_array($radius_load_balancing_policy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'radius_load_balancing_policy', must be one of '%s'",
                    $radius_load_balancing_policy,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_load_balancing_policy'] = $radius_load_balancing_policy;

        return $this;
    }

    /**
     * Gets ip_assignment_mode
     *
     * @return string|null
     */
    public function getIpAssignmentMode()
    {
        return $this->container['ip_assignment_mode'];
    }

    /**
     * Sets ip_assignment_mode
     *
     * @param string|null $ip_assignment_mode The client IP assignment mode
     *
     * @return self
     */
    public function setIpAssignmentMode($ip_assignment_mode)
    {
        if (is_null($ip_assignment_mode)) {
            throw new \InvalidArgumentException('non-nullable ip_assignment_mode cannot be null');
        }
        $allowedValues = $this->getIpAssignmentModeAllowableValues();
        if (!in_array($ip_assignment_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ip_assignment_mode', must be one of '%s'",
                    $ip_assignment_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ip_assignment_mode'] = $ip_assignment_mode;

        return $this;
    }

    /**
     * Gets admin_splash_url
     *
     * @return string|null
     */
    public function getAdminSplashUrl()
    {
        return $this->container['admin_splash_url'];
    }

    /**
     * Sets admin_splash_url
     *
     * @param string|null $admin_splash_url URL for the admin splash page
     *
     * @return self
     */
    public function setAdminSplashUrl($admin_splash_url)
    {
        if (is_null($admin_splash_url)) {
            throw new \InvalidArgumentException('non-nullable admin_splash_url cannot be null');
        }
        $this->container['admin_splash_url'] = $admin_splash_url;

        return $this;
    }

    /**
     * Gets splash_timeout
     *
     * @return string|null
     */
    public function getSplashTimeout()
    {
        return $this->container['splash_timeout'];
    }

    /**
     * Sets splash_timeout
     *
     * @param string|null $splash_timeout Splash page timeout
     *
     * @return self
     */
    public function setSplashTimeout($splash_timeout)
    {
        if (is_null($splash_timeout)) {
            throw new \InvalidArgumentException('non-nullable splash_timeout cannot be null');
        }
        $this->container['splash_timeout'] = $splash_timeout;

        return $this;
    }

    /**
     * Gets walled_garden_enabled
     *
     * @return bool|null
     */
    public function getWalledGardenEnabled()
    {
        return $this->container['walled_garden_enabled'];
    }

    /**
     * Sets walled_garden_enabled
     *
     * @param bool|null $walled_garden_enabled Allow users to access a configurable list of IP ranges prior to sign-on
     *
     * @return self
     */
    public function setWalledGardenEnabled($walled_garden_enabled)
    {
        if (is_null($walled_garden_enabled)) {
            throw new \InvalidArgumentException('non-nullable walled_garden_enabled cannot be null');
        }
        $this->container['walled_garden_enabled'] = $walled_garden_enabled;

        return $this;
    }

    /**
     * Gets walled_garden_ranges
     *
     * @return string[]|null
     */
    public function getWalledGardenRanges()
    {
        return $this->container['walled_garden_ranges'];
    }

    /**
     * Sets walled_garden_ranges
     *
     * @param string[]|null $walled_garden_ranges Domain names and IP address ranges available in Walled Garden mode
     *
     * @return self
     */
    public function setWalledGardenRanges($walled_garden_ranges)
    {
        if (is_null($walled_garden_ranges)) {
            throw new \InvalidArgumentException('non-nullable walled_garden_ranges cannot be null');
        }
        $this->container['walled_garden_ranges'] = $walled_garden_ranges;

        return $this;
    }

    /**
     * Gets min_bitrate
     *
     * @return int|null
     */
    public function getMinBitrate()
    {
        return $this->container['min_bitrate'];
    }

    /**
     * Sets min_bitrate
     *
     * @param int|null $min_bitrate The minimum bitrate in Mbps of this SSID in the default indoor RF profile
     *
     * @return self
     */
    public function setMinBitrate($min_bitrate)
    {
        if (is_null($min_bitrate)) {
            throw new \InvalidArgumentException('non-nullable min_bitrate cannot be null');
        }
        $this->container['min_bitrate'] = $min_bitrate;

        return $this;
    }

    /**
     * Gets band_selection
     *
     * @return string|null
     */
    public function getBandSelection()
    {
        return $this->container['band_selection'];
    }

    /**
     * Sets band_selection
     *
     * @param string|null $band_selection The client-serving radio frequencies of this SSID in the default indoor RF profile
     *
     * @return self
     */
    public function setBandSelection($band_selection)
    {
        if (is_null($band_selection)) {
            throw new \InvalidArgumentException('non-nullable band_selection cannot be null');
        }
        $allowedValues = $this->getBandSelectionAllowableValues();
        if (!in_array($band_selection, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'band_selection', must be one of '%s'",
                    $band_selection,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['band_selection'] = $band_selection;

        return $this;
    }

    /**
     * Gets per_client_bandwidth_limit_up
     *
     * @return int|null
     */
    public function getPerClientBandwidthLimitUp()
    {
        return $this->container['per_client_bandwidth_limit_up'];
    }

    /**
     * Sets per_client_bandwidth_limit_up
     *
     * @param int|null $per_client_bandwidth_limit_up The upload bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return self
     */
    public function setPerClientBandwidthLimitUp($per_client_bandwidth_limit_up)
    {
        if (is_null($per_client_bandwidth_limit_up)) {
            throw new \InvalidArgumentException('non-nullable per_client_bandwidth_limit_up cannot be null');
        }
        $this->container['per_client_bandwidth_limit_up'] = $per_client_bandwidth_limit_up;

        return $this;
    }

    /**
     * Gets per_client_bandwidth_limit_down
     *
     * @return int|null
     */
    public function getPerClientBandwidthLimitDown()
    {
        return $this->container['per_client_bandwidth_limit_down'];
    }

    /**
     * Sets per_client_bandwidth_limit_down
     *
     * @param int|null $per_client_bandwidth_limit_down The download bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return self
     */
    public function setPerClientBandwidthLimitDown($per_client_bandwidth_limit_down)
    {
        if (is_null($per_client_bandwidth_limit_down)) {
            throw new \InvalidArgumentException('non-nullable per_client_bandwidth_limit_down cannot be null');
        }
        $this->container['per_client_bandwidth_limit_down'] = $per_client_bandwidth_limit_down;

        return $this;
    }

    /**
     * Gets visible
     *
     * @return bool|null
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool|null $visible Whether the SSID is advertised or hidden by the AP
     *
     * @return self
     */
    public function setVisible($visible)
    {
        if (is_null($visible)) {
            throw new \InvalidArgumentException('non-nullable visible cannot be null');
        }
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets available_on_all_aps
     *
     * @return bool|null
     */
    public function getAvailableOnAllAps()
    {
        return $this->container['available_on_all_aps'];
    }

    /**
     * Sets available_on_all_aps
     *
     * @param bool|null $available_on_all_aps Whether all APs broadcast the SSID or if it's restricted to APs matching any availability tags
     *
     * @return self
     */
    public function setAvailableOnAllAps($available_on_all_aps)
    {
        if (is_null($available_on_all_aps)) {
            throw new \InvalidArgumentException('non-nullable available_on_all_aps cannot be null');
        }
        $this->container['available_on_all_aps'] = $available_on_all_aps;

        return $this;
    }

    /**
     * Gets availability_tags
     *
     * @return string[]|null
     */
    public function getAvailabilityTags()
    {
        return $this->container['availability_tags'];
    }

    /**
     * Sets availability_tags
     *
     * @param string[]|null $availability_tags List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
     *
     * @return self
     */
    public function setAvailabilityTags($availability_tags)
    {
        if (is_null($availability_tags)) {
            throw new \InvalidArgumentException('non-nullable availability_tags cannot be null');
        }
        $this->container['availability_tags'] = $availability_tags;

        return $this;
    }

    /**
     * Gets per_ssid_bandwidth_limit_up
     *
     * @return int|null
     */
    public function getPerSsidBandwidthLimitUp()
    {
        return $this->container['per_ssid_bandwidth_limit_up'];
    }

    /**
     * Sets per_ssid_bandwidth_limit_up
     *
     * @param int|null $per_ssid_bandwidth_limit_up The total upload bandwidth limit in Kbps (0 represents no limit)
     *
     * @return self
     */
    public function setPerSsidBandwidthLimitUp($per_ssid_bandwidth_limit_up)
    {
        if (is_null($per_ssid_bandwidth_limit_up)) {
            throw new \InvalidArgumentException('non-nullable per_ssid_bandwidth_limit_up cannot be null');
        }
        $this->container['per_ssid_bandwidth_limit_up'] = $per_ssid_bandwidth_limit_up;

        return $this;
    }

    /**
     * Gets per_ssid_bandwidth_limit_down
     *
     * @return int|null
     */
    public function getPerSsidBandwidthLimitDown()
    {
        return $this->container['per_ssid_bandwidth_limit_down'];
    }

    /**
     * Sets per_ssid_bandwidth_limit_down
     *
     * @param int|null $per_ssid_bandwidth_limit_down The total download bandwidth limit in Kbps (0 represents no limit)
     *
     * @return self
     */
    public function setPerSsidBandwidthLimitDown($per_ssid_bandwidth_limit_down)
    {
        if (is_null($per_ssid_bandwidth_limit_down)) {
            throw new \InvalidArgumentException('non-nullable per_ssid_bandwidth_limit_down cannot be null');
        }
        $this->container['per_ssid_bandwidth_limit_down'] = $per_ssid_bandwidth_limit_down;

        return $this;
    }

    /**
     * Gets mandatory_dhcp_enabled
     *
     * @return bool|null
     */
    public function getMandatoryDhcpEnabled()
    {
        return $this->container['mandatory_dhcp_enabled'];
    }

    /**
     * Sets mandatory_dhcp_enabled
     *
     * @param bool|null $mandatory_dhcp_enabled Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
     *
     * @return self
     */
    public function setMandatoryDhcpEnabled($mandatory_dhcp_enabled)
    {
        if (is_null($mandatory_dhcp_enabled)) {
            throw new \InvalidArgumentException('non-nullable mandatory_dhcp_enabled cannot be null');
        }
        $this->container['mandatory_dhcp_enabled'] = $mandatory_dhcp_enabled;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


