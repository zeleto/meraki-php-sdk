<?php
/**
 * UpdateNetworkWirelessSsidRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Model;

use \ArrayAccess;
use \Meraki\ObjectSerializer;

/**
 * UpdateNetworkWirelessSsidRequest Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class UpdateNetworkWirelessSsidRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'updateNetworkWirelessSsid_request';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'name' => 'string',
        'enabled' => 'bool',
        'auth_mode' => 'string',
        'enterprise_admin_access' => 'string',
        'encryption_mode' => 'string',
        'psk' => 'string',
        'wpa_encryption_mode' => 'string',
        'dot11w' => '\Meraki\Model\UpdateNetworkApplianceSsidRequestDot11w',
        'dot11r' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestDot11r',
        'splash_page' => 'string',
        'splash_guest_sponsor_domains' => 'string[]',
        'oauth' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestOauth',
        'local_radius' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestLocalRadius',
        'ldap' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestLdap',
        'active_directory' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestActiveDirectory',
        'radius_servers' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestRadiusServersInner[]',
        'radius_proxy_enabled' => 'bool',
        'radius_testing_enabled' => 'bool',
        'radius_called_station_id' => 'string',
        'radius_authentication_nas_id' => 'string',
        'radius_server_timeout' => 'int',
        'radius_server_attempts_limit' => 'int',
        'radius_fallback_enabled' => 'bool',
        'radius_radsec' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestRadiusRadsec',
        'radius_coa_enabled' => 'bool',
        'radius_failover_policy' => 'string',
        'radius_load_balancing_policy' => 'string',
        'radius_accounting_enabled' => 'bool',
        'radius_accounting_servers' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestRadiusAccountingServersInner[]',
        'radius_accounting_interim_interval' => 'int',
        'radius_attribute_for_group_policies' => 'string',
        'ip_assignment_mode' => 'string',
        'use_vlan_tagging' => 'bool',
        'concentrator_network_id' => 'string',
        'secondary_concentrator_network_id' => 'string',
        'disassociate_clients_on_vpn_failover' => 'bool',
        'vlan_id' => 'int',
        'default_vlan_id' => 'int',
        'ap_tags_and_vlan_ids' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestApTagsAndVlanIdsInner[]',
        'walled_garden_enabled' => 'bool',
        'walled_garden_ranges' => 'string[]',
        'gre' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestGre',
        'radius_override' => 'bool',
        'radius_guest_vlan_enabled' => 'bool',
        'radius_guest_vlan_id' => 'int',
        'min_bitrate' => 'float',
        'band_selection' => 'string',
        'per_client_bandwidth_limit_up' => 'int',
        'per_client_bandwidth_limit_down' => 'int',
        'per_ssid_bandwidth_limit_up' => 'int',
        'per_ssid_bandwidth_limit_down' => 'int',
        'lan_isolation_enabled' => 'bool',
        'visible' => 'bool',
        'available_on_all_aps' => 'bool',
        'availability_tags' => 'string[]',
        'mandatory_dhcp_enabled' => 'bool',
        'adult_content_filtering_enabled' => 'bool',
        'dns_rewrite' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestDnsRewrite',
        'speed_burst' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestSpeedBurst',
        'named_vlans' => '\Meraki\Model\UpdateNetworkWirelessSsidRequestNamedVlans'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'name' => null,
        'enabled' => null,
        'auth_mode' => null,
        'enterprise_admin_access' => null,
        'encryption_mode' => null,
        'psk' => null,
        'wpa_encryption_mode' => null,
        'dot11w' => null,
        'dot11r' => null,
        'splash_page' => null,
        'splash_guest_sponsor_domains' => null,
        'oauth' => null,
        'local_radius' => null,
        'ldap' => null,
        'active_directory' => null,
        'radius_servers' => null,
        'radius_proxy_enabled' => null,
        'radius_testing_enabled' => null,
        'radius_called_station_id' => null,
        'radius_authentication_nas_id' => null,
        'radius_server_timeout' => null,
        'radius_server_attempts_limit' => null,
        'radius_fallback_enabled' => null,
        'radius_radsec' => null,
        'radius_coa_enabled' => null,
        'radius_failover_policy' => null,
        'radius_load_balancing_policy' => null,
        'radius_accounting_enabled' => null,
        'radius_accounting_servers' => null,
        'radius_accounting_interim_interval' => null,
        'radius_attribute_for_group_policies' => null,
        'ip_assignment_mode' => null,
        'use_vlan_tagging' => null,
        'concentrator_network_id' => null,
        'secondary_concentrator_network_id' => null,
        'disassociate_clients_on_vpn_failover' => null,
        'vlan_id' => null,
        'default_vlan_id' => null,
        'ap_tags_and_vlan_ids' => null,
        'walled_garden_enabled' => null,
        'walled_garden_ranges' => null,
        'gre' => null,
        'radius_override' => null,
        'radius_guest_vlan_enabled' => null,
        'radius_guest_vlan_id' => null,
        'min_bitrate' => 'float',
        'band_selection' => null,
        'per_client_bandwidth_limit_up' => null,
        'per_client_bandwidth_limit_down' => null,
        'per_ssid_bandwidth_limit_up' => null,
        'per_ssid_bandwidth_limit_down' => null,
        'lan_isolation_enabled' => null,
        'visible' => null,
        'available_on_all_aps' => null,
        'availability_tags' => null,
        'mandatory_dhcp_enabled' => null,
        'adult_content_filtering_enabled' => null,
        'dns_rewrite' => null,
        'speed_burst' => null,
        'named_vlans' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'name' => false,
        'enabled' => false,
        'auth_mode' => false,
        'enterprise_admin_access' => false,
        'encryption_mode' => false,
        'psk' => false,
        'wpa_encryption_mode' => false,
        'dot11w' => false,
        'dot11r' => false,
        'splash_page' => false,
        'splash_guest_sponsor_domains' => false,
        'oauth' => false,
        'local_radius' => false,
        'ldap' => false,
        'active_directory' => false,
        'radius_servers' => false,
        'radius_proxy_enabled' => false,
        'radius_testing_enabled' => false,
        'radius_called_station_id' => false,
        'radius_authentication_nas_id' => false,
        'radius_server_timeout' => false,
        'radius_server_attempts_limit' => false,
        'radius_fallback_enabled' => false,
        'radius_radsec' => false,
        'radius_coa_enabled' => false,
        'radius_failover_policy' => false,
        'radius_load_balancing_policy' => false,
        'radius_accounting_enabled' => false,
        'radius_accounting_servers' => false,
        'radius_accounting_interim_interval' => false,
        'radius_attribute_for_group_policies' => false,
        'ip_assignment_mode' => false,
        'use_vlan_tagging' => false,
        'concentrator_network_id' => false,
        'secondary_concentrator_network_id' => false,
        'disassociate_clients_on_vpn_failover' => false,
        'vlan_id' => false,
        'default_vlan_id' => false,
        'ap_tags_and_vlan_ids' => false,
        'walled_garden_enabled' => false,
        'walled_garden_ranges' => false,
        'gre' => false,
        'radius_override' => false,
        'radius_guest_vlan_enabled' => false,
        'radius_guest_vlan_id' => false,
        'min_bitrate' => false,
        'band_selection' => false,
        'per_client_bandwidth_limit_up' => false,
        'per_client_bandwidth_limit_down' => false,
        'per_ssid_bandwidth_limit_up' => false,
        'per_ssid_bandwidth_limit_down' => false,
        'lan_isolation_enabled' => false,
        'visible' => false,
        'available_on_all_aps' => false,
        'availability_tags' => false,
        'mandatory_dhcp_enabled' => false,
        'adult_content_filtering_enabled' => false,
        'dns_rewrite' => false,
        'speed_burst' => false,
        'named_vlans' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'enabled' => 'enabled',
        'auth_mode' => 'authMode',
        'enterprise_admin_access' => 'enterpriseAdminAccess',
        'encryption_mode' => 'encryptionMode',
        'psk' => 'psk',
        'wpa_encryption_mode' => 'wpaEncryptionMode',
        'dot11w' => 'dot11w',
        'dot11r' => 'dot11r',
        'splash_page' => 'splashPage',
        'splash_guest_sponsor_domains' => 'splashGuestSponsorDomains',
        'oauth' => 'oauth',
        'local_radius' => 'localRadius',
        'ldap' => 'ldap',
        'active_directory' => 'activeDirectory',
        'radius_servers' => 'radiusServers',
        'radius_proxy_enabled' => 'radiusProxyEnabled',
        'radius_testing_enabled' => 'radiusTestingEnabled',
        'radius_called_station_id' => 'radiusCalledStationId',
        'radius_authentication_nas_id' => 'radiusAuthenticationNasId',
        'radius_server_timeout' => 'radiusServerTimeout',
        'radius_server_attempts_limit' => 'radiusServerAttemptsLimit',
        'radius_fallback_enabled' => 'radiusFallbackEnabled',
        'radius_radsec' => 'radiusRadsec',
        'radius_coa_enabled' => 'radiusCoaEnabled',
        'radius_failover_policy' => 'radiusFailoverPolicy',
        'radius_load_balancing_policy' => 'radiusLoadBalancingPolicy',
        'radius_accounting_enabled' => 'radiusAccountingEnabled',
        'radius_accounting_servers' => 'radiusAccountingServers',
        'radius_accounting_interim_interval' => 'radiusAccountingInterimInterval',
        'radius_attribute_for_group_policies' => 'radiusAttributeForGroupPolicies',
        'ip_assignment_mode' => 'ipAssignmentMode',
        'use_vlan_tagging' => 'useVlanTagging',
        'concentrator_network_id' => 'concentratorNetworkId',
        'secondary_concentrator_network_id' => 'secondaryConcentratorNetworkId',
        'disassociate_clients_on_vpn_failover' => 'disassociateClientsOnVpnFailover',
        'vlan_id' => 'vlanId',
        'default_vlan_id' => 'defaultVlanId',
        'ap_tags_and_vlan_ids' => 'apTagsAndVlanIds',
        'walled_garden_enabled' => 'walledGardenEnabled',
        'walled_garden_ranges' => 'walledGardenRanges',
        'gre' => 'gre',
        'radius_override' => 'radiusOverride',
        'radius_guest_vlan_enabled' => 'radiusGuestVlanEnabled',
        'radius_guest_vlan_id' => 'radiusGuestVlanId',
        'min_bitrate' => 'minBitrate',
        'band_selection' => 'bandSelection',
        'per_client_bandwidth_limit_up' => 'perClientBandwidthLimitUp',
        'per_client_bandwidth_limit_down' => 'perClientBandwidthLimitDown',
        'per_ssid_bandwidth_limit_up' => 'perSsidBandwidthLimitUp',
        'per_ssid_bandwidth_limit_down' => 'perSsidBandwidthLimitDown',
        'lan_isolation_enabled' => 'lanIsolationEnabled',
        'visible' => 'visible',
        'available_on_all_aps' => 'availableOnAllAps',
        'availability_tags' => 'availabilityTags',
        'mandatory_dhcp_enabled' => 'mandatoryDhcpEnabled',
        'adult_content_filtering_enabled' => 'adultContentFilteringEnabled',
        'dns_rewrite' => 'dnsRewrite',
        'speed_burst' => 'speedBurst',
        'named_vlans' => 'namedVlans'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'enabled' => 'setEnabled',
        'auth_mode' => 'setAuthMode',
        'enterprise_admin_access' => 'setEnterpriseAdminAccess',
        'encryption_mode' => 'setEncryptionMode',
        'psk' => 'setPsk',
        'wpa_encryption_mode' => 'setWpaEncryptionMode',
        'dot11w' => 'setDot11w',
        'dot11r' => 'setDot11r',
        'splash_page' => 'setSplashPage',
        'splash_guest_sponsor_domains' => 'setSplashGuestSponsorDomains',
        'oauth' => 'setOauth',
        'local_radius' => 'setLocalRadius',
        'ldap' => 'setLdap',
        'active_directory' => 'setActiveDirectory',
        'radius_servers' => 'setRadiusServers',
        'radius_proxy_enabled' => 'setRadiusProxyEnabled',
        'radius_testing_enabled' => 'setRadiusTestingEnabled',
        'radius_called_station_id' => 'setRadiusCalledStationId',
        'radius_authentication_nas_id' => 'setRadiusAuthenticationNasId',
        'radius_server_timeout' => 'setRadiusServerTimeout',
        'radius_server_attempts_limit' => 'setRadiusServerAttemptsLimit',
        'radius_fallback_enabled' => 'setRadiusFallbackEnabled',
        'radius_radsec' => 'setRadiusRadsec',
        'radius_coa_enabled' => 'setRadiusCoaEnabled',
        'radius_failover_policy' => 'setRadiusFailoverPolicy',
        'radius_load_balancing_policy' => 'setRadiusLoadBalancingPolicy',
        'radius_accounting_enabled' => 'setRadiusAccountingEnabled',
        'radius_accounting_servers' => 'setRadiusAccountingServers',
        'radius_accounting_interim_interval' => 'setRadiusAccountingInterimInterval',
        'radius_attribute_for_group_policies' => 'setRadiusAttributeForGroupPolicies',
        'ip_assignment_mode' => 'setIpAssignmentMode',
        'use_vlan_tagging' => 'setUseVlanTagging',
        'concentrator_network_id' => 'setConcentratorNetworkId',
        'secondary_concentrator_network_id' => 'setSecondaryConcentratorNetworkId',
        'disassociate_clients_on_vpn_failover' => 'setDisassociateClientsOnVpnFailover',
        'vlan_id' => 'setVlanId',
        'default_vlan_id' => 'setDefaultVlanId',
        'ap_tags_and_vlan_ids' => 'setApTagsAndVlanIds',
        'walled_garden_enabled' => 'setWalledGardenEnabled',
        'walled_garden_ranges' => 'setWalledGardenRanges',
        'gre' => 'setGre',
        'radius_override' => 'setRadiusOverride',
        'radius_guest_vlan_enabled' => 'setRadiusGuestVlanEnabled',
        'radius_guest_vlan_id' => 'setRadiusGuestVlanId',
        'min_bitrate' => 'setMinBitrate',
        'band_selection' => 'setBandSelection',
        'per_client_bandwidth_limit_up' => 'setPerClientBandwidthLimitUp',
        'per_client_bandwidth_limit_down' => 'setPerClientBandwidthLimitDown',
        'per_ssid_bandwidth_limit_up' => 'setPerSsidBandwidthLimitUp',
        'per_ssid_bandwidth_limit_down' => 'setPerSsidBandwidthLimitDown',
        'lan_isolation_enabled' => 'setLanIsolationEnabled',
        'visible' => 'setVisible',
        'available_on_all_aps' => 'setAvailableOnAllAps',
        'availability_tags' => 'setAvailabilityTags',
        'mandatory_dhcp_enabled' => 'setMandatoryDhcpEnabled',
        'adult_content_filtering_enabled' => 'setAdultContentFilteringEnabled',
        'dns_rewrite' => 'setDnsRewrite',
        'speed_burst' => 'setSpeedBurst',
        'named_vlans' => 'setNamedVlans'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'enabled' => 'getEnabled',
        'auth_mode' => 'getAuthMode',
        'enterprise_admin_access' => 'getEnterpriseAdminAccess',
        'encryption_mode' => 'getEncryptionMode',
        'psk' => 'getPsk',
        'wpa_encryption_mode' => 'getWpaEncryptionMode',
        'dot11w' => 'getDot11w',
        'dot11r' => 'getDot11r',
        'splash_page' => 'getSplashPage',
        'splash_guest_sponsor_domains' => 'getSplashGuestSponsorDomains',
        'oauth' => 'getOauth',
        'local_radius' => 'getLocalRadius',
        'ldap' => 'getLdap',
        'active_directory' => 'getActiveDirectory',
        'radius_servers' => 'getRadiusServers',
        'radius_proxy_enabled' => 'getRadiusProxyEnabled',
        'radius_testing_enabled' => 'getRadiusTestingEnabled',
        'radius_called_station_id' => 'getRadiusCalledStationId',
        'radius_authentication_nas_id' => 'getRadiusAuthenticationNasId',
        'radius_server_timeout' => 'getRadiusServerTimeout',
        'radius_server_attempts_limit' => 'getRadiusServerAttemptsLimit',
        'radius_fallback_enabled' => 'getRadiusFallbackEnabled',
        'radius_radsec' => 'getRadiusRadsec',
        'radius_coa_enabled' => 'getRadiusCoaEnabled',
        'radius_failover_policy' => 'getRadiusFailoverPolicy',
        'radius_load_balancing_policy' => 'getRadiusLoadBalancingPolicy',
        'radius_accounting_enabled' => 'getRadiusAccountingEnabled',
        'radius_accounting_servers' => 'getRadiusAccountingServers',
        'radius_accounting_interim_interval' => 'getRadiusAccountingInterimInterval',
        'radius_attribute_for_group_policies' => 'getRadiusAttributeForGroupPolicies',
        'ip_assignment_mode' => 'getIpAssignmentMode',
        'use_vlan_tagging' => 'getUseVlanTagging',
        'concentrator_network_id' => 'getConcentratorNetworkId',
        'secondary_concentrator_network_id' => 'getSecondaryConcentratorNetworkId',
        'disassociate_clients_on_vpn_failover' => 'getDisassociateClientsOnVpnFailover',
        'vlan_id' => 'getVlanId',
        'default_vlan_id' => 'getDefaultVlanId',
        'ap_tags_and_vlan_ids' => 'getApTagsAndVlanIds',
        'walled_garden_enabled' => 'getWalledGardenEnabled',
        'walled_garden_ranges' => 'getWalledGardenRanges',
        'gre' => 'getGre',
        'radius_override' => 'getRadiusOverride',
        'radius_guest_vlan_enabled' => 'getRadiusGuestVlanEnabled',
        'radius_guest_vlan_id' => 'getRadiusGuestVlanId',
        'min_bitrate' => 'getMinBitrate',
        'band_selection' => 'getBandSelection',
        'per_client_bandwidth_limit_up' => 'getPerClientBandwidthLimitUp',
        'per_client_bandwidth_limit_down' => 'getPerClientBandwidthLimitDown',
        'per_ssid_bandwidth_limit_up' => 'getPerSsidBandwidthLimitUp',
        'per_ssid_bandwidth_limit_down' => 'getPerSsidBandwidthLimitDown',
        'lan_isolation_enabled' => 'getLanIsolationEnabled',
        'visible' => 'getVisible',
        'available_on_all_aps' => 'getAvailableOnAllAps',
        'availability_tags' => 'getAvailabilityTags',
        'mandatory_dhcp_enabled' => 'getMandatoryDhcpEnabled',
        'adult_content_filtering_enabled' => 'getAdultContentFilteringEnabled',
        'dns_rewrite' => 'getDnsRewrite',
        'speed_burst' => 'getSpeedBurst',
        'named_vlans' => 'getNamedVlans'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const AUTH_MODE__8021X_ENTRA = '8021x-entra';
    public const AUTH_MODE__8021X_GOOGLE = '8021x-google';
    public const AUTH_MODE__8021X_LOCALRADIUS = '8021x-localradius';
    public const AUTH_MODE__8021X_MERAKI = '8021x-meraki';
    public const AUTH_MODE__8021X_NAC = '8021x-nac';
    public const AUTH_MODE__8021X_RADIUS = '8021x-radius';
    public const AUTH_MODE_IPSK_WITH_NAC = 'ipsk-with-nac';
    public const AUTH_MODE_IPSK_WITH_RADIUS = 'ipsk-with-radius';
    public const AUTH_MODE_IPSK_WITH_RADIUS_EASY_PSK = 'ipsk-with-radius-easy-psk';
    public const AUTH_MODE_IPSK_WITHOUT_RADIUS = 'ipsk-without-radius';
    public const AUTH_MODE_OPEN = 'open';
    public const AUTH_MODE_OPEN_ENHANCED = 'open-enhanced';
    public const AUTH_MODE_OPEN_WITH_NAC = 'open-with-nac';
    public const AUTH_MODE_OPEN_WITH_RADIUS = 'open-with-radius';
    public const AUTH_MODE_PSK = 'psk';
    public const ENTERPRISE_ADMIN_ACCESS_ACCESS_DISABLED = 'access disabled';
    public const ENTERPRISE_ADMIN_ACCESS_ACCESS_ENABLED = 'access enabled';
    public const ENCRYPTION_MODE_OPEN = 'open';
    public const ENCRYPTION_MODE_WEP = 'wep';
    public const ENCRYPTION_MODE_WPA = 'wpa';
    public const ENCRYPTION_MODE_WPA_EAP = 'wpa-eap';
    public const WPA_ENCRYPTION_MODE_WPA1_AND_WPA2 = 'WPA1 and WPA2';
    public const WPA_ENCRYPTION_MODE_WPA1_ONLY = 'WPA1 only';
    public const WPA_ENCRYPTION_MODE_WPA2_ONLY = 'WPA2 only';
    public const WPA_ENCRYPTION_MODE_WPA3_192_BIT_SECURITY = 'WPA3 192-bit Security';
    public const WPA_ENCRYPTION_MODE_WPA3_TRANSITION_MODE = 'WPA3 Transition Mode';
    public const WPA_ENCRYPTION_MODE_WPA3_ONLY = 'WPA3 only';
    public const SPLASH_PAGE_BILLING = 'Billing';
    public const SPLASH_PAGE_CISCO_ISE = 'Cisco ISE';
    public const SPLASH_PAGE_CLICK_THROUGH_SPLASH_PAGE = 'Click-through splash page';
    public const SPLASH_PAGE_FACEBOOK_WI_FI = 'Facebook Wi-Fi';
    public const SPLASH_PAGE_GOOGLE_APPS_DOMAIN = 'Google Apps domain';
    public const SPLASH_PAGE_GOOGLE_O_AUTH = 'Google OAuth';
    public const SPLASH_PAGE_MICROSOFT_ENTRA_ID = 'Microsoft Entra ID';
    public const SPLASH_PAGE_NONE = 'None';
    public const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_ACTIVE_DIRECTORY = 'Password-protected with Active Directory';
    public const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_LDAP = 'Password-protected with LDAP';
    public const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_MERAKI_RADIUS = 'Password-protected with Meraki RADIUS';
    public const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_CUSTOM_RADIUS = 'Password-protected with custom RADIUS';
    public const SPLASH_PAGE_SMS_AUTHENTICATION = 'SMS authentication';
    public const SPLASH_PAGE_SPONSORED_GUEST = 'Sponsored guest';
    public const SPLASH_PAGE_SYSTEMS_MANAGER_SENTRY = 'Systems Manager Sentry';
    public const RADIUS_FAILOVER_POLICY_ALLOW_ACCESS = 'Allow access';
    public const RADIUS_FAILOVER_POLICY_DENY_ACCESS = 'Deny access';
    public const RADIUS_LOAD_BALANCING_POLICY_ROUND_ROBIN = 'Round robin';
    public const RADIUS_LOAD_BALANCING_POLICY_STRICT_PRIORITY_ORDER = 'Strict priority order';
    public const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_AIRESPACE_ACL_NAME = 'Airespace-ACL-Name';
    public const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_ARUBA_USER_ROLE = 'Aruba-User-Role';
    public const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_FILTER_ID = 'Filter-Id';
    public const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_REPLY_MESSAGE = 'Reply-Message';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthModeAllowableValues()
    {
        return [
            self::AUTH_MODE__8021X_ENTRA,
            self::AUTH_MODE__8021X_GOOGLE,
            self::AUTH_MODE__8021X_LOCALRADIUS,
            self::AUTH_MODE__8021X_MERAKI,
            self::AUTH_MODE__8021X_NAC,
            self::AUTH_MODE__8021X_RADIUS,
            self::AUTH_MODE_IPSK_WITH_NAC,
            self::AUTH_MODE_IPSK_WITH_RADIUS,
            self::AUTH_MODE_IPSK_WITH_RADIUS_EASY_PSK,
            self::AUTH_MODE_IPSK_WITHOUT_RADIUS,
            self::AUTH_MODE_OPEN,
            self::AUTH_MODE_OPEN_ENHANCED,
            self::AUTH_MODE_OPEN_WITH_NAC,
            self::AUTH_MODE_OPEN_WITH_RADIUS,
            self::AUTH_MODE_PSK,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getEnterpriseAdminAccessAllowableValues()
    {
        return [
            self::ENTERPRISE_ADMIN_ACCESS_ACCESS_DISABLED,
            self::ENTERPRISE_ADMIN_ACCESS_ACCESS_ENABLED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getEncryptionModeAllowableValues()
    {
        return [
            self::ENCRYPTION_MODE_OPEN,
            self::ENCRYPTION_MODE_WEP,
            self::ENCRYPTION_MODE_WPA,
            self::ENCRYPTION_MODE_WPA_EAP,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getWpaEncryptionModeAllowableValues()
    {
        return [
            self::WPA_ENCRYPTION_MODE_WPA1_AND_WPA2,
            self::WPA_ENCRYPTION_MODE_WPA1_ONLY,
            self::WPA_ENCRYPTION_MODE_WPA2_ONLY,
            self::WPA_ENCRYPTION_MODE_WPA3_192_BIT_SECURITY,
            self::WPA_ENCRYPTION_MODE_WPA3_TRANSITION_MODE,
            self::WPA_ENCRYPTION_MODE_WPA3_ONLY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSplashPageAllowableValues()
    {
        return [
            self::SPLASH_PAGE_BILLING,
            self::SPLASH_PAGE_CISCO_ISE,
            self::SPLASH_PAGE_CLICK_THROUGH_SPLASH_PAGE,
            self::SPLASH_PAGE_FACEBOOK_WI_FI,
            self::SPLASH_PAGE_GOOGLE_APPS_DOMAIN,
            self::SPLASH_PAGE_GOOGLE_O_AUTH,
            self::SPLASH_PAGE_MICROSOFT_ENTRA_ID,
            self::SPLASH_PAGE_NONE,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_ACTIVE_DIRECTORY,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_LDAP,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_MERAKI_RADIUS,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_CUSTOM_RADIUS,
            self::SPLASH_PAGE_SMS_AUTHENTICATION,
            self::SPLASH_PAGE_SPONSORED_GUEST,
            self::SPLASH_PAGE_SYSTEMS_MANAGER_SENTRY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusFailoverPolicyAllowableValues()
    {
        return [
            self::RADIUS_FAILOVER_POLICY_ALLOW_ACCESS,
            self::RADIUS_FAILOVER_POLICY_DENY_ACCESS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusLoadBalancingPolicyAllowableValues()
    {
        return [
            self::RADIUS_LOAD_BALANCING_POLICY_ROUND_ROBIN,
            self::RADIUS_LOAD_BALANCING_POLICY_STRICT_PRIORITY_ORDER,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusAttributeForGroupPoliciesAllowableValues()
    {
        return [
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_AIRESPACE_ACL_NAME,
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_ARUBA_USER_ROLE,
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_FILTER_ID,
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_REPLY_MESSAGE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('enabled', $data ?? [], null);
        $this->setIfExists('auth_mode', $data ?? [], null);
        $this->setIfExists('enterprise_admin_access', $data ?? [], null);
        $this->setIfExists('encryption_mode', $data ?? [], null);
        $this->setIfExists('psk', $data ?? [], null);
        $this->setIfExists('wpa_encryption_mode', $data ?? [], null);
        $this->setIfExists('dot11w', $data ?? [], null);
        $this->setIfExists('dot11r', $data ?? [], null);
        $this->setIfExists('splash_page', $data ?? [], null);
        $this->setIfExists('splash_guest_sponsor_domains', $data ?? [], null);
        $this->setIfExists('oauth', $data ?? [], null);
        $this->setIfExists('local_radius', $data ?? [], null);
        $this->setIfExists('ldap', $data ?? [], null);
        $this->setIfExists('active_directory', $data ?? [], null);
        $this->setIfExists('radius_servers', $data ?? [], null);
        $this->setIfExists('radius_proxy_enabled', $data ?? [], null);
        $this->setIfExists('radius_testing_enabled', $data ?? [], null);
        $this->setIfExists('radius_called_station_id', $data ?? [], null);
        $this->setIfExists('radius_authentication_nas_id', $data ?? [], null);
        $this->setIfExists('radius_server_timeout', $data ?? [], null);
        $this->setIfExists('radius_server_attempts_limit', $data ?? [], null);
        $this->setIfExists('radius_fallback_enabled', $data ?? [], null);
        $this->setIfExists('radius_radsec', $data ?? [], null);
        $this->setIfExists('radius_coa_enabled', $data ?? [], null);
        $this->setIfExists('radius_failover_policy', $data ?? [], null);
        $this->setIfExists('radius_load_balancing_policy', $data ?? [], null);
        $this->setIfExists('radius_accounting_enabled', $data ?? [], null);
        $this->setIfExists('radius_accounting_servers', $data ?? [], null);
        $this->setIfExists('radius_accounting_interim_interval', $data ?? [], null);
        $this->setIfExists('radius_attribute_for_group_policies', $data ?? [], null);
        $this->setIfExists('ip_assignment_mode', $data ?? [], null);
        $this->setIfExists('use_vlan_tagging', $data ?? [], null);
        $this->setIfExists('concentrator_network_id', $data ?? [], null);
        $this->setIfExists('secondary_concentrator_network_id', $data ?? [], null);
        $this->setIfExists('disassociate_clients_on_vpn_failover', $data ?? [], null);
        $this->setIfExists('vlan_id', $data ?? [], null);
        $this->setIfExists('default_vlan_id', $data ?? [], null);
        $this->setIfExists('ap_tags_and_vlan_ids', $data ?? [], null);
        $this->setIfExists('walled_garden_enabled', $data ?? [], null);
        $this->setIfExists('walled_garden_ranges', $data ?? [], null);
        $this->setIfExists('gre', $data ?? [], null);
        $this->setIfExists('radius_override', $data ?? [], null);
        $this->setIfExists('radius_guest_vlan_enabled', $data ?? [], null);
        $this->setIfExists('radius_guest_vlan_id', $data ?? [], null);
        $this->setIfExists('min_bitrate', $data ?? [], null);
        $this->setIfExists('band_selection', $data ?? [], null);
        $this->setIfExists('per_client_bandwidth_limit_up', $data ?? [], null);
        $this->setIfExists('per_client_bandwidth_limit_down', $data ?? [], null);
        $this->setIfExists('per_ssid_bandwidth_limit_up', $data ?? [], null);
        $this->setIfExists('per_ssid_bandwidth_limit_down', $data ?? [], null);
        $this->setIfExists('lan_isolation_enabled', $data ?? [], null);
        $this->setIfExists('visible', $data ?? [], null);
        $this->setIfExists('available_on_all_aps', $data ?? [], null);
        $this->setIfExists('availability_tags', $data ?? [], null);
        $this->setIfExists('mandatory_dhcp_enabled', $data ?? [], null);
        $this->setIfExists('adult_content_filtering_enabled', $data ?? [], null);
        $this->setIfExists('dns_rewrite', $data ?? [], null);
        $this->setIfExists('speed_burst', $data ?? [], null);
        $this->setIfExists('named_vlans', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getAuthModeAllowableValues();
        if (!is_null($this->container['auth_mode']) && !in_array($this->container['auth_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_mode', must be one of '%s'",
                $this->container['auth_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getEnterpriseAdminAccessAllowableValues();
        if (!is_null($this->container['enterprise_admin_access']) && !in_array($this->container['enterprise_admin_access'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'enterprise_admin_access', must be one of '%s'",
                $this->container['enterprise_admin_access'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getEncryptionModeAllowableValues();
        if (!is_null($this->container['encryption_mode']) && !in_array($this->container['encryption_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'encryption_mode', must be one of '%s'",
                $this->container['encryption_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getWpaEncryptionModeAllowableValues();
        if (!is_null($this->container['wpa_encryption_mode']) && !in_array($this->container['wpa_encryption_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'wpa_encryption_mode', must be one of '%s'",
                $this->container['wpa_encryption_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSplashPageAllowableValues();
        if (!is_null($this->container['splash_page']) && !in_array($this->container['splash_page'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'splash_page', must be one of '%s'",
                $this->container['splash_page'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRadiusFailoverPolicyAllowableValues();
        if (!is_null($this->container['radius_failover_policy']) && !in_array($this->container['radius_failover_policy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'radius_failover_policy', must be one of '%s'",
                $this->container['radius_failover_policy'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRadiusLoadBalancingPolicyAllowableValues();
        if (!is_null($this->container['radius_load_balancing_policy']) && !in_array($this->container['radius_load_balancing_policy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'radius_load_balancing_policy', must be one of '%s'",
                $this->container['radius_load_balancing_policy'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRadiusAttributeForGroupPoliciesAllowableValues();
        if (!is_null($this->container['radius_attribute_for_group_policies']) && !in_array($this->container['radius_attribute_for_group_policies'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'radius_attribute_for_group_policies', must be one of '%s'",
                $this->container['radius_attribute_for_group_policies'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name The name of the SSID
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets enabled
     *
     * @return bool|null
     */
    public function getEnabled()
    {
        return $this->container['enabled'];
    }

    /**
     * Sets enabled
     *
     * @param bool|null $enabled Whether or not the SSID is enabled
     *
     * @return self
     */
    public function setEnabled($enabled)
    {
        if (is_null($enabled)) {
            throw new \InvalidArgumentException('non-nullable enabled cannot be null');
        }
        $this->container['enabled'] = $enabled;

        return $this;
    }

    /**
     * Gets auth_mode
     *
     * @return string|null
     */
    public function getAuthMode()
    {
        return $this->container['auth_mode'];
    }

    /**
     * Sets auth_mode
     *
     * @param string|null $auth_mode The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-entra', '8021x-localradius', 'ipsk-with-radius', 'ipsk-without-radius', 'ipsk-with-nac' or 'ipsk-with-radius-easy-psk')
     *
     * @return self
     */
    public function setAuthMode($auth_mode)
    {
        if (is_null($auth_mode)) {
            throw new \InvalidArgumentException('non-nullable auth_mode cannot be null');
        }
        $allowedValues = $this->getAuthModeAllowableValues();
        if (!in_array($auth_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_mode', must be one of '%s'",
                    $auth_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_mode'] = $auth_mode;

        return $this;
    }

    /**
     * Gets enterprise_admin_access
     *
     * @return string|null
     */
    public function getEnterpriseAdminAccess()
    {
        return $this->container['enterprise_admin_access'];
    }

    /**
     * Sets enterprise_admin_access
     *
     * @param string|null $enterprise_admin_access Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
     *
     * @return self
     */
    public function setEnterpriseAdminAccess($enterprise_admin_access)
    {
        if (is_null($enterprise_admin_access)) {
            throw new \InvalidArgumentException('non-nullable enterprise_admin_access cannot be null');
        }
        $allowedValues = $this->getEnterpriseAdminAccessAllowableValues();
        if (!in_array($enterprise_admin_access, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'enterprise_admin_access', must be one of '%s'",
                    $enterprise_admin_access,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['enterprise_admin_access'] = $enterprise_admin_access;

        return $this;
    }

    /**
     * Gets encryption_mode
     *
     * @return string|null
     */
    public function getEncryptionMode()
    {
        return $this->container['encryption_mode'];
    }

    /**
     * Sets encryption_mode
     *
     * @param string|null $encryption_mode The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
     *
     * @return self
     */
    public function setEncryptionMode($encryption_mode)
    {
        if (is_null($encryption_mode)) {
            throw new \InvalidArgumentException('non-nullable encryption_mode cannot be null');
        }
        $allowedValues = $this->getEncryptionModeAllowableValues();
        if (!in_array($encryption_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'encryption_mode', must be one of '%s'",
                    $encryption_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['encryption_mode'] = $encryption_mode;

        return $this;
    }

    /**
     * Gets psk
     *
     * @return string|null
     */
    public function getPsk()
    {
        return $this->container['psk'];
    }

    /**
     * Sets psk
     *
     * @param string|null $psk The passkey for the SSID. This param is only valid if the authMode is 'psk'
     *
     * @return self
     */
    public function setPsk($psk)
    {
        if (is_null($psk)) {
            throw new \InvalidArgumentException('non-nullable psk cannot be null');
        }
        $this->container['psk'] = $psk;

        return $this;
    }

    /**
     * Gets wpa_encryption_mode
     *
     * @return string|null
     */
    public function getWpaEncryptionMode()
    {
        return $this->container['wpa_encryption_mode'];
    }

    /**
     * Sets wpa_encryption_mode
     *
     * @param string|null $wpa_encryption_mode The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode', 'WPA3 only' or 'WPA3 192-bit Security')
     *
     * @return self
     */
    public function setWpaEncryptionMode($wpa_encryption_mode)
    {
        if (is_null($wpa_encryption_mode)) {
            throw new \InvalidArgumentException('non-nullable wpa_encryption_mode cannot be null');
        }
        $allowedValues = $this->getWpaEncryptionModeAllowableValues();
        if (!in_array($wpa_encryption_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'wpa_encryption_mode', must be one of '%s'",
                    $wpa_encryption_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['wpa_encryption_mode'] = $wpa_encryption_mode;

        return $this;
    }

    /**
     * Gets dot11w
     *
     * @return \Meraki\Model\UpdateNetworkApplianceSsidRequestDot11w|null
     */
    public function getDot11w()
    {
        return $this->container['dot11w'];
    }

    /**
     * Sets dot11w
     *
     * @param \Meraki\Model\UpdateNetworkApplianceSsidRequestDot11w|null $dot11w dot11w
     *
     * @return self
     */
    public function setDot11w($dot11w)
    {
        if (is_null($dot11w)) {
            throw new \InvalidArgumentException('non-nullable dot11w cannot be null');
        }
        $this->container['dot11w'] = $dot11w;

        return $this;
    }

    /**
     * Gets dot11r
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestDot11r|null
     */
    public function getDot11r()
    {
        return $this->container['dot11r'];
    }

    /**
     * Sets dot11r
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestDot11r|null $dot11r dot11r
     *
     * @return self
     */
    public function setDot11r($dot11r)
    {
        if (is_null($dot11r)) {
            throw new \InvalidArgumentException('non-nullable dot11r cannot be null');
        }
        $this->container['dot11r'] = $dot11r;

        return $this;
    }

    /**
     * Gets splash_page
     *
     * @return string|null
     */
    public function getSplashPage()
    {
        return $this->container['splash_page'];
    }

    /**
     * Sets splash_page
     *
     * @param string|null $splash_page The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Microsoft Entra ID', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.
     *
     * @return self
     */
    public function setSplashPage($splash_page)
    {
        if (is_null($splash_page)) {
            throw new \InvalidArgumentException('non-nullable splash_page cannot be null');
        }
        $allowedValues = $this->getSplashPageAllowableValues();
        if (!in_array($splash_page, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'splash_page', must be one of '%s'",
                    $splash_page,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['splash_page'] = $splash_page;

        return $this;
    }

    /**
     * Gets splash_guest_sponsor_domains
     *
     * @return string[]|null
     */
    public function getSplashGuestSponsorDomains()
    {
        return $this->container['splash_guest_sponsor_domains'];
    }

    /**
     * Sets splash_guest_sponsor_domains
     *
     * @param string[]|null $splash_guest_sponsor_domains Array of valid sponsor email domains for sponsored guest splash type.
     *
     * @return self
     */
    public function setSplashGuestSponsorDomains($splash_guest_sponsor_domains)
    {
        if (is_null($splash_guest_sponsor_domains)) {
            throw new \InvalidArgumentException('non-nullable splash_guest_sponsor_domains cannot be null');
        }
        $this->container['splash_guest_sponsor_domains'] = $splash_guest_sponsor_domains;

        return $this;
    }

    /**
     * Gets oauth
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestOauth|null
     */
    public function getOauth()
    {
        return $this->container['oauth'];
    }

    /**
     * Sets oauth
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestOauth|null $oauth oauth
     *
     * @return self
     */
    public function setOauth($oauth)
    {
        if (is_null($oauth)) {
            throw new \InvalidArgumentException('non-nullable oauth cannot be null');
        }
        $this->container['oauth'] = $oauth;

        return $this;
    }

    /**
     * Gets local_radius
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestLocalRadius|null
     */
    public function getLocalRadius()
    {
        return $this->container['local_radius'];
    }

    /**
     * Sets local_radius
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestLocalRadius|null $local_radius local_radius
     *
     * @return self
     */
    public function setLocalRadius($local_radius)
    {
        if (is_null($local_radius)) {
            throw new \InvalidArgumentException('non-nullable local_radius cannot be null');
        }
        $this->container['local_radius'] = $local_radius;

        return $this;
    }

    /**
     * Gets ldap
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestLdap|null
     */
    public function getLdap()
    {
        return $this->container['ldap'];
    }

    /**
     * Sets ldap
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestLdap|null $ldap ldap
     *
     * @return self
     */
    public function setLdap($ldap)
    {
        if (is_null($ldap)) {
            throw new \InvalidArgumentException('non-nullable ldap cannot be null');
        }
        $this->container['ldap'] = $ldap;

        return $this;
    }

    /**
     * Gets active_directory
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestActiveDirectory|null
     */
    public function getActiveDirectory()
    {
        return $this->container['active_directory'];
    }

    /**
     * Sets active_directory
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestActiveDirectory|null $active_directory active_directory
     *
     * @return self
     */
    public function setActiveDirectory($active_directory)
    {
        if (is_null($active_directory)) {
            throw new \InvalidArgumentException('non-nullable active_directory cannot be null');
        }
        $this->container['active_directory'] = $active_directory;

        return $this;
    }

    /**
     * Gets radius_servers
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestRadiusServersInner[]|null
     */
    public function getRadiusServers()
    {
        return $this->container['radius_servers'];
    }

    /**
     * Sets radius_servers
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestRadiusServersInner[]|null $radius_servers The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
     *
     * @return self
     */
    public function setRadiusServers($radius_servers)
    {
        if (is_null($radius_servers)) {
            throw new \InvalidArgumentException('non-nullable radius_servers cannot be null');
        }
        $this->container['radius_servers'] = $radius_servers;

        return $this;
    }

    /**
     * Gets radius_proxy_enabled
     *
     * @return bool|null
     */
    public function getRadiusProxyEnabled()
    {
        return $this->container['radius_proxy_enabled'];
    }

    /**
     * Sets radius_proxy_enabled
     *
     * @param bool|null $radius_proxy_enabled If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
     *
     * @return self
     */
    public function setRadiusProxyEnabled($radius_proxy_enabled)
    {
        if (is_null($radius_proxy_enabled)) {
            throw new \InvalidArgumentException('non-nullable radius_proxy_enabled cannot be null');
        }
        $this->container['radius_proxy_enabled'] = $radius_proxy_enabled;

        return $this;
    }

    /**
     * Gets radius_testing_enabled
     *
     * @return bool|null
     */
    public function getRadiusTestingEnabled()
    {
        return $this->container['radius_testing_enabled'];
    }

    /**
     * Sets radius_testing_enabled
     *
     * @param bool|null $radius_testing_enabled If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable.
     *
     * @return self
     */
    public function setRadiusTestingEnabled($radius_testing_enabled)
    {
        if (is_null($radius_testing_enabled)) {
            throw new \InvalidArgumentException('non-nullable radius_testing_enabled cannot be null');
        }
        $this->container['radius_testing_enabled'] = $radius_testing_enabled;

        return $this;
    }

    /**
     * Gets radius_called_station_id
     *
     * @return string|null
     */
    public function getRadiusCalledStationId()
    {
        return $this->container['radius_called_station_id'];
    }

    /**
     * Sets radius_called_station_id
     *
     * @param string|null $radius_called_station_id The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$).
     *
     * @return self
     */
    public function setRadiusCalledStationId($radius_called_station_id)
    {
        if (is_null($radius_called_station_id)) {
            throw new \InvalidArgumentException('non-nullable radius_called_station_id cannot be null');
        }
        $this->container['radius_called_station_id'] = $radius_called_station_id;

        return $this;
    }

    /**
     * Gets radius_authentication_nas_id
     *
     * @return string|null
     */
    public function getRadiusAuthenticationNasId()
    {
        return $this->container['radius_authentication_nas_id'];
    }

    /**
     * Sets radius_authentication_nas_id
     *
     * @param string|null $radius_authentication_nas_id The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$).
     *
     * @return self
     */
    public function setRadiusAuthenticationNasId($radius_authentication_nas_id)
    {
        if (is_null($radius_authentication_nas_id)) {
            throw new \InvalidArgumentException('non-nullable radius_authentication_nas_id cannot be null');
        }
        $this->container['radius_authentication_nas_id'] = $radius_authentication_nas_id;

        return $this;
    }

    /**
     * Gets radius_server_timeout
     *
     * @return int|null
     */
    public function getRadiusServerTimeout()
    {
        return $this->container['radius_server_timeout'];
    }

    /**
     * Sets radius_server_timeout
     *
     * @param int|null $radius_server_timeout The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
     *
     * @return self
     */
    public function setRadiusServerTimeout($radius_server_timeout)
    {
        if (is_null($radius_server_timeout)) {
            throw new \InvalidArgumentException('non-nullable radius_server_timeout cannot be null');
        }
        $this->container['radius_server_timeout'] = $radius_server_timeout;

        return $this;
    }

    /**
     * Gets radius_server_attempts_limit
     *
     * @return int|null
     */
    public function getRadiusServerAttemptsLimit()
    {
        return $this->container['radius_server_attempts_limit'];
    }

    /**
     * Sets radius_server_attempts_limit
     *
     * @param int|null $radius_server_attempts_limit The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
     *
     * @return self
     */
    public function setRadiusServerAttemptsLimit($radius_server_attempts_limit)
    {
        if (is_null($radius_server_attempts_limit)) {
            throw new \InvalidArgumentException('non-nullable radius_server_attempts_limit cannot be null');
        }
        $this->container['radius_server_attempts_limit'] = $radius_server_attempts_limit;

        return $this;
    }

    /**
     * Gets radius_fallback_enabled
     *
     * @return bool|null
     */
    public function getRadiusFallbackEnabled()
    {
        return $this->container['radius_fallback_enabled'];
    }

    /**
     * Sets radius_fallback_enabled
     *
     * @param bool|null $radius_fallback_enabled Whether or not higher priority RADIUS servers should be retried after 60 seconds.
     *
     * @return self
     */
    public function setRadiusFallbackEnabled($radius_fallback_enabled)
    {
        if (is_null($radius_fallback_enabled)) {
            throw new \InvalidArgumentException('non-nullable radius_fallback_enabled cannot be null');
        }
        $this->container['radius_fallback_enabled'] = $radius_fallback_enabled;

        return $this;
    }

    /**
     * Gets radius_radsec
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestRadiusRadsec|null
     */
    public function getRadiusRadsec()
    {
        return $this->container['radius_radsec'];
    }

    /**
     * Sets radius_radsec
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestRadiusRadsec|null $radius_radsec radius_radsec
     *
     * @return self
     */
    public function setRadiusRadsec($radius_radsec)
    {
        if (is_null($radius_radsec)) {
            throw new \InvalidArgumentException('non-nullable radius_radsec cannot be null');
        }
        $this->container['radius_radsec'] = $radius_radsec;

        return $this;
    }

    /**
     * Gets radius_coa_enabled
     *
     * @return bool|null
     */
    public function getRadiusCoaEnabled()
    {
        return $this->container['radius_coa_enabled'];
    }

    /**
     * Sets radius_coa_enabled
     *
     * @param bool|null $radius_coa_enabled If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
     *
     * @return self
     */
    public function setRadiusCoaEnabled($radius_coa_enabled)
    {
        if (is_null($radius_coa_enabled)) {
            throw new \InvalidArgumentException('non-nullable radius_coa_enabled cannot be null');
        }
        $this->container['radius_coa_enabled'] = $radius_coa_enabled;

        return $this;
    }

    /**
     * Gets radius_failover_policy
     *
     * @return string|null
     */
    public function getRadiusFailoverPolicy()
    {
        return $this->container['radius_failover_policy'];
    }

    /**
     * Sets radius_failover_policy
     *
     * @param string|null $radius_failover_policy This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
     *
     * @return self
     */
    public function setRadiusFailoverPolicy($radius_failover_policy)
    {
        if (is_null($radius_failover_policy)) {
            throw new \InvalidArgumentException('non-nullable radius_failover_policy cannot be null');
        }
        $allowedValues = $this->getRadiusFailoverPolicyAllowableValues();
        if (!in_array($radius_failover_policy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'radius_failover_policy', must be one of '%s'",
                    $radius_failover_policy,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_failover_policy'] = $radius_failover_policy;

        return $this;
    }

    /**
     * Gets radius_load_balancing_policy
     *
     * @return string|null
     */
    public function getRadiusLoadBalancingPolicy()
    {
        return $this->container['radius_load_balancing_policy'];
    }

    /**
     * Sets radius_load_balancing_policy
     *
     * @param string|null $radius_load_balancing_policy This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
     *
     * @return self
     */
    public function setRadiusLoadBalancingPolicy($radius_load_balancing_policy)
    {
        if (is_null($radius_load_balancing_policy)) {
            throw new \InvalidArgumentException('non-nullable radius_load_balancing_policy cannot be null');
        }
        $allowedValues = $this->getRadiusLoadBalancingPolicyAllowableValues();
        if (!in_array($radius_load_balancing_policy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'radius_load_balancing_policy', must be one of '%s'",
                    $radius_load_balancing_policy,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_load_balancing_policy'] = $radius_load_balancing_policy;

        return $this;
    }

    /**
     * Gets radius_accounting_enabled
     *
     * @return bool|null
     */
    public function getRadiusAccountingEnabled()
    {
        return $this->container['radius_accounting_enabled'];
    }

    /**
     * Sets radius_accounting_enabled
     *
     * @param bool|null $radius_accounting_enabled Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
     *
     * @return self
     */
    public function setRadiusAccountingEnabled($radius_accounting_enabled)
    {
        if (is_null($radius_accounting_enabled)) {
            throw new \InvalidArgumentException('non-nullable radius_accounting_enabled cannot be null');
        }
        $this->container['radius_accounting_enabled'] = $radius_accounting_enabled;

        return $this;
    }

    /**
     * Gets radius_accounting_servers
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestRadiusAccountingServersInner[]|null
     */
    public function getRadiusAccountingServers()
    {
        return $this->container['radius_accounting_servers'];
    }

    /**
     * Sets radius_accounting_servers
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestRadiusAccountingServersInner[]|null $radius_accounting_servers The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
     *
     * @return self
     */
    public function setRadiusAccountingServers($radius_accounting_servers)
    {
        if (is_null($radius_accounting_servers)) {
            throw new \InvalidArgumentException('non-nullable radius_accounting_servers cannot be null');
        }
        $this->container['radius_accounting_servers'] = $radius_accounting_servers;

        return $this;
    }

    /**
     * Gets radius_accounting_interim_interval
     *
     * @return int|null
     */
    public function getRadiusAccountingInterimInterval()
    {
        return $this->container['radius_accounting_interim_interval'];
    }

    /**
     * Sets radius_accounting_interim_interval
     *
     * @param int|null $radius_accounting_interim_interval The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
     *
     * @return self
     */
    public function setRadiusAccountingInterimInterval($radius_accounting_interim_interval)
    {
        if (is_null($radius_accounting_interim_interval)) {
            throw new \InvalidArgumentException('non-nullable radius_accounting_interim_interval cannot be null');
        }
        $this->container['radius_accounting_interim_interval'] = $radius_accounting_interim_interval;

        return $this;
    }

    /**
     * Gets radius_attribute_for_group_policies
     *
     * @return string|null
     */
    public function getRadiusAttributeForGroupPolicies()
    {
        return $this->container['radius_attribute_for_group_policies'];
    }

    /**
     * Sets radius_attribute_for_group_policies
     *
     * @param string|null $radius_attribute_for_group_policies Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
     *
     * @return self
     */
    public function setRadiusAttributeForGroupPolicies($radius_attribute_for_group_policies)
    {
        if (is_null($radius_attribute_for_group_policies)) {
            throw new \InvalidArgumentException('non-nullable radius_attribute_for_group_policies cannot be null');
        }
        $allowedValues = $this->getRadiusAttributeForGroupPoliciesAllowableValues();
        if (!in_array($radius_attribute_for_group_policies, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'radius_attribute_for_group_policies', must be one of '%s'",
                    $radius_attribute_for_group_policies,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_attribute_for_group_policies'] = $radius_attribute_for_group_policies;

        return $this;
    }

    /**
     * Gets ip_assignment_mode
     *
     * @return string|null
     */
    public function getIpAssignmentMode()
    {
        return $this->container['ip_assignment_mode'];
    }

    /**
     * Sets ip_assignment_mode
     *
     * @param string|null $ip_assignment_mode The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN')
     *
     * @return self
     */
    public function setIpAssignmentMode($ip_assignment_mode)
    {
        if (is_null($ip_assignment_mode)) {
            throw new \InvalidArgumentException('non-nullable ip_assignment_mode cannot be null');
        }
        $this->container['ip_assignment_mode'] = $ip_assignment_mode;

        return $this;
    }

    /**
     * Gets use_vlan_tagging
     *
     * @return bool|null
     */
    public function getUseVlanTagging()
    {
        return $this->container['use_vlan_tagging'];
    }

    /**
     * Sets use_vlan_tagging
     *
     * @param bool|null $use_vlan_tagging Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
     *
     * @return self
     */
    public function setUseVlanTagging($use_vlan_tagging)
    {
        if (is_null($use_vlan_tagging)) {
            throw new \InvalidArgumentException('non-nullable use_vlan_tagging cannot be null');
        }
        $this->container['use_vlan_tagging'] = $use_vlan_tagging;

        return $this;
    }

    /**
     * Gets concentrator_network_id
     *
     * @return string|null
     */
    public function getConcentratorNetworkId()
    {
        return $this->container['concentrator_network_id'];
    }

    /**
     * Sets concentrator_network_id
     *
     * @param string|null $concentrator_network_id The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
     *
     * @return self
     */
    public function setConcentratorNetworkId($concentrator_network_id)
    {
        if (is_null($concentrator_network_id)) {
            throw new \InvalidArgumentException('non-nullable concentrator_network_id cannot be null');
        }
        $this->container['concentrator_network_id'] = $concentrator_network_id;

        return $this;
    }

    /**
     * Gets secondary_concentrator_network_id
     *
     * @return string|null
     */
    public function getSecondaryConcentratorNetworkId()
    {
        return $this->container['secondary_concentrator_network_id'];
    }

    /**
     * Sets secondary_concentrator_network_id
     *
     * @param string|null $secondary_concentrator_network_id The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.)
     *
     * @return self
     */
    public function setSecondaryConcentratorNetworkId($secondary_concentrator_network_id)
    {
        if (is_null($secondary_concentrator_network_id)) {
            throw new \InvalidArgumentException('non-nullable secondary_concentrator_network_id cannot be null');
        }
        $this->container['secondary_concentrator_network_id'] = $secondary_concentrator_network_id;

        return $this;
    }

    /**
     * Gets disassociate_clients_on_vpn_failover
     *
     * @return bool|null
     */
    public function getDisassociateClientsOnVpnFailover()
    {
        return $this->container['disassociate_clients_on_vpn_failover'];
    }

    /**
     * Sets disassociate_clients_on_vpn_failover
     *
     * @param bool|null $disassociate_clients_on_vpn_failover Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'.
     *
     * @return self
     */
    public function setDisassociateClientsOnVpnFailover($disassociate_clients_on_vpn_failover)
    {
        if (is_null($disassociate_clients_on_vpn_failover)) {
            throw new \InvalidArgumentException('non-nullable disassociate_clients_on_vpn_failover cannot be null');
        }
        $this->container['disassociate_clients_on_vpn_failover'] = $disassociate_clients_on_vpn_failover;

        return $this;
    }

    /**
     * Gets vlan_id
     *
     * @return int|null
     */
    public function getVlanId()
    {
        return $this->container['vlan_id'];
    }

    /**
     * Sets vlan_id
     *
     * @param int|null $vlan_id The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
     *
     * @return self
     */
    public function setVlanId($vlan_id)
    {
        if (is_null($vlan_id)) {
            throw new \InvalidArgumentException('non-nullable vlan_id cannot be null');
        }
        $this->container['vlan_id'] = $vlan_id;

        return $this;
    }

    /**
     * Gets default_vlan_id
     *
     * @return int|null
     */
    public function getDefaultVlanId()
    {
        return $this->container['default_vlan_id'];
    }

    /**
     * Sets default_vlan_id
     *
     * @param int|null $default_vlan_id The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
     *
     * @return self
     */
    public function setDefaultVlanId($default_vlan_id)
    {
        if (is_null($default_vlan_id)) {
            throw new \InvalidArgumentException('non-nullable default_vlan_id cannot be null');
        }
        $this->container['default_vlan_id'] = $default_vlan_id;

        return $this;
    }

    /**
     * Gets ap_tags_and_vlan_ids
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestApTagsAndVlanIdsInner[]|null
     */
    public function getApTagsAndVlanIds()
    {
        return $this->container['ap_tags_and_vlan_ids'];
    }

    /**
     * Sets ap_tags_and_vlan_ids
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestApTagsAndVlanIdsInner[]|null $ap_tags_and_vlan_ids The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
     *
     * @return self
     */
    public function setApTagsAndVlanIds($ap_tags_and_vlan_ids)
    {
        if (is_null($ap_tags_and_vlan_ids)) {
            throw new \InvalidArgumentException('non-nullable ap_tags_and_vlan_ids cannot be null');
        }
        $this->container['ap_tags_and_vlan_ids'] = $ap_tags_and_vlan_ids;

        return $this;
    }

    /**
     * Gets walled_garden_enabled
     *
     * @return bool|null
     */
    public function getWalledGardenEnabled()
    {
        return $this->container['walled_garden_enabled'];
    }

    /**
     * Sets walled_garden_enabled
     *
     * @param bool|null $walled_garden_enabled Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
     *
     * @return self
     */
    public function setWalledGardenEnabled($walled_garden_enabled)
    {
        if (is_null($walled_garden_enabled)) {
            throw new \InvalidArgumentException('non-nullable walled_garden_enabled cannot be null');
        }
        $this->container['walled_garden_enabled'] = $walled_garden_enabled;

        return $this;
    }

    /**
     * Gets walled_garden_ranges
     *
     * @return string[]|null
     */
    public function getWalledGardenRanges()
    {
        return $this->container['walled_garden_ranges'];
    }

    /**
     * Sets walled_garden_ranges
     *
     * @param string[]|null $walled_garden_ranges Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden.
     *
     * @return self
     */
    public function setWalledGardenRanges($walled_garden_ranges)
    {
        if (is_null($walled_garden_ranges)) {
            throw new \InvalidArgumentException('non-nullable walled_garden_ranges cannot be null');
        }
        $this->container['walled_garden_ranges'] = $walled_garden_ranges;

        return $this;
    }

    /**
     * Gets gre
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestGre|null
     */
    public function getGre()
    {
        return $this->container['gre'];
    }

    /**
     * Sets gre
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestGre|null $gre gre
     *
     * @return self
     */
    public function setGre($gre)
    {
        if (is_null($gre)) {
            throw new \InvalidArgumentException('non-nullable gre cannot be null');
        }
        $this->container['gre'] = $gre;

        return $this;
    }

    /**
     * Gets radius_override
     *
     * @return bool|null
     */
    public function getRadiusOverride()
    {
        return $this->container['radius_override'];
    }

    /**
     * Sets radius_override
     *
     * @param bool|null $radius_override If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
     *
     * @return self
     */
    public function setRadiusOverride($radius_override)
    {
        if (is_null($radius_override)) {
            throw new \InvalidArgumentException('non-nullable radius_override cannot be null');
        }
        $this->container['radius_override'] = $radius_override;

        return $this;
    }

    /**
     * Gets radius_guest_vlan_enabled
     *
     * @return bool|null
     */
    public function getRadiusGuestVlanEnabled()
    {
        return $this->container['radius_guest_vlan_enabled'];
    }

    /**
     * Sets radius_guest_vlan_enabled
     *
     * @param bool|null $radius_guest_vlan_enabled Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
     *
     * @return self
     */
    public function setRadiusGuestVlanEnabled($radius_guest_vlan_enabled)
    {
        if (is_null($radius_guest_vlan_enabled)) {
            throw new \InvalidArgumentException('non-nullable radius_guest_vlan_enabled cannot be null');
        }
        $this->container['radius_guest_vlan_enabled'] = $radius_guest_vlan_enabled;

        return $this;
    }

    /**
     * Gets radius_guest_vlan_id
     *
     * @return int|null
     */
    public function getRadiusGuestVlanId()
    {
        return $this->container['radius_guest_vlan_id'];
    }

    /**
     * Sets radius_guest_vlan_id
     *
     * @param int|null $radius_guest_vlan_id VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
     *
     * @return self
     */
    public function setRadiusGuestVlanId($radius_guest_vlan_id)
    {
        if (is_null($radius_guest_vlan_id)) {
            throw new \InvalidArgumentException('non-nullable radius_guest_vlan_id cannot be null');
        }
        $this->container['radius_guest_vlan_id'] = $radius_guest_vlan_id;

        return $this;
    }

    /**
     * Gets min_bitrate
     *
     * @return float|null
     */
    public function getMinBitrate()
    {
        return $this->container['min_bitrate'];
    }

    /**
     * Sets min_bitrate
     *
     * @param float|null $min_bitrate The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
     *
     * @return self
     */
    public function setMinBitrate($min_bitrate)
    {
        if (is_null($min_bitrate)) {
            throw new \InvalidArgumentException('non-nullable min_bitrate cannot be null');
        }
        $this->container['min_bitrate'] = $min_bitrate;

        return $this;
    }

    /**
     * Gets band_selection
     *
     * @return string|null
     */
    public function getBandSelection()
    {
        return $this->container['band_selection'];
    }

    /**
     * Sets band_selection
     *
     * @param string|null $band_selection The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
     *
     * @return self
     */
    public function setBandSelection($band_selection)
    {
        if (is_null($band_selection)) {
            throw new \InvalidArgumentException('non-nullable band_selection cannot be null');
        }
        $this->container['band_selection'] = $band_selection;

        return $this;
    }

    /**
     * Gets per_client_bandwidth_limit_up
     *
     * @return int|null
     */
    public function getPerClientBandwidthLimitUp()
    {
        return $this->container['per_client_bandwidth_limit_up'];
    }

    /**
     * Sets per_client_bandwidth_limit_up
     *
     * @param int|null $per_client_bandwidth_limit_up The upload bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return self
     */
    public function setPerClientBandwidthLimitUp($per_client_bandwidth_limit_up)
    {
        if (is_null($per_client_bandwidth_limit_up)) {
            throw new \InvalidArgumentException('non-nullable per_client_bandwidth_limit_up cannot be null');
        }
        $this->container['per_client_bandwidth_limit_up'] = $per_client_bandwidth_limit_up;

        return $this;
    }

    /**
     * Gets per_client_bandwidth_limit_down
     *
     * @return int|null
     */
    public function getPerClientBandwidthLimitDown()
    {
        return $this->container['per_client_bandwidth_limit_down'];
    }

    /**
     * Sets per_client_bandwidth_limit_down
     *
     * @param int|null $per_client_bandwidth_limit_down The download bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return self
     */
    public function setPerClientBandwidthLimitDown($per_client_bandwidth_limit_down)
    {
        if (is_null($per_client_bandwidth_limit_down)) {
            throw new \InvalidArgumentException('non-nullable per_client_bandwidth_limit_down cannot be null');
        }
        $this->container['per_client_bandwidth_limit_down'] = $per_client_bandwidth_limit_down;

        return $this;
    }

    /**
     * Gets per_ssid_bandwidth_limit_up
     *
     * @return int|null
     */
    public function getPerSsidBandwidthLimitUp()
    {
        return $this->container['per_ssid_bandwidth_limit_up'];
    }

    /**
     * Sets per_ssid_bandwidth_limit_up
     *
     * @param int|null $per_ssid_bandwidth_limit_up The total upload bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return self
     */
    public function setPerSsidBandwidthLimitUp($per_ssid_bandwidth_limit_up)
    {
        if (is_null($per_ssid_bandwidth_limit_up)) {
            throw new \InvalidArgumentException('non-nullable per_ssid_bandwidth_limit_up cannot be null');
        }
        $this->container['per_ssid_bandwidth_limit_up'] = $per_ssid_bandwidth_limit_up;

        return $this;
    }

    /**
     * Gets per_ssid_bandwidth_limit_down
     *
     * @return int|null
     */
    public function getPerSsidBandwidthLimitDown()
    {
        return $this->container['per_ssid_bandwidth_limit_down'];
    }

    /**
     * Sets per_ssid_bandwidth_limit_down
     *
     * @param int|null $per_ssid_bandwidth_limit_down The total download bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return self
     */
    public function setPerSsidBandwidthLimitDown($per_ssid_bandwidth_limit_down)
    {
        if (is_null($per_ssid_bandwidth_limit_down)) {
            throw new \InvalidArgumentException('non-nullable per_ssid_bandwidth_limit_down cannot be null');
        }
        $this->container['per_ssid_bandwidth_limit_down'] = $per_ssid_bandwidth_limit_down;

        return $this;
    }

    /**
     * Gets lan_isolation_enabled
     *
     * @return bool|null
     */
    public function getLanIsolationEnabled()
    {
        return $this->container['lan_isolation_enabled'];
    }

    /**
     * Sets lan_isolation_enabled
     *
     * @param bool|null $lan_isolation_enabled Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
     *
     * @return self
     */
    public function setLanIsolationEnabled($lan_isolation_enabled)
    {
        if (is_null($lan_isolation_enabled)) {
            throw new \InvalidArgumentException('non-nullable lan_isolation_enabled cannot be null');
        }
        $this->container['lan_isolation_enabled'] = $lan_isolation_enabled;

        return $this;
    }

    /**
     * Gets visible
     *
     * @return bool|null
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool|null $visible Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
     *
     * @return self
     */
    public function setVisible($visible)
    {
        if (is_null($visible)) {
            throw new \InvalidArgumentException('non-nullable visible cannot be null');
        }
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets available_on_all_aps
     *
     * @return bool|null
     */
    public function getAvailableOnAllAps()
    {
        return $this->container['available_on_all_aps'];
    }

    /**
     * Sets available_on_all_aps
     *
     * @param bool|null $available_on_all_aps Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
     *
     * @return self
     */
    public function setAvailableOnAllAps($available_on_all_aps)
    {
        if (is_null($available_on_all_aps)) {
            throw new \InvalidArgumentException('non-nullable available_on_all_aps cannot be null');
        }
        $this->container['available_on_all_aps'] = $available_on_all_aps;

        return $this;
    }

    /**
     * Gets availability_tags
     *
     * @return string[]|null
     */
    public function getAvailabilityTags()
    {
        return $this->container['availability_tags'];
    }

    /**
     * Sets availability_tags
     *
     * @param string[]|null $availability_tags Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
     *
     * @return self
     */
    public function setAvailabilityTags($availability_tags)
    {
        if (is_null($availability_tags)) {
            throw new \InvalidArgumentException('non-nullable availability_tags cannot be null');
        }
        $this->container['availability_tags'] = $availability_tags;

        return $this;
    }

    /**
     * Gets mandatory_dhcp_enabled
     *
     * @return bool|null
     */
    public function getMandatoryDhcpEnabled()
    {
        return $this->container['mandatory_dhcp_enabled'];
    }

    /**
     * Sets mandatory_dhcp_enabled
     *
     * @param bool|null $mandatory_dhcp_enabled If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate.
     *
     * @return self
     */
    public function setMandatoryDhcpEnabled($mandatory_dhcp_enabled)
    {
        if (is_null($mandatory_dhcp_enabled)) {
            throw new \InvalidArgumentException('non-nullable mandatory_dhcp_enabled cannot be null');
        }
        $this->container['mandatory_dhcp_enabled'] = $mandatory_dhcp_enabled;

        return $this;
    }

    /**
     * Gets adult_content_filtering_enabled
     *
     * @return bool|null
     */
    public function getAdultContentFilteringEnabled()
    {
        return $this->container['adult_content_filtering_enabled'];
    }

    /**
     * Sets adult_content_filtering_enabled
     *
     * @param bool|null $adult_content_filtering_enabled Boolean indicating whether or not adult content will be blocked
     *
     * @return self
     */
    public function setAdultContentFilteringEnabled($adult_content_filtering_enabled)
    {
        if (is_null($adult_content_filtering_enabled)) {
            throw new \InvalidArgumentException('non-nullable adult_content_filtering_enabled cannot be null');
        }
        $this->container['adult_content_filtering_enabled'] = $adult_content_filtering_enabled;

        return $this;
    }

    /**
     * Gets dns_rewrite
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestDnsRewrite|null
     */
    public function getDnsRewrite()
    {
        return $this->container['dns_rewrite'];
    }

    /**
     * Sets dns_rewrite
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestDnsRewrite|null $dns_rewrite dns_rewrite
     *
     * @return self
     */
    public function setDnsRewrite($dns_rewrite)
    {
        if (is_null($dns_rewrite)) {
            throw new \InvalidArgumentException('non-nullable dns_rewrite cannot be null');
        }
        $this->container['dns_rewrite'] = $dns_rewrite;

        return $this;
    }

    /**
     * Gets speed_burst
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestSpeedBurst|null
     */
    public function getSpeedBurst()
    {
        return $this->container['speed_burst'];
    }

    /**
     * Sets speed_burst
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestSpeedBurst|null $speed_burst speed_burst
     *
     * @return self
     */
    public function setSpeedBurst($speed_burst)
    {
        if (is_null($speed_burst)) {
            throw new \InvalidArgumentException('non-nullable speed_burst cannot be null');
        }
        $this->container['speed_burst'] = $speed_burst;

        return $this;
    }

    /**
     * Gets named_vlans
     *
     * @return \Meraki\Model\UpdateNetworkWirelessSsidRequestNamedVlans|null
     */
    public function getNamedVlans()
    {
        return $this->container['named_vlans'];
    }

    /**
     * Sets named_vlans
     *
     * @param \Meraki\Model\UpdateNetworkWirelessSsidRequestNamedVlans|null $named_vlans named_vlans
     *
     * @return self
     */
    public function setNamedVlans($named_vlans)
    {
        if (is_null($named_vlans)) {
            throw new \InvalidArgumentException('non-nullable named_vlans cannot be null');
        }
        $this->container['named_vlans'] = $named_vlans;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


