<?php
/**
 * UplinksApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Meraki\ApiException;
use Meraki\Configuration;
use Meraki\HeaderSelector;
use Meraki\ObjectSerializer;

/**
 * UplinksApi Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UplinksApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getDeviceApplianceUplinksSettings' => [
            'application/json',
        ],
        'getDeviceLossAndLatencyHistory' => [
            'application/json',
        ],
        'getNetworkApplianceUplinksUsageHistory' => [
            'application/json',
        ],
        'getOrganizationApplianceUplinkStatuses' => [
            'application/json',
        ],
        'getOrganizationApplianceUplinksStatusesOverview' => [
            'application/json',
        ],
        'getOrganizationApplianceUplinksUsageByNetwork' => [
            'application/json',
        ],
        'getOrganizationDevicesUplinksAddressesByDevice' => [
            'application/json',
        ],
        'getOrganizationDevicesUplinksLossAndLatency' => [
            'application/json',
        ],
        'getOrganizationUplinksStatuses' => [
            'application/json',
        ],
        'updateDeviceApplianceUplinksSettings' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getDeviceApplianceUplinksSettings
     *
     * Return the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceApplianceUplinksSettings200Response
     */
    public function getDeviceApplianceUplinksSettings($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {
        list($response) = $this->getDeviceApplianceUplinksSettingsWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceApplianceUplinksSettingsWithHttpInfo
     *
     * Return the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceApplianceUplinksSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceApplianceUplinksSettingsWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {
        $request = $this->getDeviceApplianceUplinksSettingsRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceApplianceUplinksSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceApplianceUplinksSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceApplianceUplinksSettingsAsync
     *
     * Return the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceUplinksSettingsAsync($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {
        return $this->getDeviceApplianceUplinksSettingsAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceApplianceUplinksSettingsAsyncWithHttpInfo
     *
     * Return the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceUplinksSettingsAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response';
        $request = $this->getDeviceApplianceUplinksSettingsRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceApplianceUplinksSettings'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceApplianceUplinksSettingsRequest($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceApplianceUplinksSettings'
            );
        }


        $resourcePath = '/devices/{serial}/appliance/uplinks/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLossAndLatencyHistory
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for MX, MG and Z devices.
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]
     */
    public function getDeviceLossAndLatencyHistory($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {
        list($response) = $this->getDeviceLossAndLatencyHistoryWithHttpInfo($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLossAndLatencyHistoryWithHttpInfo
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for MX, MG and Z devices.
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLossAndLatencyHistoryWithHttpInfo($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {
        $request = $this->getDeviceLossAndLatencyHistoryRequest($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLossAndLatencyHistoryAsync
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for MX, MG and Z devices.
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLossAndLatencyHistoryAsync($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {
        return $this->getDeviceLossAndLatencyHistoryAsyncWithHttpInfo($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLossAndLatencyHistoryAsyncWithHttpInfo
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for MX, MG and Z devices.
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLossAndLatencyHistoryAsyncWithHttpInfo($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]';
        $request = $this->getDeviceLossAndLatencyHistoryRequest($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLossAndLatencyHistory'
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLossAndLatencyHistoryRequest($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLossAndLatencyHistory'
            );
        }

        // verify the required parameter 'ip' is set
        if ($ip === null || (is_array($ip) && count($ip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip when calling getDeviceLossAndLatencyHistory'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling UplinksApi.getDeviceLossAndLatencyHistory, must be smaller than or equal to 2678400.');
        }
        



        $resourcePath = '/devices/{serial}/lossAndLatencyHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uplink,
            'uplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip,
            'ip', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceUplinksUsageHistory
     *
     * Get the sent and received bytes for each uplink of a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]
     */
    public function getNetworkApplianceUplinksUsageHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {
        list($response) = $this->getNetworkApplianceUplinksUsageHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceUplinksUsageHistoryWithHttpInfo
     *
     * Get the sent and received bytes for each uplink of a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceUplinksUsageHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {
        $request = $this->getNetworkApplianceUplinksUsageHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceUplinksUsageHistoryAsync
     *
     * Get the sent and received bytes for each uplink of a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceUplinksUsageHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {
        return $this->getNetworkApplianceUplinksUsageHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceUplinksUsageHistoryAsyncWithHttpInfo
     *
     * Get the sent and received bytes for each uplink of a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceUplinksUsageHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]';
        $request = $this->getNetworkApplianceUplinksUsageHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceUplinksUsageHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceUplinksUsageHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceUplinksUsageHistory'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling UplinksApi.getNetworkApplianceUplinksUsageHistory, must be smaller than or equal to 2678400.');
        }
        


        $resourcePath = '/networks/{networkId}/appliance/uplinks/usageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceUplinkStatuses
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]
     */
    public function getOrganizationApplianceUplinkStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {
        list($response) = $this->getOrganizationApplianceUplinkStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceUplinkStatusesWithHttpInfo
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceUplinkStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {
        $request = $this->getOrganizationApplianceUplinkStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceUplinkStatusesAsync
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinkStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {
        return $this->getOrganizationApplianceUplinkStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceUplinkStatusesAsyncWithHttpInfo
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinkStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]';
        $request = $this->getOrganizationApplianceUplinkStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceUplinkStatuses'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceUplinkStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceUplinkStatuses'
            );
        }








        $resourcePath = '/organizations/{organizationId}/appliance/uplink/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $iccids,
            'iccids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceUplinksStatusesOverview
     *
     * Returns an overview of uplink statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response
     */
    public function getOrganizationApplianceUplinksStatusesOverview($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {
        list($response) = $this->getOrganizationApplianceUplinksStatusesOverviewWithHttpInfo($organization_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceUplinksStatusesOverviewWithHttpInfo
     *
     * Returns an overview of uplink statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceUplinksStatusesOverviewWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {
        $request = $this->getOrganizationApplianceUplinksStatusesOverviewRequest($organization_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceUplinksStatusesOverviewAsync
     *
     * Returns an overview of uplink statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinksStatusesOverviewAsync($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {
        return $this->getOrganizationApplianceUplinksStatusesOverviewAsyncWithHttpInfo($organization_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceUplinksStatusesOverviewAsyncWithHttpInfo
     *
     * Returns an overview of uplink statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinksStatusesOverviewAsyncWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response';
        $request = $this->getOrganizationApplianceUplinksStatusesOverviewRequest($organization_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceUplinksStatusesOverview'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceUplinksStatusesOverviewRequest($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceUplinksStatusesOverview'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/uplinks/statuses/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceUplinksUsageByNetwork
     *
     * Get the sent and received bytes for each uplink of all MX and Z networks within an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]
     */
    public function getOrganizationApplianceUplinksUsageByNetwork($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {
        list($response) = $this->getOrganizationApplianceUplinksUsageByNetworkWithHttpInfo($organization_id, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceUplinksUsageByNetworkWithHttpInfo
     *
     * Get the sent and received bytes for each uplink of all MX and Z networks within an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceUplinksUsageByNetworkWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {
        $request = $this->getOrganizationApplianceUplinksUsageByNetworkRequest($organization_id, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceUplinksUsageByNetworkAsync
     *
     * Get the sent and received bytes for each uplink of all MX and Z networks within an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinksUsageByNetworkAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {
        return $this->getOrganizationApplianceUplinksUsageByNetworkAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceUplinksUsageByNetworkAsyncWithHttpInfo
     *
     * Get the sent and received bytes for each uplink of all MX and Z networks within an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinksUsageByNetworkAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]';
        $request = $this->getOrganizationApplianceUplinksUsageByNetworkRequest($organization_id, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceUplinksUsageByNetwork'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceUplinksUsageByNetworkRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceUplinksUsageByNetwork'
            );
        }



        if ($timespan !== null && $timespan > 1209600) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling UplinksApi.getOrganizationApplianceUplinksUsageByNetwork, must be smaller than or equal to 1209600.');
        }
        

        $resourcePath = '/organizations/{organizationId}/appliance/uplinks/usage/byNetwork';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesUplinksAddressesByDevice
     *
     * List the current uplink addresses for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]
     */
    public function getOrganizationDevicesUplinksAddressesByDevice($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {
        list($response) = $this->getOrganizationDevicesUplinksAddressesByDeviceWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesUplinksAddressesByDeviceWithHttpInfo
     *
     * List the current uplink addresses for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesUplinksAddressesByDeviceWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {
        $request = $this->getOrganizationDevicesUplinksAddressesByDeviceRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesUplinksAddressesByDeviceAsync
     *
     * List the current uplink addresses for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksAddressesByDeviceAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {
        return $this->getOrganizationDevicesUplinksAddressesByDeviceAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesUplinksAddressesByDeviceAsyncWithHttpInfo
     *
     * List the current uplink addresses for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksAddressesByDeviceAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]';
        $request = $this->getOrganizationDevicesUplinksAddressesByDeviceRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesUplinksAddressesByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesUplinksAddressesByDeviceRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesUplinksAddressesByDevice'
            );
        }










        $resourcePath = '/organizations/{organizationId}/devices/uplinks/addresses/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags_filter_type,
            'tagsFilterType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatency
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]
     */
    public function getOrganizationDevicesUplinksLossAndLatency($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {
        list($response) = $this->getOrganizationDevicesUplinksLossAndLatencyWithHttpInfo($organization_id, $t0, $t1, $timespan, $uplink, $ip, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatencyWithHttpInfo
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesUplinksLossAndLatencyWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {
        $request = $this->getOrganizationDevicesUplinksLossAndLatencyRequest($organization_id, $t0, $t1, $timespan, $uplink, $ip, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatencyAsync
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksLossAndLatencyAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {
        return $this->getOrganizationDevicesUplinksLossAndLatencyAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $uplink, $ip, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatencyAsyncWithHttpInfo
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksLossAndLatencyAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]';
        $request = $this->getOrganizationDevicesUplinksLossAndLatencyRequest($organization_id, $t0, $t1, $timespan, $uplink, $ip, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesUplinksLossAndLatency'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesUplinksLossAndLatencyRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesUplinksLossAndLatency'
            );
        }



        if ($timespan !== null && $timespan > 300) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling UplinksApi.getOrganizationDevicesUplinksLossAndLatency, must be smaller than or equal to 300.');
        }
        



        $resourcePath = '/organizations/{organizationId}/devices/uplinksLossAndLatency';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uplink,
            'uplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip,
            'ip', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationUplinksStatuses
     *
     * List the uplink status of every Meraki MX, MG and Z series devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationUplinksStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationUplinksStatuses200ResponseInner[]
     */
    public function getOrganizationUplinksStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationUplinksStatuses'][0])
    {
        list($response) = $this->getOrganizationUplinksStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationUplinksStatusesWithHttpInfo
     *
     * List the uplink status of every Meraki MX, MG and Z series devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationUplinksStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationUplinksStatuses200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationUplinksStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationUplinksStatuses'][0])
    {
        $request = $this->getOrganizationUplinksStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationUplinksStatuses200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationUplinksStatuses200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationUplinksStatuses200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationUplinksStatuses200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationUplinksStatuses200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationUplinksStatusesAsync
     *
     * List the uplink status of every Meraki MX, MG and Z series devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationUplinksStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationUplinksStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationUplinksStatuses'][0])
    {
        return $this->getOrganizationUplinksStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationUplinksStatusesAsyncWithHttpInfo
     *
     * List the uplink status of every Meraki MX, MG and Z series devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationUplinksStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationUplinksStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationUplinksStatuses'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationUplinksStatuses200ResponseInner[]';
        $request = $this->getOrganizationUplinksStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationUplinksStatuses'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationUplinksStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationUplinksStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationUplinksStatuses'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationUplinksStatuses'
            );
        }








        $resourcePath = '/organizations/{organizationId}/uplinks/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $iccids,
            'iccids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDeviceApplianceUplinksSettings
     *
     * Update the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceApplianceUplinksSettings200Response
     */
    public function updateDeviceApplianceUplinksSettings($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {
        list($response) = $this->updateDeviceApplianceUplinksSettingsWithHttpInfo($serial, $update_device_appliance_uplinks_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateDeviceApplianceUplinksSettingsWithHttpInfo
     *
     * Update the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceApplianceUplinksSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDeviceApplianceUplinksSettingsWithHttpInfo($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {
        $request = $this->updateDeviceApplianceUplinksSettingsRequest($serial, $update_device_appliance_uplinks_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceApplianceUplinksSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceApplianceUplinksSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDeviceApplianceUplinksSettingsAsync
     *
     * Update the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceApplianceUplinksSettingsAsync($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {
        return $this->updateDeviceApplianceUplinksSettingsAsyncWithHttpInfo($serial, $update_device_appliance_uplinks_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDeviceApplianceUplinksSettingsAsyncWithHttpInfo
     *
     * Update the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceApplianceUplinksSettingsAsyncWithHttpInfo($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response';
        $request = $this->updateDeviceApplianceUplinksSettingsRequest($serial, $update_device_appliance_uplinks_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDeviceApplianceUplinksSettings'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDeviceApplianceUplinksSettingsRequest($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling updateDeviceApplianceUplinksSettings'
            );
        }

        // verify the required parameter 'update_device_appliance_uplinks_settings_request' is set
        if ($update_device_appliance_uplinks_settings_request === null || (is_array($update_device_appliance_uplinks_settings_request) && count($update_device_appliance_uplinks_settings_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_device_appliance_uplinks_settings_request when calling updateDeviceApplianceUplinksSettings'
            );
        }


        $resourcePath = '/devices/{serial}/appliance/uplinks/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_device_appliance_uplinks_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_device_appliance_uplinks_settings_request));
            } else {
                $httpBody = $update_device_appliance_uplinks_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
