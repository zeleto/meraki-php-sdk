<?php
/**
 * MerakiAuthUsersApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Meraki\ApiException;
use Meraki\Configuration;
use Meraki\HeaderSelector;
use Meraki\ObjectSerializer;

/**
 * MerakiAuthUsersApi Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MerakiAuthUsersApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createNetworkMerakiAuthUser' => [
            'application/json',
        ],
        'deleteNetworkMerakiAuthUser' => [
            'application/json',
        ],
        'getNetworkMerakiAuthUser' => [
            'application/json',
        ],
        'getNetworkMerakiAuthUsers' => [
            'application/json',
        ],
        'updateNetworkMerakiAuthUser' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createNetworkMerakiAuthUser
     *
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner
     */
    public function createNetworkMerakiAuthUser($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {
        list($response) = $this->createNetworkMerakiAuthUserWithHttpInfo($network_id, $create_network_meraki_auth_user_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkMerakiAuthUserWithHttpInfo
     *
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkMerakiAuthUserWithHttpInfo($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {
        $request = $this->createNetworkMerakiAuthUserRequest($network_id, $create_network_meraki_auth_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkMerakiAuthUserAsync
     *
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkMerakiAuthUserAsync($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {
        return $this->createNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $create_network_meraki_auth_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkMerakiAuthUserAsyncWithHttpInfo
     *
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
        $request = $this->createNetworkMerakiAuthUserRequest($network_id, $create_network_meraki_auth_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkMerakiAuthUser'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkMerakiAuthUserRequest($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkMerakiAuthUser'
            );
        }

        // verify the required parameter 'create_network_meraki_auth_user_request' is set
        if ($create_network_meraki_auth_user_request === null || (is_array($create_network_meraki_auth_user_request) && count($create_network_meraki_auth_user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_meraki_auth_user_request when calling createNetworkMerakiAuthUser'
            );
        }


        $resourcePath = '/networks/{networkId}/merakiAuthUsers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_meraki_auth_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_meraki_auth_user_request));
            } else {
                $httpBody = $create_network_meraki_auth_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkMerakiAuthUser
     *
     * Delete an 802.1X RADIUS user, or deauthorize and optionally delete a splash guest or client VPN user.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkMerakiAuthUser($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {
        $this->deleteNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $delete, $contentType);
    }

    /**
     * Operation deleteNetworkMerakiAuthUserWithHttpInfo
     *
     * Delete an 802.1X RADIUS user, or deauthorize and optionally delete a splash guest or client VPN user.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {
        $request = $this->deleteNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $delete, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkMerakiAuthUserAsync
     *
     * Delete an 802.1X RADIUS user, or deauthorize and optionally delete a splash guest or client VPN user.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkMerakiAuthUserAsync($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {
        return $this->deleteNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $delete, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkMerakiAuthUserAsyncWithHttpInfo
     *
     * Delete an 802.1X RADIUS user, or deauthorize and optionally delete a splash guest or client VPN user.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $delete, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkMerakiAuthUser'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkMerakiAuthUser'
            );
        }

        // verify the required parameter 'meraki_auth_user_id' is set
        if ($meraki_auth_user_id === null || (is_array($meraki_auth_user_id) && count($meraki_auth_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meraki_auth_user_id when calling deleteNetworkMerakiAuthUser'
            );
        }



        $resourcePath = '/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete,
            'delete', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($meraki_auth_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merakiAuthUserId' . '}',
                ObjectSerializer::toPathValue($meraki_auth_user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkMerakiAuthUser
     *
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner
     */
    public function getNetworkMerakiAuthUser($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {
        list($response) = $this->getNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkMerakiAuthUserWithHttpInfo
     *
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {
        $request = $this->getNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkMerakiAuthUserAsync
     *
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMerakiAuthUserAsync($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {
        return $this->getNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkMerakiAuthUserAsyncWithHttpInfo
     *
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
        $request = $this->getNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkMerakiAuthUser'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkMerakiAuthUser'
            );
        }

        // verify the required parameter 'meraki_auth_user_id' is set
        if ($meraki_auth_user_id === null || (is_array($meraki_auth_user_id) && count($meraki_auth_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meraki_auth_user_id when calling getNetworkMerakiAuthUser'
            );
        }


        $resourcePath = '/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($meraki_auth_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merakiAuthUserId' . '}',
                ObjectSerializer::toPathValue($meraki_auth_user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkMerakiAuthUsers
     *
     * List the authorized users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a MX network)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]
     */
    public function getNetworkMerakiAuthUsers($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {
        list($response) = $this->getNetworkMerakiAuthUsersWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkMerakiAuthUsersWithHttpInfo
     *
     * List the authorized users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a MX network)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkMerakiAuthUsersWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {
        $request = $this->getNetworkMerakiAuthUsersRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkMerakiAuthUsersAsync
     *
     * List the authorized users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a MX network)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMerakiAuthUsersAsync($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {
        return $this->getNetworkMerakiAuthUsersAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkMerakiAuthUsersAsyncWithHttpInfo
     *
     * List the authorized users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a MX network)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMerakiAuthUsersAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]';
        $request = $this->getNetworkMerakiAuthUsersRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkMerakiAuthUsers'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkMerakiAuthUsersRequest($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkMerakiAuthUsers'
            );
        }


        $resourcePath = '/networks/{networkId}/merakiAuthUsers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkMerakiAuthUser
     *
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner
     */
    public function updateNetworkMerakiAuthUser($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {
        list($response) = $this->updateNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkMerakiAuthUserWithHttpInfo
     *
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {
        $request = $this->updateNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkMerakiAuthUserAsync
     *
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkMerakiAuthUserAsync($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {
        return $this->updateNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkMerakiAuthUserAsyncWithHttpInfo
     *
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
        $request = $this->updateNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkMerakiAuthUser'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkMerakiAuthUser'
            );
        }

        // verify the required parameter 'meraki_auth_user_id' is set
        if ($meraki_auth_user_id === null || (is_array($meraki_auth_user_id) && count($meraki_auth_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meraki_auth_user_id when calling updateNetworkMerakiAuthUser'
            );
        }



        $resourcePath = '/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($meraki_auth_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merakiAuthUserId' . '}',
                ObjectSerializer::toPathValue($meraki_auth_user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_meraki_auth_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_meraki_auth_user_request));
            } else {
                $httpBody = $update_network_meraki_auth_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
