<?php
/**
 * AlertsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Meraki\ApiException;
use Meraki\Configuration;
use Meraki\HeaderSelector;
use Meraki\ObjectSerializer;

/**
 * AlertsApi Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AlertsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createNetworkSensorAlertsProfile' => [
            'application/json',
        ],
        'createOrganizationAlertsProfile' => [
            'application/json',
        ],
        'deleteNetworkSensorAlertsProfile' => [
            'application/json',
        ],
        'deleteOrganizationAlertsProfile' => [
            'application/json',
        ],
        'dismissOrganizationAssuranceAlerts' => [
            'application/json',
        ],
        'getNetworkAlertsHistory' => [
            'application/json',
        ],
        'getNetworkAlertsSettings' => [
            'application/json',
        ],
        'getNetworkHealthAlerts' => [
            'application/json',
        ],
        'getNetworkSensorAlertsCurrentOverviewByMetric' => [
            'application/json',
        ],
        'getNetworkSensorAlertsOverviewByMetric' => [
            'application/json',
        ],
        'getNetworkSensorAlertsProfile' => [
            'application/json',
        ],
        'getNetworkSensorAlertsProfiles' => [
            'application/json',
        ],
        'getOrganizationAlertsProfiles' => [
            'application/json',
        ],
        'getOrganizationAssuranceAlert' => [
            'application/json',
        ],
        'getOrganizationAssuranceAlerts' => [
            'application/json',
        ],
        'getOrganizationAssuranceAlertsOverview' => [
            'application/json',
        ],
        'getOrganizationAssuranceAlertsOverviewByNetwork' => [
            'application/json',
        ],
        'getOrganizationAssuranceAlertsOverviewByType' => [
            'application/json',
        ],
        'getOrganizationAssuranceAlertsOverviewHistorical' => [
            'application/json',
        ],
        'restoreOrganizationAssuranceAlerts' => [
            'application/json',
        ],
        'updateNetworkAlertsSettings' => [
            'application/json',
        ],
        'updateNetworkSensorAlertsProfile' => [
            'application/json',
        ],
        'updateOrganizationAlertsProfile' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createNetworkSensorAlertsProfile
     *
     * Creates a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkSensorAlertsProfileRequest $create_network_sensor_alerts_profile_request create_network_sensor_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner
     */
    public function createNetworkSensorAlertsProfile($network_id, $create_network_sensor_alerts_profile_request, string $contentType = self::contentTypes['createNetworkSensorAlertsProfile'][0])
    {
        list($response) = $this->createNetworkSensorAlertsProfileWithHttpInfo($network_id, $create_network_sensor_alerts_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkSensorAlertsProfileWithHttpInfo
     *
     * Creates a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkSensorAlertsProfileRequest $create_network_sensor_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkSensorAlertsProfileWithHttpInfo($network_id, $create_network_sensor_alerts_profile_request, string $contentType = self::contentTypes['createNetworkSensorAlertsProfile'][0])
    {
        $request = $this->createNetworkSensorAlertsProfileRequest($network_id, $create_network_sensor_alerts_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkSensorAlertsProfileAsync
     *
     * Creates a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkSensorAlertsProfileRequest $create_network_sensor_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkSensorAlertsProfileAsync($network_id, $create_network_sensor_alerts_profile_request, string $contentType = self::contentTypes['createNetworkSensorAlertsProfile'][0])
    {
        return $this->createNetworkSensorAlertsProfileAsyncWithHttpInfo($network_id, $create_network_sensor_alerts_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkSensorAlertsProfileAsyncWithHttpInfo
     *
     * Creates a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkSensorAlertsProfileRequest $create_network_sensor_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkSensorAlertsProfileAsyncWithHttpInfo($network_id, $create_network_sensor_alerts_profile_request, string $contentType = self::contentTypes['createNetworkSensorAlertsProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner';
        $request = $this->createNetworkSensorAlertsProfileRequest($network_id, $create_network_sensor_alerts_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkSensorAlertsProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkSensorAlertsProfileRequest $create_network_sensor_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkSensorAlertsProfileRequest($network_id, $create_network_sensor_alerts_profile_request, string $contentType = self::contentTypes['createNetworkSensorAlertsProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkSensorAlertsProfile'
            );
        }

        // verify the required parameter 'create_network_sensor_alerts_profile_request' is set
        if ($create_network_sensor_alerts_profile_request === null || (is_array($create_network_sensor_alerts_profile_request) && count($create_network_sensor_alerts_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_sensor_alerts_profile_request when calling createNetworkSensorAlertsProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/sensor/alerts/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_sensor_alerts_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_sensor_alerts_profile_request));
            } else {
                $httpBody = $create_network_sensor_alerts_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationAlertsProfile
     *
     * Create an organization-wide alert configuration
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationAlertsProfileRequest $create_organization_alerts_profile_request create_organization_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner
     */
    public function createOrganizationAlertsProfile($organization_id, $create_organization_alerts_profile_request, string $contentType = self::contentTypes['createOrganizationAlertsProfile'][0])
    {
        list($response) = $this->createOrganizationAlertsProfileWithHttpInfo($organization_id, $create_organization_alerts_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationAlertsProfileWithHttpInfo
     *
     * Create an organization-wide alert configuration
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationAlertsProfileRequest $create_organization_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationAlertsProfileWithHttpInfo($organization_id, $create_organization_alerts_profile_request, string $contentType = self::contentTypes['createOrganizationAlertsProfile'][0])
    {
        $request = $this->createOrganizationAlertsProfileRequest($organization_id, $create_organization_alerts_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationAlertsProfileAsync
     *
     * Create an organization-wide alert configuration
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationAlertsProfileRequest $create_organization_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationAlertsProfileAsync($organization_id, $create_organization_alerts_profile_request, string $contentType = self::contentTypes['createOrganizationAlertsProfile'][0])
    {
        return $this->createOrganizationAlertsProfileAsyncWithHttpInfo($organization_id, $create_organization_alerts_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationAlertsProfileAsyncWithHttpInfo
     *
     * Create an organization-wide alert configuration
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationAlertsProfileRequest $create_organization_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationAlertsProfileAsyncWithHttpInfo($organization_id, $create_organization_alerts_profile_request, string $contentType = self::contentTypes['createOrganizationAlertsProfile'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner';
        $request = $this->createOrganizationAlertsProfileRequest($organization_id, $create_organization_alerts_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationAlertsProfile'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationAlertsProfileRequest $create_organization_alerts_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationAlertsProfileRequest($organization_id, $create_organization_alerts_profile_request, string $contentType = self::contentTypes['createOrganizationAlertsProfile'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationAlertsProfile'
            );
        }

        // verify the required parameter 'create_organization_alerts_profile_request' is set
        if ($create_organization_alerts_profile_request === null || (is_array($create_organization_alerts_profile_request) && count($create_organization_alerts_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_alerts_profile_request when calling createOrganizationAlertsProfile'
            );
        }


        $resourcePath = '/organizations/{organizationId}/alerts/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_alerts_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_alerts_profile_request));
            } else {
                $httpBody = $create_organization_alerts_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkSensorAlertsProfile
     *
     * Deletes a sensor alert profile from a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkSensorAlertsProfile($network_id, $id, string $contentType = self::contentTypes['deleteNetworkSensorAlertsProfile'][0])
    {
        $this->deleteNetworkSensorAlertsProfileWithHttpInfo($network_id, $id, $contentType);
    }

    /**
     * Operation deleteNetworkSensorAlertsProfileWithHttpInfo
     *
     * Deletes a sensor alert profile from a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkSensorAlertsProfileWithHttpInfo($network_id, $id, string $contentType = self::contentTypes['deleteNetworkSensorAlertsProfile'][0])
    {
        $request = $this->deleteNetworkSensorAlertsProfileRequest($network_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkSensorAlertsProfileAsync
     *
     * Deletes a sensor alert profile from a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkSensorAlertsProfileAsync($network_id, $id, string $contentType = self::contentTypes['deleteNetworkSensorAlertsProfile'][0])
    {
        return $this->deleteNetworkSensorAlertsProfileAsyncWithHttpInfo($network_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkSensorAlertsProfileAsyncWithHttpInfo
     *
     * Deletes a sensor alert profile from a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkSensorAlertsProfileAsyncWithHttpInfo($network_id, $id, string $contentType = self::contentTypes['deleteNetworkSensorAlertsProfile'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkSensorAlertsProfileRequest($network_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkSensorAlertsProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkSensorAlertsProfileRequest($network_id, $id, string $contentType = self::contentTypes['deleteNetworkSensorAlertsProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkSensorAlertsProfile'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteNetworkSensorAlertsProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/sensor/alerts/profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOrganizationAlertsProfile
     *
     * Removes an organization-wide alert config
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOrganizationAlertsProfile($organization_id, $alert_config_id, string $contentType = self::contentTypes['deleteOrganizationAlertsProfile'][0])
    {
        $this->deleteOrganizationAlertsProfileWithHttpInfo($organization_id, $alert_config_id, $contentType);
    }

    /**
     * Operation deleteOrganizationAlertsProfileWithHttpInfo
     *
     * Removes an organization-wide alert config
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOrganizationAlertsProfileWithHttpInfo($organization_id, $alert_config_id, string $contentType = self::contentTypes['deleteOrganizationAlertsProfile'][0])
    {
        $request = $this->deleteOrganizationAlertsProfileRequest($organization_id, $alert_config_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOrganizationAlertsProfileAsync
     *
     * Removes an organization-wide alert config
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrganizationAlertsProfileAsync($organization_id, $alert_config_id, string $contentType = self::contentTypes['deleteOrganizationAlertsProfile'][0])
    {
        return $this->deleteOrganizationAlertsProfileAsyncWithHttpInfo($organization_id, $alert_config_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOrganizationAlertsProfileAsyncWithHttpInfo
     *
     * Removes an organization-wide alert config
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrganizationAlertsProfileAsyncWithHttpInfo($organization_id, $alert_config_id, string $contentType = self::contentTypes['deleteOrganizationAlertsProfile'][0])
    {
        $returnType = '';
        $request = $this->deleteOrganizationAlertsProfileRequest($organization_id, $alert_config_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOrganizationAlertsProfile'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteOrganizationAlertsProfileRequest($organization_id, $alert_config_id, string $contentType = self::contentTypes['deleteOrganizationAlertsProfile'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling deleteOrganizationAlertsProfile'
            );
        }

        // verify the required parameter 'alert_config_id' is set
        if ($alert_config_id === null || (is_array($alert_config_id) && count($alert_config_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_config_id when calling deleteOrganizationAlertsProfile'
            );
        }


        $resourcePath = '/organizations/{organizationId}/alerts/profiles/{alertConfigId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($alert_config_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alertConfigId' . '}',
                ObjectSerializer::toPathValue($alert_config_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dismissOrganizationAssuranceAlerts
     *
     * Dismiss health alerts
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DismissOrganizationAssuranceAlertsRequest $dismiss_organization_assurance_alerts_request dismiss_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dismissOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dismissOrganizationAssuranceAlerts($organization_id, $dismiss_organization_assurance_alerts_request, string $contentType = self::contentTypes['dismissOrganizationAssuranceAlerts'][0])
    {
        $this->dismissOrganizationAssuranceAlertsWithHttpInfo($organization_id, $dismiss_organization_assurance_alerts_request, $contentType);
    }

    /**
     * Operation dismissOrganizationAssuranceAlertsWithHttpInfo
     *
     * Dismiss health alerts
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DismissOrganizationAssuranceAlertsRequest $dismiss_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dismissOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dismissOrganizationAssuranceAlertsWithHttpInfo($organization_id, $dismiss_organization_assurance_alerts_request, string $contentType = self::contentTypes['dismissOrganizationAssuranceAlerts'][0])
    {
        $request = $this->dismissOrganizationAssuranceAlertsRequest($organization_id, $dismiss_organization_assurance_alerts_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation dismissOrganizationAssuranceAlertsAsync
     *
     * Dismiss health alerts
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DismissOrganizationAssuranceAlertsRequest $dismiss_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dismissOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dismissOrganizationAssuranceAlertsAsync($organization_id, $dismiss_organization_assurance_alerts_request, string $contentType = self::contentTypes['dismissOrganizationAssuranceAlerts'][0])
    {
        return $this->dismissOrganizationAssuranceAlertsAsyncWithHttpInfo($organization_id, $dismiss_organization_assurance_alerts_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dismissOrganizationAssuranceAlertsAsyncWithHttpInfo
     *
     * Dismiss health alerts
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DismissOrganizationAssuranceAlertsRequest $dismiss_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dismissOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dismissOrganizationAssuranceAlertsAsyncWithHttpInfo($organization_id, $dismiss_organization_assurance_alerts_request, string $contentType = self::contentTypes['dismissOrganizationAssuranceAlerts'][0])
    {
        $returnType = '';
        $request = $this->dismissOrganizationAssuranceAlertsRequest($organization_id, $dismiss_organization_assurance_alerts_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dismissOrganizationAssuranceAlerts'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DismissOrganizationAssuranceAlertsRequest $dismiss_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['dismissOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function dismissOrganizationAssuranceAlertsRequest($organization_id, $dismiss_organization_assurance_alerts_request, string $contentType = self::contentTypes['dismissOrganizationAssuranceAlerts'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling dismissOrganizationAssuranceAlerts'
            );
        }

        // verify the required parameter 'dismiss_organization_assurance_alerts_request' is set
        if ($dismiss_organization_assurance_alerts_request === null || (is_array($dismiss_organization_assurance_alerts_request) && count($dismiss_organization_assurance_alerts_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dismiss_organization_assurance_alerts_request when calling dismissOrganizationAssuranceAlerts'
            );
        }


        $resourcePath = '/organizations/{organizationId}/assurance/alerts/dismiss';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($dismiss_organization_assurance_alerts_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($dismiss_organization_assurance_alerts_request));
            } else {
                $httpBody = $dismiss_organization_assurance_alerts_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkAlertsHistory
     *
     * Return the alert history for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]
     */
    public function getNetworkAlertsHistory($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {
        list($response) = $this->getNetworkAlertsHistoryWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkAlertsHistoryWithHttpInfo
     *
     * Return the alert history for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAlertsHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkAlertsHistoryWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {
        $request = $this->getNetworkAlertsHistoryRequest($network_id, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkAlertsHistoryAsync
     *
     * Return the alert history for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAlertsHistoryAsync($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {
        return $this->getNetworkAlertsHistoryAsyncWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkAlertsHistoryAsyncWithHttpInfo
     *
     * Return the alert history for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAlertsHistoryAsyncWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]';
        $request = $this->getNetworkAlertsHistoryRequest($network_id, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkAlertsHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkAlertsHistoryRequest($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkAlertsHistory'
            );
        }





        $resourcePath = '/networks/{networkId}/alerts/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkAlertsSettings
     *
     * Return the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAlertsSettings200Response
     */
    public function getNetworkAlertsSettings($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {
        list($response) = $this->getNetworkAlertsSettingsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkAlertsSettingsWithHttpInfo
     *
     * Return the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAlertsSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkAlertsSettingsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {
        $request = $this->getNetworkAlertsSettingsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAlertsSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAlertsSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAlertsSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAlertsSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAlertsSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkAlertsSettingsAsync
     *
     * Return the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAlertsSettingsAsync($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {
        return $this->getNetworkAlertsSettingsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkAlertsSettingsAsyncWithHttpInfo
     *
     * Return the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAlertsSettingsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAlertsSettings200Response';
        $request = $this->getNetworkAlertsSettingsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkAlertsSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkAlertsSettingsRequest($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkAlertsSettings'
            );
        }


        $resourcePath = '/networks/{networkId}/alerts/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkHealthAlerts
     *
     * Return all global alerts on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]
     * @deprecated
     */
    public function getNetworkHealthAlerts($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {
        list($response) = $this->getNetworkHealthAlertsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkHealthAlertsWithHttpInfo
     *
     * Return all global alerts on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkHealthAlerts200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getNetworkHealthAlertsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {
        $request = $this->getNetworkHealthAlertsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkHealthAlertsAsync
     *
     * Return all global alerts on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getNetworkHealthAlertsAsync($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {
        return $this->getNetworkHealthAlertsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkHealthAlertsAsyncWithHttpInfo
     *
     * Return all global alerts on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getNetworkHealthAlertsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]';
        $request = $this->getNetworkHealthAlertsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkHealthAlerts'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getNetworkHealthAlertsRequest($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkHealthAlerts'
            );
        }


        $resourcePath = '/networks/{networkId}/health/alerts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSensorAlertsCurrentOverviewByMetric
     *
     * Return an overview of currently alerting sensors by metric
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSensorAlertsCurrentOverviewByMetric200Response
     */
    public function getNetworkSensorAlertsCurrentOverviewByMetric($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'][0])
    {
        list($response) = $this->getNetworkSensorAlertsCurrentOverviewByMetricWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSensorAlertsCurrentOverviewByMetricWithHttpInfo
     *
     * Return an overview of currently alerting sensors by metric
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSensorAlertsCurrentOverviewByMetric200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSensorAlertsCurrentOverviewByMetricWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'][0])
    {
        $request = $this->getNetworkSensorAlertsCurrentOverviewByMetricRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSensorAlertsCurrentOverviewByMetric200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSensorAlertsCurrentOverviewByMetric200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSensorAlertsCurrentOverviewByMetric200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSensorAlertsCurrentOverviewByMetric200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSensorAlertsCurrentOverviewByMetric200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSensorAlertsCurrentOverviewByMetricAsync
     *
     * Return an overview of currently alerting sensors by metric
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSensorAlertsCurrentOverviewByMetricAsync($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'][0])
    {
        return $this->getNetworkSensorAlertsCurrentOverviewByMetricAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSensorAlertsCurrentOverviewByMetricAsyncWithHttpInfo
     *
     * Return an overview of currently alerting sensors by metric
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSensorAlertsCurrentOverviewByMetricAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSensorAlertsCurrentOverviewByMetric200Response';
        $request = $this->getNetworkSensorAlertsCurrentOverviewByMetricRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSensorAlertsCurrentOverviewByMetric'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSensorAlertsCurrentOverviewByMetricRequest($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsCurrentOverviewByMetric'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSensorAlertsCurrentOverviewByMetric'
            );
        }


        $resourcePath = '/networks/{networkId}/sensor/alerts/current/overview/byMetric';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSensorAlertsOverviewByMetric
     *
     * Return an overview of alert occurrences over a timespan, by metric
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 731 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 366 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 366 days. The default is 7 days. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 900, 3600, 86400, 604800, 2592000. The default is 604800. Interval is calculated if time params are provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSensorAlertsOverviewByMetric200ResponseInner[]
     */
    public function getNetworkSensorAlertsOverviewByMetric($network_id, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getNetworkSensorAlertsOverviewByMetric'][0])
    {
        list($response) = $this->getNetworkSensorAlertsOverviewByMetricWithHttpInfo($network_id, $t0, $t1, $timespan, $interval, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSensorAlertsOverviewByMetricWithHttpInfo
     *
     * Return an overview of alert occurrences over a timespan, by metric
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 731 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 366 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 366 days. The default is 7 days. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 900, 3600, 86400, 604800, 2592000. The default is 604800. Interval is calculated if time params are provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSensorAlertsOverviewByMetric200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSensorAlertsOverviewByMetricWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getNetworkSensorAlertsOverviewByMetric'][0])
    {
        $request = $this->getNetworkSensorAlertsOverviewByMetricRequest($network_id, $t0, $t1, $timespan, $interval, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSensorAlertsOverviewByMetric200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSensorAlertsOverviewByMetric200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSensorAlertsOverviewByMetric200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSensorAlertsOverviewByMetric200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSensorAlertsOverviewByMetric200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSensorAlertsOverviewByMetricAsync
     *
     * Return an overview of alert occurrences over a timespan, by metric
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 731 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 366 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 366 days. The default is 7 days. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 900, 3600, 86400, 604800, 2592000. The default is 604800. Interval is calculated if time params are provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSensorAlertsOverviewByMetricAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getNetworkSensorAlertsOverviewByMetric'][0])
    {
        return $this->getNetworkSensorAlertsOverviewByMetricAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $interval, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSensorAlertsOverviewByMetricAsyncWithHttpInfo
     *
     * Return an overview of alert occurrences over a timespan, by metric
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 731 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 366 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 366 days. The default is 7 days. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 900, 3600, 86400, 604800, 2592000. The default is 604800. Interval is calculated if time params are provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSensorAlertsOverviewByMetricAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getNetworkSensorAlertsOverviewByMetric'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSensorAlertsOverviewByMetric200ResponseInner[]';
        $request = $this->getNetworkSensorAlertsOverviewByMetricRequest($network_id, $t0, $t1, $timespan, $interval, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSensorAlertsOverviewByMetric'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 731 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 366 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 366 days. The default is 7 days. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 900, 3600, 86400, 604800, 2592000. The default is 604800. Interval is calculated if time params are provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsOverviewByMetric'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSensorAlertsOverviewByMetricRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getNetworkSensorAlertsOverviewByMetric'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSensorAlertsOverviewByMetric'
            );
        }



        if ($timespan !== null && $timespan > 31622400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling AlertsApi.getNetworkSensorAlertsOverviewByMetric, must be smaller than or equal to 31622400.');
        }
        


        $resourcePath = '/networks/{networkId}/sensor/alerts/overview/byMetric';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSensorAlertsProfile
     *
     * Show details of a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner
     */
    public function getNetworkSensorAlertsProfile($network_id, $id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfile'][0])
    {
        list($response) = $this->getNetworkSensorAlertsProfileWithHttpInfo($network_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSensorAlertsProfileWithHttpInfo
     *
     * Show details of a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSensorAlertsProfileWithHttpInfo($network_id, $id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfile'][0])
    {
        $request = $this->getNetworkSensorAlertsProfileRequest($network_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSensorAlertsProfileAsync
     *
     * Show details of a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSensorAlertsProfileAsync($network_id, $id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfile'][0])
    {
        return $this->getNetworkSensorAlertsProfileAsyncWithHttpInfo($network_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSensorAlertsProfileAsyncWithHttpInfo
     *
     * Show details of a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSensorAlertsProfileAsyncWithHttpInfo($network_id, $id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner';
        $request = $this->getNetworkSensorAlertsProfileRequest($network_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSensorAlertsProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSensorAlertsProfileRequest($network_id, $id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSensorAlertsProfile'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getNetworkSensorAlertsProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/sensor/alerts/profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSensorAlertsProfiles
     *
     * Lists all sensor alert profiles for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner[]
     */
    public function getNetworkSensorAlertsProfiles($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfiles'][0])
    {
        list($response) = $this->getNetworkSensorAlertsProfilesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSensorAlertsProfilesWithHttpInfo
     *
     * Lists all sensor alert profiles for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSensorAlertsProfilesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfiles'][0])
    {
        $request = $this->getNetworkSensorAlertsProfilesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSensorAlertsProfilesAsync
     *
     * Lists all sensor alert profiles for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSensorAlertsProfilesAsync($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfiles'][0])
    {
        return $this->getNetworkSensorAlertsProfilesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSensorAlertsProfilesAsyncWithHttpInfo
     *
     * Lists all sensor alert profiles for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSensorAlertsProfilesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfiles'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner[]';
        $request = $this->getNetworkSensorAlertsProfilesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSensorAlertsProfiles'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSensorAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSensorAlertsProfilesRequest($network_id, string $contentType = self::contentTypes['getNetworkSensorAlertsProfiles'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSensorAlertsProfiles'
            );
        }


        $resourcePath = '/networks/{networkId}/sensor/alerts/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationAlertsProfiles
     *
     * List all organization-wide alert configurations
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner[]
     */
    public function getOrganizationAlertsProfiles($organization_id, string $contentType = self::contentTypes['getOrganizationAlertsProfiles'][0])
    {
        list($response) = $this->getOrganizationAlertsProfilesWithHttpInfo($organization_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationAlertsProfilesWithHttpInfo
     *
     * List all organization-wide alert configurations
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationAlertsProfilesWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationAlertsProfiles'][0])
    {
        $request = $this->getOrganizationAlertsProfilesRequest($organization_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationAlertsProfilesAsync
     *
     * List all organization-wide alert configurations
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAlertsProfilesAsync($organization_id, string $contentType = self::contentTypes['getOrganizationAlertsProfiles'][0])
    {
        return $this->getOrganizationAlertsProfilesAsyncWithHttpInfo($organization_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationAlertsProfilesAsyncWithHttpInfo
     *
     * List all organization-wide alert configurations
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAlertsProfilesAsyncWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationAlertsProfiles'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner[]';
        $request = $this->getOrganizationAlertsProfilesRequest($organization_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationAlertsProfiles'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAlertsProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationAlertsProfilesRequest($organization_id, string $contentType = self::contentTypes['getOrganizationAlertsProfiles'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationAlertsProfiles'
            );
        }


        $resourcePath = '/organizations/{organizationId}/alerts/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationAssuranceAlert
     *
     * Return a singular Health Alert by its id
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlert'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner
     */
    public function getOrganizationAssuranceAlert($organization_id, $id, string $contentType = self::contentTypes['getOrganizationAssuranceAlert'][0])
    {
        list($response) = $this->getOrganizationAssuranceAlertWithHttpInfo($organization_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationAssuranceAlertWithHttpInfo
     *
     * Return a singular Health Alert by its id
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlert'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationAssuranceAlertWithHttpInfo($organization_id, $id, string $contentType = self::contentTypes['getOrganizationAssuranceAlert'][0])
    {
        $request = $this->getOrganizationAssuranceAlertRequest($organization_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationAssuranceAlertAsync
     *
     * Return a singular Health Alert by its id
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertAsync($organization_id, $id, string $contentType = self::contentTypes['getOrganizationAssuranceAlert'][0])
    {
        return $this->getOrganizationAssuranceAlertAsyncWithHttpInfo($organization_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationAssuranceAlertAsyncWithHttpInfo
     *
     * Return a singular Health Alert by its id
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertAsyncWithHttpInfo($organization_id, $id, string $contentType = self::contentTypes['getOrganizationAssuranceAlert'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner';
        $request = $this->getOrganizationAssuranceAlertRequest($organization_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationAssuranceAlert'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationAssuranceAlertRequest($organization_id, $id, string $contentType = self::contentTypes['getOrganizationAssuranceAlert'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationAssuranceAlert'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOrganizationAssuranceAlert'
            );
        }


        $resourcePath = '/organizations/{organizationId}/assurance/alerts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationAssuranceAlerts
     *
     * Return all health alerts for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 4 - 300. Default is 30. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner[]
     */
    public function getOrganizationAssuranceAlerts($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlerts'][0])
    {
        list($response) = $this->getOrganizationAssuranceAlertsWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $sort_by, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationAssuranceAlertsWithHttpInfo
     *
     * Return all health alerts for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 4 - 300. Default is 30. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationAssuranceAlertsWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlerts'][0])
    {
        $request = $this->getOrganizationAssuranceAlertsRequest($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $sort_by, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationAssuranceAlertsAsync
     *
     * Return all health alerts for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 4 - 300. Default is 30. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlerts'][0])
    {
        return $this->getOrganizationAssuranceAlertsAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $sort_by, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationAssuranceAlertsAsyncWithHttpInfo
     *
     * Return all health alerts for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 4 - 300. Default is 30. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlerts'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationAssuranceAlerts200ResponseInner[]';
        $request = $this->getOrganizationAssuranceAlertsRequest($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $sort_by, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationAssuranceAlerts'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 4 - 300. Default is 30. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationAssuranceAlertsRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlerts'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationAssuranceAlerts'
            );
        }




















        $resourcePath = '/organizations/{organizationId}/assurance/alerts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_id,
            'networkId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $severity,
            'severity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $types,
            'types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_start,
            'tsStart', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_end,
            'tsEnd', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_types,
            'deviceTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tags,
            'deviceTags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dismissed,
            'dismissed', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolved,
            'resolved', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $suppress_alerts_for_offline_nodes,
            'suppressAlertsForOfflineNodes', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverview
     *
     * Return overview of active health alerts for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationAssuranceAlertsOverview200Response
     */
    public function getOrganizationAssuranceAlertsOverview($organization_id, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverview'][0])
    {
        list($response) = $this->getOrganizationAssuranceAlertsOverviewWithHttpInfo($organization_id, $network_id, $severity, $types, $ts_start, $ts_end, $category, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewWithHttpInfo
     *
     * Return overview of active health alerts for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationAssuranceAlertsOverview200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationAssuranceAlertsOverviewWithHttpInfo($organization_id, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverview'][0])
    {
        $request = $this->getOrganizationAssuranceAlertsOverviewRequest($organization_id, $network_id, $severity, $types, $ts_start, $ts_end, $category, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationAssuranceAlertsOverview200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationAssuranceAlertsOverview200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationAssuranceAlertsOverview200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationAssuranceAlertsOverview200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationAssuranceAlertsOverview200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewAsync
     *
     * Return overview of active health alerts for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsOverviewAsync($organization_id, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverview'][0])
    {
        return $this->getOrganizationAssuranceAlertsOverviewAsyncWithHttpInfo($organization_id, $network_id, $severity, $types, $ts_start, $ts_end, $category, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewAsyncWithHttpInfo
     *
     * Return overview of active health alerts for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsOverviewAsyncWithHttpInfo($organization_id, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverview'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationAssuranceAlertsOverview200Response';
        $request = $this->getOrganizationAssuranceAlertsOverviewRequest($organization_id, $network_id, $severity, $types, $ts_start, $ts_end, $category, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationAssuranceAlertsOverview'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationAssuranceAlertsOverviewRequest($organization_id, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverview'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationAssuranceAlertsOverview'
            );
        }















        $resourcePath = '/organizations/{organizationId}/assurance/alerts/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_id,
            'networkId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $severity,
            'severity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $types,
            'types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_start,
            'tsStart', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_end,
            'tsEnd', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_types,
            'deviceTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tags,
            'deviceTags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dismissed,
            'dismissed', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolved,
            'resolved', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $suppress_alerts_for_offline_nodes,
            'suppressAlertsForOfflineNodes', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewByNetwork
     *
     * Return a Summary of Alerts grouped by network and severity
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network id. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationAssuranceAlertsOverviewByNetwork200Response
     */
    public function getOrganizationAssuranceAlertsOverviewByNetwork($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'][0])
    {
        list($response) = $this->getOrganizationAssuranceAlertsOverviewByNetworkWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewByNetworkWithHttpInfo
     *
     * Return a Summary of Alerts grouped by network and severity
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network id. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationAssuranceAlertsOverviewByNetwork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationAssuranceAlertsOverviewByNetworkWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'][0])
    {
        $request = $this->getOrganizationAssuranceAlertsOverviewByNetworkRequest($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByNetwork200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByNetwork200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByNetwork200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByNetwork200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByNetwork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewByNetworkAsync
     *
     * Return a Summary of Alerts grouped by network and severity
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network id. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsOverviewByNetworkAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'][0])
    {
        return $this->getOrganizationAssuranceAlertsOverviewByNetworkAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewByNetworkAsyncWithHttpInfo
     *
     * Return a Summary of Alerts grouped by network and severity
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network id. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsOverviewByNetworkAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByNetwork200Response';
        $request = $this->getOrganizationAssuranceAlertsOverviewByNetworkRequest($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationAssuranceAlertsOverviewByNetwork'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network id. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationAssuranceAlertsOverviewByNetworkRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByNetwork'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationAssuranceAlertsOverviewByNetwork'
            );
        }



















        $resourcePath = '/organizations/{organizationId}/assurance/alerts/overview/byNetwork';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_id,
            'networkId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $severity,
            'severity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $types,
            'types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_start,
            'tsStart', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_end,
            'tsEnd', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_types,
            'deviceTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tags,
            'deviceTags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dismissed,
            'dismissed', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolved,
            'resolved', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $suppress_alerts_for_offline_nodes,
            'suppressAlertsForOfflineNodes', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewByType
     *
     * Return a Summary of Alerts grouped by type and severity
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationAssuranceAlertsOverviewByType200Response
     */
    public function getOrganizationAssuranceAlertsOverviewByType($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'][0])
    {
        list($response) = $this->getOrganizationAssuranceAlertsOverviewByTypeWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $sort_by, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewByTypeWithHttpInfo
     *
     * Return a Summary of Alerts grouped by type and severity
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationAssuranceAlertsOverviewByType200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationAssuranceAlertsOverviewByTypeWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'][0])
    {
        $request = $this->getOrganizationAssuranceAlertsOverviewByTypeRequest($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $sort_by, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByType200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByType200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByType200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByType200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByType200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewByTypeAsync
     *
     * Return a Summary of Alerts grouped by type and severity
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsOverviewByTypeAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'][0])
    {
        return $this->getOrganizationAssuranceAlertsOverviewByTypeAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $sort_by, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewByTypeAsyncWithHttpInfo
     *
     * Return a Summary of Alerts grouped by type and severity
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsOverviewByTypeAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewByType200Response';
        $request = $this->getOrganizationAssuranceAlertsOverviewByTypeRequest($organization_id, $per_page, $starting_after, $ending_before, $sort_order, $network_id, $severity, $types, $ts_start, $ts_end, $category, $sort_by, $serials, $device_types, $device_tags, $active, $dismissed, $resolved, $suppress_alerts_for_offline_nodes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationAssuranceAlertsOverviewByType'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_start Optional parameter to filter by starting timestamp (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string|null $sort_by Optional parameter to set column to sort by. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string[]|null $device_tags Optional parameter to filter by device tags (optional)
     * @param  bool|null $active Optional parameter to filter by active alerts defaults to true (optional)
     * @param  bool|null $dismissed Optional parameter to filter by dismissed alerts defaults to false (optional)
     * @param  bool|null $resolved Optional parameter to filter by resolved alerts defaults to false (optional)
     * @param  bool|null $suppress_alerts_for_offline_nodes When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationAssuranceAlertsOverviewByTypeRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $network_id = null, $severity = null, $types = null, $ts_start = null, $ts_end = null, $category = null, $sort_by = null, $serials = null, $device_types = null, $device_tags = null, $active = null, $dismissed = null, $resolved = null, $suppress_alerts_for_offline_nodes = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewByType'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationAssuranceAlertsOverviewByType'
            );
        }




















        $resourcePath = '/organizations/{organizationId}/assurance/alerts/overview/byType';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_id,
            'networkId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $severity,
            'severity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $types,
            'types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_start,
            'tsStart', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_end,
            'tsEnd', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_types,
            'deviceTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tags,
            'deviceTags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dismissed,
            'dismissed', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolved,
            'resolved', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $suppress_alerts_for_offline_nodes,
            'suppressAlertsForOfflineNodes', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewHistorical
     *
     * Returns historical health alert overviews
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int $segment_duration Amount of time in seconds for each segment in the returned dataset (required)
     * @param  \DateTime $ts_start Parameter to define starting timestamp of historical totals (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp defaults to the current time (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationAssuranceAlertsOverviewHistorical200Response
     */
    public function getOrganizationAssuranceAlertsOverviewHistorical($organization_id, $segment_duration, $ts_start, $network_id = null, $severity = null, $types = null, $ts_end = null, $category = null, $serials = null, $device_types = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'][0])
    {
        list($response) = $this->getOrganizationAssuranceAlertsOverviewHistoricalWithHttpInfo($organization_id, $segment_duration, $ts_start, $network_id, $severity, $types, $ts_end, $category, $serials, $device_types, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewHistoricalWithHttpInfo
     *
     * Returns historical health alert overviews
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int $segment_duration Amount of time in seconds for each segment in the returned dataset (required)
     * @param  \DateTime $ts_start Parameter to define starting timestamp of historical totals (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp defaults to the current time (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationAssuranceAlertsOverviewHistorical200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationAssuranceAlertsOverviewHistoricalWithHttpInfo($organization_id, $segment_duration, $ts_start, $network_id = null, $severity = null, $types = null, $ts_end = null, $category = null, $serials = null, $device_types = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'][0])
    {
        $request = $this->getOrganizationAssuranceAlertsOverviewHistoricalRequest($organization_id, $segment_duration, $ts_start, $network_id, $severity, $types, $ts_end, $category, $serials, $device_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationAssuranceAlertsOverviewHistorical200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationAssuranceAlertsOverviewHistorical200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewHistorical200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewHistorical200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewHistorical200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewHistoricalAsync
     *
     * Returns historical health alert overviews
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int $segment_duration Amount of time in seconds for each segment in the returned dataset (required)
     * @param  \DateTime $ts_start Parameter to define starting timestamp of historical totals (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp defaults to the current time (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsOverviewHistoricalAsync($organization_id, $segment_duration, $ts_start, $network_id = null, $severity = null, $types = null, $ts_end = null, $category = null, $serials = null, $device_types = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'][0])
    {
        return $this->getOrganizationAssuranceAlertsOverviewHistoricalAsyncWithHttpInfo($organization_id, $segment_duration, $ts_start, $network_id, $severity, $types, $ts_end, $category, $serials, $device_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationAssuranceAlertsOverviewHistoricalAsyncWithHttpInfo
     *
     * Returns historical health alert overviews
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int $segment_duration Amount of time in seconds for each segment in the returned dataset (required)
     * @param  \DateTime $ts_start Parameter to define starting timestamp of historical totals (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp defaults to the current time (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationAssuranceAlertsOverviewHistoricalAsyncWithHttpInfo($organization_id, $segment_duration, $ts_start, $network_id = null, $severity = null, $types = null, $ts_end = null, $category = null, $serials = null, $device_types = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationAssuranceAlertsOverviewHistorical200Response';
        $request = $this->getOrganizationAssuranceAlertsOverviewHistoricalRequest($organization_id, $segment_duration, $ts_start, $network_id, $severity, $types, $ts_end, $category, $serials, $device_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationAssuranceAlertsOverviewHistorical'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int $segment_duration Amount of time in seconds for each segment in the returned dataset (required)
     * @param  \DateTime $ts_start Parameter to define starting timestamp of historical totals (required)
     * @param  string|null $network_id Optional parameter to filter alerts overview by network ids. (optional)
     * @param  string|null $severity Optional parameter to filter alerts overview by severity type. (optional)
     * @param  string[]|null $types Optional parameter to filter by alert type. (optional)
     * @param  \DateTime|null $ts_end Optional parameter to filter by end timestamp defaults to the current time (optional)
     * @param  string|null $category Optional parameter to filter by category. (optional)
     * @param  string[]|null $serials Optional parameter to filter by primary device serial (optional)
     * @param  string[]|null $device_types Optional parameter to filter by device types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationAssuranceAlertsOverviewHistoricalRequest($organization_id, $segment_duration, $ts_start, $network_id = null, $severity = null, $types = null, $ts_end = null, $category = null, $serials = null, $device_types = null, string $contentType = self::contentTypes['getOrganizationAssuranceAlertsOverviewHistorical'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationAssuranceAlertsOverviewHistorical'
            );
        }

        // verify the required parameter 'segment_duration' is set
        if ($segment_duration === null || (is_array($segment_duration) && count($segment_duration) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_duration when calling getOrganizationAssuranceAlertsOverviewHistorical'
            );
        }

        // verify the required parameter 'ts_start' is set
        if ($ts_start === null || (is_array($ts_start) && count($ts_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ts_start when calling getOrganizationAssuranceAlertsOverviewHistorical'
            );
        }









        $resourcePath = '/organizations/{organizationId}/assurance/alerts/overview/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $segment_duration,
            'segmentDuration', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_id,
            'networkId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $severity,
            'severity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $types,
            'types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_start,
            'tsStart', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ts_end,
            'tsEnd', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_types,
            'deviceTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restoreOrganizationAssuranceAlerts
     *
     * Restore health alerts from dismissed
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\RestoreOrganizationAssuranceAlertsRequest $restore_organization_assurance_alerts_request restore_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restoreOrganizationAssuranceAlerts($organization_id, $restore_organization_assurance_alerts_request, string $contentType = self::contentTypes['restoreOrganizationAssuranceAlerts'][0])
    {
        $this->restoreOrganizationAssuranceAlertsWithHttpInfo($organization_id, $restore_organization_assurance_alerts_request, $contentType);
    }

    /**
     * Operation restoreOrganizationAssuranceAlertsWithHttpInfo
     *
     * Restore health alerts from dismissed
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\RestoreOrganizationAssuranceAlertsRequest $restore_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restoreOrganizationAssuranceAlertsWithHttpInfo($organization_id, $restore_organization_assurance_alerts_request, string $contentType = self::contentTypes['restoreOrganizationAssuranceAlerts'][0])
    {
        $request = $this->restoreOrganizationAssuranceAlertsRequest($organization_id, $restore_organization_assurance_alerts_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restoreOrganizationAssuranceAlertsAsync
     *
     * Restore health alerts from dismissed
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\RestoreOrganizationAssuranceAlertsRequest $restore_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreOrganizationAssuranceAlertsAsync($organization_id, $restore_organization_assurance_alerts_request, string $contentType = self::contentTypes['restoreOrganizationAssuranceAlerts'][0])
    {
        return $this->restoreOrganizationAssuranceAlertsAsyncWithHttpInfo($organization_id, $restore_organization_assurance_alerts_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restoreOrganizationAssuranceAlertsAsyncWithHttpInfo
     *
     * Restore health alerts from dismissed
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\RestoreOrganizationAssuranceAlertsRequest $restore_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreOrganizationAssuranceAlertsAsyncWithHttpInfo($organization_id, $restore_organization_assurance_alerts_request, string $contentType = self::contentTypes['restoreOrganizationAssuranceAlerts'][0])
    {
        $returnType = '';
        $request = $this->restoreOrganizationAssuranceAlertsRequest($organization_id, $restore_organization_assurance_alerts_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restoreOrganizationAssuranceAlerts'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\RestoreOrganizationAssuranceAlertsRequest $restore_organization_assurance_alerts_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreOrganizationAssuranceAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restoreOrganizationAssuranceAlertsRequest($organization_id, $restore_organization_assurance_alerts_request, string $contentType = self::contentTypes['restoreOrganizationAssuranceAlerts'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling restoreOrganizationAssuranceAlerts'
            );
        }

        // verify the required parameter 'restore_organization_assurance_alerts_request' is set
        if ($restore_organization_assurance_alerts_request === null || (is_array($restore_organization_assurance_alerts_request) && count($restore_organization_assurance_alerts_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $restore_organization_assurance_alerts_request when calling restoreOrganizationAssuranceAlerts'
            );
        }


        $resourcePath = '/organizations/{organizationId}/assurance/alerts/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($restore_organization_assurance_alerts_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($restore_organization_assurance_alerts_request));
            } else {
                $httpBody = $restore_organization_assurance_alerts_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkAlertsSettings
     *
     * Update the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAlertsSettings200Response
     */
    public function updateNetworkAlertsSettings($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {
        list($response) = $this->updateNetworkAlertsSettingsWithHttpInfo($network_id, $update_network_alerts_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkAlertsSettingsWithHttpInfo
     *
     * Update the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAlertsSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkAlertsSettingsWithHttpInfo($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {
        $request = $this->updateNetworkAlertsSettingsRequest($network_id, $update_network_alerts_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAlertsSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAlertsSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAlertsSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAlertsSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAlertsSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkAlertsSettingsAsync
     *
     * Update the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAlertsSettingsAsync($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {
        return $this->updateNetworkAlertsSettingsAsyncWithHttpInfo($network_id, $update_network_alerts_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkAlertsSettingsAsyncWithHttpInfo
     *
     * Update the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAlertsSettingsAsyncWithHttpInfo($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAlertsSettings200Response';
        $request = $this->updateNetworkAlertsSettingsRequest($network_id, $update_network_alerts_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkAlertsSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkAlertsSettingsRequest($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkAlertsSettings'
            );
        }



        $resourcePath = '/networks/{networkId}/alerts/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_alerts_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_alerts_settings_request));
            } else {
                $httpBody = $update_network_alerts_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkSensorAlertsProfile
     *
     * Updates a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  \Meraki\Model\UpdateNetworkSensorAlertsProfileRequest|null $update_network_sensor_alerts_profile_request update_network_sensor_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner
     */
    public function updateNetworkSensorAlertsProfile($network_id, $id, $update_network_sensor_alerts_profile_request = null, string $contentType = self::contentTypes['updateNetworkSensorAlertsProfile'][0])
    {
        list($response) = $this->updateNetworkSensorAlertsProfileWithHttpInfo($network_id, $id, $update_network_sensor_alerts_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkSensorAlertsProfileWithHttpInfo
     *
     * Updates a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  \Meraki\Model\UpdateNetworkSensorAlertsProfileRequest|null $update_network_sensor_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkSensorAlertsProfileWithHttpInfo($network_id, $id, $update_network_sensor_alerts_profile_request = null, string $contentType = self::contentTypes['updateNetworkSensorAlertsProfile'][0])
    {
        $request = $this->updateNetworkSensorAlertsProfileRequest($network_id, $id, $update_network_sensor_alerts_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkSensorAlertsProfileAsync
     *
     * Updates a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  \Meraki\Model\UpdateNetworkSensorAlertsProfileRequest|null $update_network_sensor_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSensorAlertsProfileAsync($network_id, $id, $update_network_sensor_alerts_profile_request = null, string $contentType = self::contentTypes['updateNetworkSensorAlertsProfile'][0])
    {
        return $this->updateNetworkSensorAlertsProfileAsyncWithHttpInfo($network_id, $id, $update_network_sensor_alerts_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkSensorAlertsProfileAsyncWithHttpInfo
     *
     * Updates a sensor alert profile for a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  \Meraki\Model\UpdateNetworkSensorAlertsProfileRequest|null $update_network_sensor_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSensorAlertsProfileAsyncWithHttpInfo($network_id, $id, $update_network_sensor_alerts_profile_request = null, string $contentType = self::contentTypes['updateNetworkSensorAlertsProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSensorAlertsProfiles200ResponseInner';
        $request = $this->updateNetworkSensorAlertsProfileRequest($network_id, $id, $update_network_sensor_alerts_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkSensorAlertsProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $id ID (required)
     * @param  \Meraki\Model\UpdateNetworkSensorAlertsProfileRequest|null $update_network_sensor_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSensorAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkSensorAlertsProfileRequest($network_id, $id, $update_network_sensor_alerts_profile_request = null, string $contentType = self::contentTypes['updateNetworkSensorAlertsProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkSensorAlertsProfile'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateNetworkSensorAlertsProfile'
            );
        }



        $resourcePath = '/networks/{networkId}/sensor/alerts/profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_sensor_alerts_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_sensor_alerts_profile_request));
            } else {
                $httpBody = $update_network_sensor_alerts_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrganizationAlertsProfile
     *
     * Update an organization-wide alert config
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  \Meraki\Model\UpdateOrganizationAlertsProfileRequest|null $update_organization_alerts_profile_request update_organization_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner
     */
    public function updateOrganizationAlertsProfile($organization_id, $alert_config_id, $update_organization_alerts_profile_request = null, string $contentType = self::contentTypes['updateOrganizationAlertsProfile'][0])
    {
        list($response) = $this->updateOrganizationAlertsProfileWithHttpInfo($organization_id, $alert_config_id, $update_organization_alerts_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation updateOrganizationAlertsProfileWithHttpInfo
     *
     * Update an organization-wide alert config
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  \Meraki\Model\UpdateOrganizationAlertsProfileRequest|null $update_organization_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrganizationAlertsProfileWithHttpInfo($organization_id, $alert_config_id, $update_organization_alerts_profile_request = null, string $contentType = self::contentTypes['updateOrganizationAlertsProfile'][0])
    {
        $request = $this->updateOrganizationAlertsProfileRequest($organization_id, $alert_config_id, $update_organization_alerts_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrganizationAlertsProfileAsync
     *
     * Update an organization-wide alert config
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  \Meraki\Model\UpdateOrganizationAlertsProfileRequest|null $update_organization_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationAlertsProfileAsync($organization_id, $alert_config_id, $update_organization_alerts_profile_request = null, string $contentType = self::contentTypes['updateOrganizationAlertsProfile'][0])
    {
        return $this->updateOrganizationAlertsProfileAsyncWithHttpInfo($organization_id, $alert_config_id, $update_organization_alerts_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrganizationAlertsProfileAsyncWithHttpInfo
     *
     * Update an organization-wide alert config
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  \Meraki\Model\UpdateOrganizationAlertsProfileRequest|null $update_organization_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationAlertsProfileAsyncWithHttpInfo($organization_id, $alert_config_id, $update_organization_alerts_profile_request = null, string $contentType = self::contentTypes['updateOrganizationAlertsProfile'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationAlertsProfiles200ResponseInner';
        $request = $this->updateOrganizationAlertsProfileRequest($organization_id, $alert_config_id, $update_organization_alerts_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrganizationAlertsProfile'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $alert_config_id Alert config ID (required)
     * @param  \Meraki\Model\UpdateOrganizationAlertsProfileRequest|null $update_organization_alerts_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationAlertsProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateOrganizationAlertsProfileRequest($organization_id, $alert_config_id, $update_organization_alerts_profile_request = null, string $contentType = self::contentTypes['updateOrganizationAlertsProfile'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateOrganizationAlertsProfile'
            );
        }

        // verify the required parameter 'alert_config_id' is set
        if ($alert_config_id === null || (is_array($alert_config_id) && count($alert_config_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alert_config_id when calling updateOrganizationAlertsProfile'
            );
        }



        $resourcePath = '/organizations/{organizationId}/alerts/profiles/{alertConfigId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($alert_config_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alertConfigId' . '}',
                ObjectSerializer::toPathValue($alert_config_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_organization_alerts_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_organization_alerts_profile_request));
            } else {
                $httpBody = $update_organization_alerts_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
