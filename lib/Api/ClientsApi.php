<?php
/**
 * ClientsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Meraki\ApiException;
use Meraki\Configuration;
use Meraki\HeaderSelector;
use Meraki\ObjectSerializer;

/**
 * ClientsApi Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ClientsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getDeviceClients' => [
            'application/json',
        ],
        'getNetworkApplianceClientSecurityEvents' => [
            'application/json',
        ],
        'getNetworkClient' => [
            'application/json',
        ],
        'getNetworkClientPolicy' => [
            'application/json',
        ],
        'getNetworkClientSplashAuthorizationStatus' => [
            'application/json',
        ],
        'getNetworkClientTrafficHistory' => [
            'application/json',
        ],
        'getNetworkClientUsageHistory' => [
            'application/json',
        ],
        'getNetworkClients' => [
            'application/json',
        ],
        'getNetworkClientsApplicationUsage' => [
            'application/json',
        ],
        'getNetworkClientsBandwidthUsageHistory' => [
            'application/json',
        ],
        'getNetworkClientsOverview' => [
            'application/json',
        ],
        'getNetworkClientsUsageHistories' => [
            'application/json',
        ],
        'getNetworkWirelessClientConnectionStats' => [
            'application/json',
        ],
        'getNetworkWirelessClientConnectivityEvents' => [
            'application/json',
        ],
        'getNetworkWirelessClientLatencyHistory' => [
            'application/json',
        ],
        'getNetworkWirelessClientLatencyStats' => [
            'application/json',
        ],
        'getNetworkWirelessClientsConnectionStats' => [
            'application/json',
        ],
        'getNetworkWirelessClientsLatencyStats' => [
            'application/json',
        ],
        'getOrganizationClientsBandwidthUsageHistory' => [
            'application/json',
        ],
        'getOrganizationClientsOverview' => [
            'application/json',
        ],
        'getOrganizationClientsSearch' => [
            'application/json',
        ],
        'getOrganizationSummaryTopClientsByUsage' => [
            'application/json',
        ],
        'getOrganizationSummaryTopClientsManufacturersByUsage' => [
            'application/json',
        ],
        'getOrganizationSwitchPortsClientsOverviewByDevice' => [
            'application/json',
        ],
        'getOrganizationWirelessClientsOverviewByDevice' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval' => [
            'application/json',
        ],
        'provisionNetworkClients' => [
            'application/json',
        ],
        'updateNetworkClientPolicy' => [
            'application/json',
        ],
        'updateNetworkClientSplashAuthorizationStatus' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getDeviceClients
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceClients200ResponseInner[]
     */
    public function getDeviceClients($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {
        list($response) = $this->getDeviceClientsWithHttpInfo($serial, $t0, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceClientsWithHttpInfo
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceClients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceClientsWithHttpInfo($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {
        $request = $this->getDeviceClientsRequest($serial, $t0, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceClients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceClients200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceClients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceClients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceClients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceClientsAsync
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceClientsAsync($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {
        return $this->getDeviceClientsAsyncWithHttpInfo($serial, $t0, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceClientsAsyncWithHttpInfo
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceClientsAsyncWithHttpInfo($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceClients200ResponseInner[]';
        $request = $this->getDeviceClientsRequest($serial, $t0, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceClients'
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceClientsRequest($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceClients'
            );
        }


        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getDeviceClients, must be smaller than or equal to 2678400.');
        }
        

        $resourcePath = '/devices/{serial}/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceClientSecurityEvents
     *
     * List the security events for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>[]
     */
    public function getNetworkApplianceClientSecurityEvents($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {
        list($response) = $this->getNetworkApplianceClientSecurityEventsWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceClientSecurityEventsWithHttpInfo
     *
     * List the security events for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceClientSecurityEventsWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {
        $request = $this->getNetworkApplianceClientSecurityEventsRequest($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'array<string,mixed>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceClientSecurityEventsAsync
     *
     * List the security events for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceClientSecurityEventsAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {
        return $this->getNetworkApplianceClientSecurityEventsAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceClientSecurityEventsAsyncWithHttpInfo
     *
     * List the security events for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceClientSecurityEventsAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {
        $returnType = 'array<string,mixed>[]';
        $request = $this->getNetworkApplianceClientSecurityEventsRequest($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceClientSecurityEvents'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceClientSecurityEventsRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceClientSecurityEvents'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkApplianceClientSecurityEvents'
            );
        }



        if ($timespan !== null && $timespan > 68342400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkApplianceClientSecurityEvents, must be smaller than or equal to 68342400.');
        }
        





        $resourcePath = '/networks/{networkId}/appliance/clients/{clientId}/security/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClient
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClient200Response
     */
    public function getNetworkClient($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {
        list($response) = $this->getNetworkClientWithHttpInfo($network_id, $client_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientWithHttpInfo
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClient200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {
        $request = $this->getNetworkClientRequest($network_id, $client_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClient200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClient200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClient200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClient200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClient200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientAsync
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientAsync($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {
        return $this->getNetworkClientAsyncWithHttpInfo($network_id, $client_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientAsyncWithHttpInfo
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientAsyncWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClient200Response';
        $request = $this->getNetworkClientRequest($network_id, $client_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClient'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientRequest($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClient'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClient'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientPolicy
     *
     * Return the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientPolicy200Response
     */
    public function getNetworkClientPolicy($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {
        list($response) = $this->getNetworkClientPolicyWithHttpInfo($network_id, $client_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientPolicyWithHttpInfo
     *
     * Return the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientPolicy200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientPolicyWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {
        $request = $this->getNetworkClientPolicyRequest($network_id, $client_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientPolicy200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientPolicy200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientPolicy200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientPolicy200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientPolicy200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientPolicyAsync
     *
     * Return the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientPolicyAsync($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {
        return $this->getNetworkClientPolicyAsyncWithHttpInfo($network_id, $client_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientPolicyAsyncWithHttpInfo
     *
     * Return the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientPolicyAsyncWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientPolicy200Response';
        $request = $this->getNetworkClientPolicyRequest($network_id, $client_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientPolicy'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientPolicyRequest($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientPolicy'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientPolicy'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientSplashAuthorizationStatus
     *
     * Return the splash authorization for a client, for each SSID they&#39;ve associated with through splash
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkClientSplashAuthorizationStatus($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {
        list($response) = $this->getNetworkClientSplashAuthorizationStatusWithHttpInfo($network_id, $client_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientSplashAuthorizationStatusWithHttpInfo
     *
     * Return the splash authorization for a client, for each SSID they&#39;ve associated with through splash
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientSplashAuthorizationStatusWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {
        $request = $this->getNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientSplashAuthorizationStatusAsync
     *
     * Return the splash authorization for a client, for each SSID they&#39;ve associated with through splash
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientSplashAuthorizationStatusAsync($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {
        return $this->getNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo($network_id, $client_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo
     *
     * Return the splash authorization for a client, for each SSID they&#39;ve associated with through splash
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientSplashAuthorizationStatus'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientSplashAuthorizationStatus'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientSplashAuthorizationStatus'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientTrafficHistory
     *
     * Return the client&#39;s network traffic data over time
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]
     */
    public function getNetworkClientTrafficHistory($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {
        list($response) = $this->getNetworkClientTrafficHistoryWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientTrafficHistoryWithHttpInfo
     *
     * Return the client&#39;s network traffic data over time
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientTrafficHistoryWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {
        $request = $this->getNetworkClientTrafficHistoryRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientTrafficHistoryAsync
     *
     * Return the client&#39;s network traffic data over time
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientTrafficHistoryAsync($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {
        return $this->getNetworkClientTrafficHistoryAsyncWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientTrafficHistoryAsyncWithHttpInfo
     *
     * Return the client&#39;s network traffic data over time
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientTrafficHistoryAsyncWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]';
        $request = $this->getNetworkClientTrafficHistoryRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientTrafficHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientTrafficHistoryRequest($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientTrafficHistory'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientTrafficHistory'
            );
        }





        $resourcePath = '/networks/{networkId}/clients/{clientId}/trafficHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientUsageHistory
     *
     * Return the client&#39;s daily usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]
     */
    public function getNetworkClientUsageHistory($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {
        list($response) = $this->getNetworkClientUsageHistoryWithHttpInfo($network_id, $client_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientUsageHistoryWithHttpInfo
     *
     * Return the client&#39;s daily usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientUsageHistoryWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {
        $request = $this->getNetworkClientUsageHistoryRequest($network_id, $client_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientUsageHistoryAsync
     *
     * Return the client&#39;s daily usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientUsageHistoryAsync($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {
        return $this->getNetworkClientUsageHistoryAsyncWithHttpInfo($network_id, $client_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientUsageHistoryAsyncWithHttpInfo
     *
     * Return the client&#39;s daily usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientUsageHistoryAsyncWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]';
        $request = $this->getNetworkClientUsageHistoryRequest($network_id, $client_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientUsageHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientUsageHistoryRequest($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientUsageHistory'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientUsageHistory'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/usageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClients
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClients200ResponseInner[]
     */
    public function getNetworkClients($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {
        list($response) = $this->getNetworkClientsWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $psk_group, $description, $vlan, $named_vlan, $recent_device_connections, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsWithHttpInfo
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {
        $request = $this->getNetworkClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $psk_group, $description, $vlan, $named_vlan, $recent_device_connections, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClients200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsAsync
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsAsync($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {
        return $this->getNetworkClientsAsyncWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $psk_group, $description, $vlan, $named_vlan, $recent_device_connections, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsAsyncWithHttpInfo
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsAsyncWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClients200ResponseInner[]';
        $request = $this->getNetworkClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $psk_group, $description, $vlan, $named_vlan, $recent_device_connections, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClients'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsRequest($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClients'
            );
        }


        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkClients, must be smaller than or equal to 2678400.');
        }
        















        $resourcePath = '/networks/{networkId}/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $statuses,
            'statuses', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip,
            'ip', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip6,
            'ip6', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip6_local,
            'ip6Local', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mac,
            'mac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $os,
            'os', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $psk_group,
            'pskGroup', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan,
            'vlan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $named_vlan,
            'namedVlan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recent_device_connections,
            'recentDeviceConnections', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsApplicationUsage
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getNetworkClientsApplicationUsage($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {
        list($response) = $this->getNetworkClientsApplicationUsageWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsApplicationUsageWithHttpInfo
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsApplicationUsageWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {
        $request = $this->getNetworkClientsApplicationUsageRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsApplicationUsageAsync
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsApplicationUsageAsync($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {
        return $this->getNetworkClientsApplicationUsageAsyncWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsApplicationUsageAsyncWithHttpInfo
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsApplicationUsageAsyncWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {
        $returnType = 'object[]';
        $request = $this->getNetworkClientsApplicationUsageRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsApplicationUsage'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsApplicationUsageRequest($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsApplicationUsage'
            );
        }

        // verify the required parameter 'clients' is set
        if ($clients === null || (is_array($clients) && count($clients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clients when calling getNetworkClientsApplicationUsage'
            );
        }







        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkClientsApplicationUsage, must be smaller than or equal to 2678400.');
        }
        

        $resourcePath = '/networks/{networkId}/clients/applicationUsage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clients,
            'clients', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_number,
            'ssidNumber', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsBandwidthUsageHistory
     *
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]
     */
    public function getNetworkClientsBandwidthUsageHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {
        list($response) = $this->getNetworkClientsBandwidthUsageHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsBandwidthUsageHistoryWithHttpInfo
     *
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsBandwidthUsageHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {
        $request = $this->getNetworkClientsBandwidthUsageHistoryRequest($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsBandwidthUsageHistoryAsync
     *
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsBandwidthUsageHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {
        return $this->getNetworkClientsBandwidthUsageHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsBandwidthUsageHistoryAsyncWithHttpInfo
     *
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsBandwidthUsageHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]';
        $request = $this->getNetworkClientsBandwidthUsageHistoryRequest($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsBandwidthUsageHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsBandwidthUsageHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsBandwidthUsageHistory'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkClientsBandwidthUsageHistory, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/networks/{networkId}/clients/bandwidthUsageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsOverview
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientsOverview200Response
     */
    public function getNetworkClientsOverview($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {
        list($response) = $this->getNetworkClientsOverviewWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsOverviewWithHttpInfo
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientsOverview200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsOverviewWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {
        $request = $this->getNetworkClientsOverviewRequest($network_id, $t0, $t1, $timespan, $resolution, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientsOverview200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientsOverview200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientsOverview200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientsOverview200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientsOverview200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsOverviewAsync
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsOverviewAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {
        return $this->getNetworkClientsOverviewAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsOverviewAsyncWithHttpInfo
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsOverviewAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientsOverview200Response';
        $request = $this->getNetworkClientsOverviewRequest($network_id, $t0, $t1, $timespan, $resolution, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsOverview'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsOverviewRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsOverview'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkClientsOverview, must be smaller than or equal to 2678400.');
        }
        


        $resourcePath = '/networks/{networkId}/clients/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsUsageHistories
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getNetworkClientsUsageHistories($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {
        list($response) = $this->getNetworkClientsUsageHistoriesWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsUsageHistoriesWithHttpInfo
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsUsageHistoriesWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {
        $request = $this->getNetworkClientsUsageHistoriesRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsUsageHistoriesAsync
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsUsageHistoriesAsync($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {
        return $this->getNetworkClientsUsageHistoriesAsyncWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsUsageHistoriesAsyncWithHttpInfo
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsUsageHistoriesAsyncWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {
        $returnType = 'object[]';
        $request = $this->getNetworkClientsUsageHistoriesRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsUsageHistories'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsUsageHistoriesRequest($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsUsageHistories'
            );
        }

        // verify the required parameter 'clients' is set
        if ($clients === null || (is_array($clients) && count($clients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clients when calling getNetworkClientsUsageHistories'
            );
        }







        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkClientsUsageHistories, must be smaller than or equal to 2678400.');
        }
        

        $resourcePath = '/networks/{networkId}/clients/usageHistories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clients,
            'clients', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_number,
            'ssidNumber', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientConnectionStats
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectionStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWirelessClientConnectionStats200Response
     */
    public function getNetworkWirelessClientConnectionStats($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectionStats'][0])
    {
        list($response) = $this->getNetworkWirelessClientConnectionStatsWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectionStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWirelessClientConnectionStats200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientConnectionStatsWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectionStats'][0])
    {
        $request = $this->getNetworkWirelessClientConnectionStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWirelessClientConnectionStats200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWirelessClientConnectionStats200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWirelessClientConnectionStats200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWirelessClientConnectionStats200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWirelessClientConnectionStats200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientConnectionStatsAsync
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectionStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectionStatsAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectionStats'][0])
    {
        return $this->getNetworkWirelessClientConnectionStatsAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectionStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectionStatsAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectionStats'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWirelessClientConnectionStats200Response';
        $request = $this->getNetworkWirelessClientConnectionStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientConnectionStats'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectionStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWirelessClientConnectionStatsRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectionStats'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientConnectionStats'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientConnectionStats'
            );
        }



        if ($timespan !== null && $timespan > 604800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkWirelessClientConnectionStats, must be smaller than or equal to 604800.');
        }
        





        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $band,
            'band', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid,
            'ssid', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan,
            'vlan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ap_tag,
            'apTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEvents
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string|null $band Filter results by band. Valid bands are &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;. (optional)
     * @param  int|null $ssid_number Filter results by SSID. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string[]|null $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string|null $device_serial Filter results by an AP&#39;s serial number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectivityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWirelessClientConnectivityEvents200ResponseInner[]
     */
    public function getNetworkWirelessClientConnectivityEvents($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $band = null, $ssid_number = null, $included_severities = null, $device_serial = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectivityEvents'][0])
    {
        list($response) = $this->getNetworkWirelessClientConnectivityEventsWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $sort_order, $t0, $t1, $timespan, $types, $band, $ssid_number, $included_severities, $device_serial, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEventsWithHttpInfo
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string|null $band Filter results by band. Valid bands are &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;. (optional)
     * @param  int|null $ssid_number Filter results by SSID. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string[]|null $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string|null $device_serial Filter results by an AP&#39;s serial number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectivityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWirelessClientConnectivityEvents200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientConnectivityEventsWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $band = null, $ssid_number = null, $included_severities = null, $device_serial = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectivityEvents'][0])
    {
        $request = $this->getNetworkWirelessClientConnectivityEventsRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $sort_order, $t0, $t1, $timespan, $types, $band, $ssid_number, $included_severities, $device_serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWirelessClientConnectivityEvents200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWirelessClientConnectivityEvents200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWirelessClientConnectivityEvents200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWirelessClientConnectivityEvents200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWirelessClientConnectivityEvents200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEventsAsync
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string|null $band Filter results by band. Valid bands are &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;. (optional)
     * @param  int|null $ssid_number Filter results by SSID. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string[]|null $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string|null $device_serial Filter results by an AP&#39;s serial number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectivityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectivityEventsAsync($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $band = null, $ssid_number = null, $included_severities = null, $device_serial = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectivityEvents'][0])
    {
        return $this->getNetworkWirelessClientConnectivityEventsAsyncWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $sort_order, $t0, $t1, $timespan, $types, $band, $ssid_number, $included_severities, $device_serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEventsAsyncWithHttpInfo
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string|null $band Filter results by band. Valid bands are &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;. (optional)
     * @param  int|null $ssid_number Filter results by SSID. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string[]|null $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string|null $device_serial Filter results by an AP&#39;s serial number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectivityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectivityEventsAsyncWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $band = null, $ssid_number = null, $included_severities = null, $device_serial = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectivityEvents'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWirelessClientConnectivityEvents200ResponseInner[]';
        $request = $this->getNetworkWirelessClientConnectivityEventsRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $sort_order, $t0, $t1, $timespan, $types, $band, $ssid_number, $included_severities, $device_serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientConnectivityEvents'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string|null $band Filter results by band. Valid bands are &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;. (optional)
     * @param  int|null $ssid_number Filter results by SSID. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string[]|null $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string|null $device_serial Filter results by an AP&#39;s serial number. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientConnectivityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWirelessClientConnectivityEventsRequest($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $band = null, $ssid_number = null, $included_severities = null, $device_serial = null, string $contentType = self::contentTypes['getNetworkWirelessClientConnectivityEvents'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientConnectivityEvents'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientConnectivityEvents'
            );
        }







        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkWirelessClientConnectivityEvents, must be smaller than or equal to 2678400.');
        }
        






        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/connectivityEvents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $types,
            'types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $band,
            'band', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_number,
            'ssidNumber', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $included_severities,
            'includedSeverities', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_serial,
            'deviceSerial', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistory
     *
     * Return the latency history for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWirelessClientLatencyHistory200ResponseInner[]
     */
    public function getNetworkWirelessClientLatencyHistory($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyHistory'][0])
    {
        list($response) = $this->getNetworkWirelessClientLatencyHistoryWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $resolution, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistoryWithHttpInfo
     *
     * Return the latency history for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWirelessClientLatencyHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientLatencyHistoryWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyHistory'][0])
    {
        $request = $this->getNetworkWirelessClientLatencyHistoryRequest($network_id, $client_id, $t0, $t1, $timespan, $resolution, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWirelessClientLatencyHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWirelessClientLatencyHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWirelessClientLatencyHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWirelessClientLatencyHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWirelessClientLatencyHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistoryAsync
     *
     * Return the latency history for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyHistoryAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyHistory'][0])
    {
        return $this->getNetworkWirelessClientLatencyHistoryAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $resolution, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistoryAsyncWithHttpInfo
     *
     * Return the latency history for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyHistoryAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWirelessClientLatencyHistory200ResponseInner[]';
        $request = $this->getNetworkWirelessClientLatencyHistoryRequest($network_id, $client_id, $t0, $t1, $timespan, $resolution, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientLatencyHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWirelessClientLatencyHistoryRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientLatencyHistory'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientLatencyHistory'
            );
        }



        if ($timespan !== null && $timespan > 68342400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkWirelessClientLatencyHistory, must be smaller than or equal to 68342400.');
        }
        


        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/latencyHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientLatencyStats
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientLatencyStats($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyStats'][0])
    {
        list($response) = $this->getNetworkWirelessClientLatencyStatsWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientLatencyStatsWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyStats'][0])
    {
        $request = $this->getNetworkWirelessClientLatencyStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientLatencyStatsAsync
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyStatsAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyStats'][0])
    {
        return $this->getNetworkWirelessClientLatencyStatsAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyStatsAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyStats'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientLatencyStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientLatencyStats'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientLatencyStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWirelessClientLatencyStatsRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientLatencyStats'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientLatencyStats'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientLatencyStats'
            );
        }



        if ($timespan !== null && $timespan > 604800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkWirelessClientLatencyStats, must be smaller than or equal to 604800.');
        }
        






        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $band,
            'band', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid,
            'ssid', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan,
            'vlan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ap_tag,
            'apTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStats
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsConnectionStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getNetworkWirelessClientsConnectionStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientsConnectionStats'][0])
    {
        list($response) = $this->getNetworkWirelessClientsConnectionStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsConnectionStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientsConnectionStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientsConnectionStats'][0])
    {
        $request = $this->getNetworkWirelessClientsConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStatsAsync
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsConnectionStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsConnectionStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientsConnectionStats'][0])
    {
        return $this->getNetworkWirelessClientsConnectionStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsConnectionStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsConnectionStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientsConnectionStats'][0])
    {
        $returnType = 'object[]';
        $request = $this->getNetworkWirelessClientsConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientsConnectionStats'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsConnectionStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWirelessClientsConnectionStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessClientsConnectionStats'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientsConnectionStats'
            );
        }



        if ($timespan !== null && $timespan > 604800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkWirelessClientsConnectionStats, must be smaller than or equal to 604800.');
        }
        





        $resourcePath = '/networks/{networkId}/wireless/clients/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $band,
            'band', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid,
            'ssid', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan,
            'vlan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ap_tag,
            'apTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStats
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsLatencyStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getNetworkWirelessClientsLatencyStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientsLatencyStats'][0])
    {
        list($response) = $this->getNetworkWirelessClientsLatencyStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsLatencyStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientsLatencyStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientsLatencyStats'][0])
    {
        $request = $this->getNetworkWirelessClientsLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStatsAsync
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsLatencyStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsLatencyStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientsLatencyStats'][0])
    {
        return $this->getNetworkWirelessClientsLatencyStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsLatencyStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsLatencyStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientsLatencyStats'][0])
    {
        $returnType = 'object[]';
        $request = $this->getNetworkWirelessClientsLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientsLatencyStats'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessClientsLatencyStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWirelessClientsLatencyStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessClientsLatencyStats'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientsLatencyStats'
            );
        }



        if ($timespan !== null && $timespan > 604800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getNetworkWirelessClientsLatencyStats, must be smaller than or equal to 604800.');
        }
        






        $resourcePath = '/networks/{networkId}/wireless/clients/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $band,
            'band', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid,
            'ssid', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan,
            'vlan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ap_tag,
            'apTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationClientsBandwidthUsageHistory
     *
     * Return data usage (in megabits per second) over time for all clients in the given organization within a given time range.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationClientsBandwidthUsageHistory200ResponseInner[]
     */
    public function getOrganizationClientsBandwidthUsageHistory($organization_id, $network_tag = null, $device_tag = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsBandwidthUsageHistory'][0])
    {
        list($response) = $this->getOrganizationClientsBandwidthUsageHistoryWithHttpInfo($organization_id, $network_tag, $device_tag, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationClientsBandwidthUsageHistoryWithHttpInfo
     *
     * Return data usage (in megabits per second) over time for all clients in the given organization within a given time range.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationClientsBandwidthUsageHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationClientsBandwidthUsageHistoryWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsBandwidthUsageHistory'][0])
    {
        $request = $this->getOrganizationClientsBandwidthUsageHistoryRequest($organization_id, $network_tag, $device_tag, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationClientsBandwidthUsageHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationClientsBandwidthUsageHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationClientsBandwidthUsageHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationClientsBandwidthUsageHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationClientsBandwidthUsageHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationClientsBandwidthUsageHistoryAsync
     *
     * Return data usage (in megabits per second) over time for all clients in the given organization within a given time range.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationClientsBandwidthUsageHistoryAsync($organization_id, $network_tag = null, $device_tag = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsBandwidthUsageHistory'][0])
    {
        return $this->getOrganizationClientsBandwidthUsageHistoryAsyncWithHttpInfo($organization_id, $network_tag, $device_tag, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationClientsBandwidthUsageHistoryAsyncWithHttpInfo
     *
     * Return data usage (in megabits per second) over time for all clients in the given organization within a given time range.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationClientsBandwidthUsageHistoryAsyncWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsBandwidthUsageHistory'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationClientsBandwidthUsageHistory200ResponseInner[]';
        $request = $this->getOrganizationClientsBandwidthUsageHistoryRequest($organization_id, $network_tag, $device_tag, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationClientsBandwidthUsageHistory'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationClientsBandwidthUsageHistoryRequest($organization_id, $network_tag = null, $device_tag = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsBandwidthUsageHistory'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationClientsBandwidthUsageHistory'
            );
        }







        if ($timespan !== null && $timespan > 16070400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getOrganizationClientsBandwidthUsageHistory, must be smaller than or equal to 16070400.');
        }
        

        $resourcePath = '/organizations/{organizationId}/clients/bandwidthUsageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_tag,
            'networkTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tag,
            'deviceTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_name,
            'ssidName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $usage_uplink,
            'usageUplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationClientsOverview
     *
     * Return summary information around client data usage (in kb) across the given organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationClientsOverview200Response
     */
    public function getOrganizationClientsOverview($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsOverview'][0])
    {
        list($response) = $this->getOrganizationClientsOverviewWithHttpInfo($organization_id, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationClientsOverviewWithHttpInfo
     *
     * Return summary information around client data usage (in kb) across the given organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationClientsOverview200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationClientsOverviewWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsOverview'][0])
    {
        $request = $this->getOrganizationClientsOverviewRequest($organization_id, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationClientsOverview200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationClientsOverview200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationClientsOverview200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationClientsOverview200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationClientsOverview200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationClientsOverviewAsync
     *
     * Return summary information around client data usage (in kb) across the given organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationClientsOverviewAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsOverview'][0])
    {
        return $this->getOrganizationClientsOverviewAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationClientsOverviewAsyncWithHttpInfo
     *
     * Return summary information around client data usage (in kb) across the given organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationClientsOverviewAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsOverview'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationClientsOverview200Response';
        $request = $this->getOrganizationClientsOverviewRequest($organization_id, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationClientsOverview'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationClientsOverviewRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationClientsOverview'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationClientsOverview'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getOrganizationClientsOverview, must be smaller than or equal to 2678400.');
        }
        

        $resourcePath = '/organizations/{organizationId}/clients/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationClientsSearch
     *
     * Return the client details in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $mac The MAC address of the client. Required. (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5. Default is 5. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsSearch'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationClientsSearch200Response
     */
    public function getOrganizationClientsSearch($organization_id, $mac, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationClientsSearch'][0])
    {
        list($response) = $this->getOrganizationClientsSearchWithHttpInfo($organization_id, $mac, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationClientsSearchWithHttpInfo
     *
     * Return the client details in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $mac The MAC address of the client. Required. (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5. Default is 5. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsSearch'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationClientsSearch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationClientsSearchWithHttpInfo($organization_id, $mac, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationClientsSearch'][0])
    {
        $request = $this->getOrganizationClientsSearchRequest($organization_id, $mac, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationClientsSearch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationClientsSearch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationClientsSearch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationClientsSearch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationClientsSearch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationClientsSearchAsync
     *
     * Return the client details in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $mac The MAC address of the client. Required. (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5. Default is 5. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationClientsSearchAsync($organization_id, $mac, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationClientsSearch'][0])
    {
        return $this->getOrganizationClientsSearchAsyncWithHttpInfo($organization_id, $mac, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationClientsSearchAsyncWithHttpInfo
     *
     * Return the client details in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $mac The MAC address of the client. Required. (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5. Default is 5. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationClientsSearchAsyncWithHttpInfo($organization_id, $mac, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationClientsSearch'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationClientsSearch200Response';
        $request = $this->getOrganizationClientsSearchRequest($organization_id, $mac, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationClientsSearch'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $mac The MAC address of the client. Required. (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5. Default is 5. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationClientsSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationClientsSearchRequest($organization_id, $mac, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationClientsSearch'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationClientsSearch'
            );
        }

        // verify the required parameter 'mac' is set
        if ($mac === null || (is_array($mac) && count($mac) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mac when calling getOrganizationClientsSearch'
            );
        }





        $resourcePath = '/organizations/{organizationId}/clients/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mac,
            'mac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationSummaryTopClientsByUsage
     *
     * Return metrics for organization&#39;s top 10 clients by data usage (in mb) over given time range.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsByUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationSummaryTopClientsByUsage200ResponseInner[]
     */
    public function getOrganizationSummaryTopClientsByUsage($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsByUsage'][0])
    {
        list($response) = $this->getOrganizationSummaryTopClientsByUsageWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationSummaryTopClientsByUsageWithHttpInfo
     *
     * Return metrics for organization&#39;s top 10 clients by data usage (in mb) over given time range.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsByUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationSummaryTopClientsByUsage200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationSummaryTopClientsByUsageWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsByUsage'][0])
    {
        $request = $this->getOrganizationSummaryTopClientsByUsageRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationSummaryTopClientsByUsage200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationSummaryTopClientsByUsage200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationSummaryTopClientsByUsage200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationSummaryTopClientsByUsage200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationSummaryTopClientsByUsage200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationSummaryTopClientsByUsageAsync
     *
     * Return metrics for organization&#39;s top 10 clients by data usage (in mb) over given time range.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopClientsByUsageAsync($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsByUsage'][0])
    {
        return $this->getOrganizationSummaryTopClientsByUsageAsyncWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationSummaryTopClientsByUsageAsyncWithHttpInfo
     *
     * Return metrics for organization&#39;s top 10 clients by data usage (in mb) over given time range.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopClientsByUsageAsyncWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsByUsage'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationSummaryTopClientsByUsage200ResponseInner[]';
        $request = $this->getOrganizationSummaryTopClientsByUsageRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationSummaryTopClientsByUsage'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationSummaryTopClientsByUsageRequest($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsByUsage'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationSummaryTopClientsByUsage'
            );
        }








        if ($timespan !== null && $timespan > 16070400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getOrganizationSummaryTopClientsByUsage, must be smaller than or equal to 16070400.');
        }
        if ($timespan !== null && $timespan < 28800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getOrganizationSummaryTopClientsByUsage, must be bigger than or equal to 28800.');
        }
        

        $resourcePath = '/organizations/{organizationId}/summary/top/clients/byUsage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_tag,
            'networkTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tag,
            'deviceTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity,
            'quantity', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_name,
            'ssidName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $usage_uplink,
            'usageUplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationSummaryTopClientsManufacturersByUsage
     *
     * Return metrics for organization&#39;s top clients by data usage (in mb) over given time range, grouped by manufacturer.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationSummaryTopClientsManufacturersByUsage200ResponseInner[]
     */
    public function getOrganizationSummaryTopClientsManufacturersByUsage($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'][0])
    {
        list($response) = $this->getOrganizationSummaryTopClientsManufacturersByUsageWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationSummaryTopClientsManufacturersByUsageWithHttpInfo
     *
     * Return metrics for organization&#39;s top clients by data usage (in mb) over given time range, grouped by manufacturer.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationSummaryTopClientsManufacturersByUsage200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationSummaryTopClientsManufacturersByUsageWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'][0])
    {
        $request = $this->getOrganizationSummaryTopClientsManufacturersByUsageRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationSummaryTopClientsManufacturersByUsage200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationSummaryTopClientsManufacturersByUsage200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationSummaryTopClientsManufacturersByUsage200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationSummaryTopClientsManufacturersByUsage200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationSummaryTopClientsManufacturersByUsage200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationSummaryTopClientsManufacturersByUsageAsync
     *
     * Return metrics for organization&#39;s top clients by data usage (in mb) over given time range, grouped by manufacturer.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopClientsManufacturersByUsageAsync($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'][0])
    {
        return $this->getOrganizationSummaryTopClientsManufacturersByUsageAsyncWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationSummaryTopClientsManufacturersByUsageAsyncWithHttpInfo
     *
     * Return metrics for organization&#39;s top clients by data usage (in mb) over given time range, grouped by manufacturer.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopClientsManufacturersByUsageAsyncWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationSummaryTopClientsManufacturersByUsage200ResponseInner[]';
        $request = $this->getOrganizationSummaryTopClientsManufacturersByUsageRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationSummaryTopClientsManufacturersByUsage'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationSummaryTopClientsManufacturersByUsageRequest($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopClientsManufacturersByUsage'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationSummaryTopClientsManufacturersByUsage'
            );
        }








        if ($timespan !== null && $timespan > 16070400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getOrganizationSummaryTopClientsManufacturersByUsage, must be smaller than or equal to 16070400.');
        }
        

        $resourcePath = '/organizations/{organizationId}/summary/top/clients/manufacturers/byUsage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_tag,
            'networkTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tag,
            'deviceTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity,
            'quantity', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_name,
            'ssidName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $usage_uplink,
            'usageUplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationSwitchPortsClientsOverviewByDevice
     *
     * List the number of clients for all switchports with at least one online client in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  \DateTime|null $configuration_updated_after Optional parameter to filter items to switches where the configuration has been updated after the given timestamp. (optional)
     * @param  string|null $mac Optional parameter to filter items to switches with MAC addresses that contain the search term or are an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter items to switches that have one of the provided MAC addresses. (optional)
     * @param  string|null $name Optional parameter to filter items to switches with names that contain the search term or are an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter items to switches in one of the provided networks. (optional)
     * @param  string[]|null $port_profile_ids Optional parameter to filter items to switches that contain switchports belonging to one of the specified port profiles. (optional)
     * @param  string|null $serial Optional parameter to filter items to switches with serial number that contains the search term or are an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter items to switches that have one of the provided serials. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationSwitchPortsClientsOverviewByDevice200Response
     */
    public function getOrganizationSwitchPortsClientsOverviewByDevice($organization_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $mac = null, $macs = null, $name = null, $network_ids = null, $port_profile_ids = null, $serial = null, $serials = null, string $contentType = self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'][0])
    {
        list($response) = $this->getOrganizationSwitchPortsClientsOverviewByDeviceWithHttpInfo($organization_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $configuration_updated_after, $mac, $macs, $name, $network_ids, $port_profile_ids, $serial, $serials, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationSwitchPortsClientsOverviewByDeviceWithHttpInfo
     *
     * List the number of clients for all switchports with at least one online client in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  \DateTime|null $configuration_updated_after Optional parameter to filter items to switches where the configuration has been updated after the given timestamp. (optional)
     * @param  string|null $mac Optional parameter to filter items to switches with MAC addresses that contain the search term or are an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter items to switches that have one of the provided MAC addresses. (optional)
     * @param  string|null $name Optional parameter to filter items to switches with names that contain the search term or are an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter items to switches in one of the provided networks. (optional)
     * @param  string[]|null $port_profile_ids Optional parameter to filter items to switches that contain switchports belonging to one of the specified port profiles. (optional)
     * @param  string|null $serial Optional parameter to filter items to switches with serial number that contains the search term or are an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter items to switches that have one of the provided serials. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationSwitchPortsClientsOverviewByDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationSwitchPortsClientsOverviewByDeviceWithHttpInfo($organization_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $mac = null, $macs = null, $name = null, $network_ids = null, $port_profile_ids = null, $serial = null, $serials = null, string $contentType = self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'][0])
    {
        $request = $this->getOrganizationSwitchPortsClientsOverviewByDeviceRequest($organization_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $configuration_updated_after, $mac, $macs, $name, $network_ids, $port_profile_ids, $serial, $serials, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationSwitchPortsClientsOverviewByDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationSwitchPortsClientsOverviewByDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationSwitchPortsClientsOverviewByDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationSwitchPortsClientsOverviewByDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationSwitchPortsClientsOverviewByDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationSwitchPortsClientsOverviewByDeviceAsync
     *
     * List the number of clients for all switchports with at least one online client in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  \DateTime|null $configuration_updated_after Optional parameter to filter items to switches where the configuration has been updated after the given timestamp. (optional)
     * @param  string|null $mac Optional parameter to filter items to switches with MAC addresses that contain the search term or are an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter items to switches that have one of the provided MAC addresses. (optional)
     * @param  string|null $name Optional parameter to filter items to switches with names that contain the search term or are an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter items to switches in one of the provided networks. (optional)
     * @param  string[]|null $port_profile_ids Optional parameter to filter items to switches that contain switchports belonging to one of the specified port profiles. (optional)
     * @param  string|null $serial Optional parameter to filter items to switches with serial number that contains the search term or are an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter items to switches that have one of the provided serials. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSwitchPortsClientsOverviewByDeviceAsync($organization_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $mac = null, $macs = null, $name = null, $network_ids = null, $port_profile_ids = null, $serial = null, $serials = null, string $contentType = self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'][0])
    {
        return $this->getOrganizationSwitchPortsClientsOverviewByDeviceAsyncWithHttpInfo($organization_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $configuration_updated_after, $mac, $macs, $name, $network_ids, $port_profile_ids, $serial, $serials, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationSwitchPortsClientsOverviewByDeviceAsyncWithHttpInfo
     *
     * List the number of clients for all switchports with at least one online client in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  \DateTime|null $configuration_updated_after Optional parameter to filter items to switches where the configuration has been updated after the given timestamp. (optional)
     * @param  string|null $mac Optional parameter to filter items to switches with MAC addresses that contain the search term or are an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter items to switches that have one of the provided MAC addresses. (optional)
     * @param  string|null $name Optional parameter to filter items to switches with names that contain the search term or are an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter items to switches in one of the provided networks. (optional)
     * @param  string[]|null $port_profile_ids Optional parameter to filter items to switches that contain switchports belonging to one of the specified port profiles. (optional)
     * @param  string|null $serial Optional parameter to filter items to switches with serial number that contains the search term or are an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter items to switches that have one of the provided serials. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSwitchPortsClientsOverviewByDeviceAsyncWithHttpInfo($organization_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $mac = null, $macs = null, $name = null, $network_ids = null, $port_profile_ids = null, $serial = null, $serials = null, string $contentType = self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationSwitchPortsClientsOverviewByDevice200Response';
        $request = $this->getOrganizationSwitchPortsClientsOverviewByDeviceRequest($organization_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $configuration_updated_after, $mac, $macs, $name, $network_ids, $port_profile_ids, $serial, $serials, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationSwitchPortsClientsOverviewByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  \DateTime|null $configuration_updated_after Optional parameter to filter items to switches where the configuration has been updated after the given timestamp. (optional)
     * @param  string|null $mac Optional parameter to filter items to switches with MAC addresses that contain the search term or are an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter items to switches that have one of the provided MAC addresses. (optional)
     * @param  string|null $name Optional parameter to filter items to switches with names that contain the search term or are an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter items to switches in one of the provided networks. (optional)
     * @param  string[]|null $port_profile_ids Optional parameter to filter items to switches that contain switchports belonging to one of the specified port profiles. (optional)
     * @param  string|null $serial Optional parameter to filter items to switches with serial number that contains the search term or are an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter items to switches that have one of the provided serials. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationSwitchPortsClientsOverviewByDeviceRequest($organization_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $mac = null, $macs = null, $name = null, $network_ids = null, $port_profile_ids = null, $serial = null, $serials = null, string $contentType = self::contentTypes['getOrganizationSwitchPortsClientsOverviewByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationSwitchPortsClientsOverviewByDevice'
            );
        }


        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getOrganizationSwitchPortsClientsOverviewByDevice, must be smaller than or equal to 2678400.');
        }
        












        $resourcePath = '/organizations/{organizationId}/switch/ports/clients/overview/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $configuration_updated_after,
            'configurationUpdatedAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mac,
            'mac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $macs,
            'macs', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $port_profile_ids,
            'portProfileIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serial,
            'serial', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessClientsOverviewByDevice
     *
     * List access point client count at the moment in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points client counts by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points client counts by its serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $campus_gateway_cluster_ids Optional parameter to filter access points client counts by MCG cluster IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessClientsOverviewByDevice200Response
     */
    public function getOrganizationWirelessClientsOverviewByDevice($organization_id, $network_ids = null, $serials = null, $campus_gateway_cluster_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'][0])
    {
        list($response) = $this->getOrganizationWirelessClientsOverviewByDeviceWithHttpInfo($organization_id, $network_ids, $serials, $campus_gateway_cluster_ids, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessClientsOverviewByDeviceWithHttpInfo
     *
     * List access point client count at the moment in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points client counts by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points client counts by its serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $campus_gateway_cluster_ids Optional parameter to filter access points client counts by MCG cluster IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessClientsOverviewByDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessClientsOverviewByDeviceWithHttpInfo($organization_id, $network_ids = null, $serials = null, $campus_gateway_cluster_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'][0])
    {
        $request = $this->getOrganizationWirelessClientsOverviewByDeviceRequest($organization_id, $network_ids, $serials, $campus_gateway_cluster_ids, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessClientsOverviewByDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessClientsOverviewByDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessClientsOverviewByDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessClientsOverviewByDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessClientsOverviewByDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessClientsOverviewByDeviceAsync
     *
     * List access point client count at the moment in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points client counts by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points client counts by its serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $campus_gateway_cluster_ids Optional parameter to filter access points client counts by MCG cluster IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessClientsOverviewByDeviceAsync($organization_id, $network_ids = null, $serials = null, $campus_gateway_cluster_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'][0])
    {
        return $this->getOrganizationWirelessClientsOverviewByDeviceAsyncWithHttpInfo($organization_id, $network_ids, $serials, $campus_gateway_cluster_ids, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessClientsOverviewByDeviceAsyncWithHttpInfo
     *
     * List access point client count at the moment in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points client counts by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points client counts by its serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $campus_gateway_cluster_ids Optional parameter to filter access points client counts by MCG cluster IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessClientsOverviewByDeviceAsyncWithHttpInfo($organization_id, $network_ids = null, $serials = null, $campus_gateway_cluster_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessClientsOverviewByDevice200Response';
        $request = $this->getOrganizationWirelessClientsOverviewByDeviceRequest($organization_id, $network_ids, $serials, $campus_gateway_cluster_ids, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessClientsOverviewByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points client counts by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points client counts by its serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $campus_gateway_cluster_ids Optional parameter to filter access points client counts by MCG cluster IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessClientsOverviewByDeviceRequest($organization_id, $network_ids = null, $serials = null, $campus_gateway_cluster_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessClientsOverviewByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessClientsOverviewByDevice'
            );
        }








        $resourcePath = '/organizations/{organizationId}/wireless/clients/overview/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $campus_gateway_cluster_ids,
            'campusGatewayClusterIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval
     *
     * List wireless client counts of wireless LAN controllers over time in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter wireless LAN controllers by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval200Response
     */
    public function getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval($organization_id, $network_ids = null, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $resolution = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalWithHttpInfo($organization_id, $network_ids, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $resolution, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalWithHttpInfo
     *
     * List wireless client counts of wireless LAN controllers over time in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter wireless LAN controllers by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalWithHttpInfo($organization_id, $network_ids = null, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $resolution = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'][0])
    {
        $request = $this->getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest($organization_id, $network_ids, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $resolution, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalAsync
     *
     * List wireless client counts of wireless LAN controllers over time in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter wireless LAN controllers by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalAsync($organization_id, $network_ids = null, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $resolution = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'][0])
    {
        return $this->getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalAsyncWithHttpInfo($organization_id, $network_ids, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $resolution, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalAsyncWithHttpInfo
     *
     * List wireless client counts of wireless LAN controllers over time in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter wireless LAN controllers by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalAsyncWithHttpInfo($organization_id, $network_ids = null, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $resolution = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval200Response';
        $request = $this->getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest($organization_id, $network_ids, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $resolution, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter wireless LAN controllers by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest($organization_id, $network_ids = null, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $resolution = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval'
            );
        }





        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ClientsApi.getOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval, must be smaller than or equal to 2678400.');
        }
        





        $resourcePath = '/organizations/{organizationId}/wirelessController/clients/overview/history/byDevice/byInterval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation provisionNetworkClients
     *
     * Provisions a client with a name and policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\ProvisionNetworkClients201Response
     */
    public function provisionNetworkClients($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {
        list($response) = $this->provisionNetworkClientsWithHttpInfo($network_id, $provision_network_clients_request, $contentType);
        return $response;
    }

    /**
     * Operation provisionNetworkClientsWithHttpInfo
     *
     * Provisions a client with a name and policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\ProvisionNetworkClients201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function provisionNetworkClientsWithHttpInfo($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {
        $request = $this->provisionNetworkClientsRequest($network_id, $provision_network_clients_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\ProvisionNetworkClients201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\ProvisionNetworkClients201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\ProvisionNetworkClients201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\ProvisionNetworkClients201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\ProvisionNetworkClients201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation provisionNetworkClientsAsync
     *
     * Provisions a client with a name and policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provisionNetworkClientsAsync($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {
        return $this->provisionNetworkClientsAsyncWithHttpInfo($network_id, $provision_network_clients_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation provisionNetworkClientsAsyncWithHttpInfo
     *
     * Provisions a client with a name and policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provisionNetworkClientsAsyncWithHttpInfo($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {
        $returnType = '\Meraki\Model\ProvisionNetworkClients201Response';
        $request = $this->provisionNetworkClientsRequest($network_id, $provision_network_clients_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'provisionNetworkClients'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function provisionNetworkClientsRequest($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling provisionNetworkClients'
            );
        }

        // verify the required parameter 'provision_network_clients_request' is set
        if ($provision_network_clients_request === null || (is_array($provision_network_clients_request) && count($provision_network_clients_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provision_network_clients_request when calling provisionNetworkClients'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/provision';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provision_network_clients_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provision_network_clients_request));
            } else {
                $httpBody = $provision_network_clients_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkClientPolicy
     *
     * Update the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientPolicy200Response
     */
    public function updateNetworkClientPolicy($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {
        list($response) = $this->updateNetworkClientPolicyWithHttpInfo($network_id, $client_id, $update_network_client_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkClientPolicyWithHttpInfo
     *
     * Update the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientPolicy200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkClientPolicyWithHttpInfo($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {
        $request = $this->updateNetworkClientPolicyRequest($network_id, $client_id, $update_network_client_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientPolicy200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientPolicy200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientPolicy200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientPolicy200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientPolicy200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkClientPolicyAsync
     *
     * Update the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkClientPolicyAsync($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {
        return $this->updateNetworkClientPolicyAsyncWithHttpInfo($network_id, $client_id, $update_network_client_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkClientPolicyAsyncWithHttpInfo
     *
     * Update the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkClientPolicyAsyncWithHttpInfo($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientPolicy200Response';
        $request = $this->updateNetworkClientPolicyRequest($network_id, $client_id, $update_network_client_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkClientPolicy'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkClientPolicyRequest($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkClientPolicy'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling updateNetworkClientPolicy'
            );
        }

        // verify the required parameter 'update_network_client_policy_request' is set
        if ($update_network_client_policy_request === null || (is_array($update_network_client_policy_request) && count($update_network_client_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_client_policy_request when calling updateNetworkClientPolicy'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_client_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_client_policy_request));
            } else {
                $httpBody = $update_network_client_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkClientSplashAuthorizationStatus
     *
     * Update a client&#39;s splash authorization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkClientSplashAuthorizationStatus($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {
        list($response) = $this->updateNetworkClientSplashAuthorizationStatusWithHttpInfo($network_id, $client_id, $update_network_client_splash_authorization_status_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkClientSplashAuthorizationStatusWithHttpInfo
     *
     * Update a client&#39;s splash authorization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkClientSplashAuthorizationStatusWithHttpInfo($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {
        $request = $this->updateNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $update_network_client_splash_authorization_status_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkClientSplashAuthorizationStatusAsync
     *
     * Update a client&#39;s splash authorization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkClientSplashAuthorizationStatusAsync($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {
        return $this->updateNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo($network_id, $client_id, $update_network_client_splash_authorization_status_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo
     *
     * Update a client&#39;s splash authorization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $update_network_client_splash_authorization_status_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkClientSplashAuthorizationStatus'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkClientSplashAuthorizationStatus'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling updateNetworkClientSplashAuthorizationStatus'
            );
        }

        // verify the required parameter 'update_network_client_splash_authorization_status_request' is set
        if ($update_network_client_splash_authorization_status_request === null || (is_array($update_network_client_splash_authorization_status_request) && count($update_network_client_splash_authorization_status_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_client_splash_authorization_status_request when calling updateNetworkClientSplashAuthorizationStatus'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_client_splash_authorization_status_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_client_splash_authorization_status_request));
            } else {
                $httpBody = $update_network_client_splash_authorization_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
