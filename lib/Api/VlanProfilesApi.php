<?php
/**
 * VlanProfilesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Meraki\ApiException;
use Meraki\Configuration;
use Meraki\HeaderSelector;
use Meraki\ObjectSerializer;

/**
 * VlanProfilesApi Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class VlanProfilesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createNetworkVlanProfile' => [
            'application/json',
        ],
        'deleteNetworkVlanProfile' => [
            'application/json',
        ],
        'getNetworkVlanProfile' => [
            'application/json',
        ],
        'getNetworkVlanProfiles' => [
            'application/json',
        ],
        'getNetworkVlanProfilesAssignmentsByDevice' => [
            'application/json',
        ],
        'reassignNetworkVlanProfilesAssignments' => [
            'application/json',
        ],
        'updateNetworkVlanProfile' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createNetworkVlanProfile
     *
     * Create a VLAN profile for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfiles200ResponseInner
     */
    public function createNetworkVlanProfile($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {
        list($response) = $this->createNetworkVlanProfileWithHttpInfo($network_id, $create_network_vlan_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkVlanProfileWithHttpInfo
     *
     * Create a VLAN profile for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkVlanProfileWithHttpInfo($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {
        $request = $this->createNetworkVlanProfileRequest($network_id, $create_network_vlan_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkVlanProfileAsync
     *
     * Create a VLAN profile for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkVlanProfileAsync($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {
        return $this->createNetworkVlanProfileAsyncWithHttpInfo($network_id, $create_network_vlan_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkVlanProfileAsyncWithHttpInfo
     *
     * Create a VLAN profile for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkVlanProfileAsyncWithHttpInfo($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
        $request = $this->createNetworkVlanProfileRequest($network_id, $create_network_vlan_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkVlanProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkVlanProfileRequest($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkVlanProfile'
            );
        }

        // verify the required parameter 'create_network_vlan_profile_request' is set
        if ($create_network_vlan_profile_request === null || (is_array($create_network_vlan_profile_request) && count($create_network_vlan_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_vlan_profile_request when calling createNetworkVlanProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_vlan_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_vlan_profile_request));
            } else {
                $httpBody = $create_network_vlan_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkVlanProfile
     *
     * Delete a VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkVlanProfile($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {
        $this->deleteNetworkVlanProfileWithHttpInfo($network_id, $iname, $contentType);
    }

    /**
     * Operation deleteNetworkVlanProfileWithHttpInfo
     *
     * Delete a VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkVlanProfileWithHttpInfo($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {
        $request = $this->deleteNetworkVlanProfileRequest($network_id, $iname, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkVlanProfileAsync
     *
     * Delete a VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkVlanProfileAsync($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {
        return $this->deleteNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkVlanProfileAsyncWithHttpInfo
     *
     * Delete a VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkVlanProfileRequest($network_id, $iname, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkVlanProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkVlanProfileRequest($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkVlanProfile'
            );
        }

        // verify the required parameter 'iname' is set
        if ($iname === null || (is_array($iname) && count($iname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iname when calling deleteNetworkVlanProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles/{iname}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($iname !== null) {
            $resourcePath = str_replace(
                '{' . 'iname' . '}',
                ObjectSerializer::toPathValue($iname),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkVlanProfile
     *
     * Get an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfiles200ResponseInner
     */
    public function getNetworkVlanProfile($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {
        list($response) = $this->getNetworkVlanProfileWithHttpInfo($network_id, $iname, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkVlanProfileWithHttpInfo
     *
     * Get an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkVlanProfileWithHttpInfo($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {
        $request = $this->getNetworkVlanProfileRequest($network_id, $iname, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkVlanProfileAsync
     *
     * Get an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfileAsync($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {
        return $this->getNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkVlanProfileAsyncWithHttpInfo
     *
     * Get an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
        $request = $this->getNetworkVlanProfileRequest($network_id, $iname, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkVlanProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkVlanProfileRequest($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkVlanProfile'
            );
        }

        // verify the required parameter 'iname' is set
        if ($iname === null || (is_array($iname) && count($iname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iname when calling getNetworkVlanProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles/{iname}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($iname !== null) {
            $resourcePath = str_replace(
                '{' . 'iname' . '}',
                ObjectSerializer::toPathValue($iname),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkVlanProfiles
     *
     * List VLAN profiles for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]
     */
    public function getNetworkVlanProfiles($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {
        list($response) = $this->getNetworkVlanProfilesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkVlanProfilesWithHttpInfo
     *
     * List VLAN profiles for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfiles200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkVlanProfilesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {
        $request = $this->getNetworkVlanProfilesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkVlanProfilesAsync
     *
     * List VLAN profiles for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfilesAsync($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {
        return $this->getNetworkVlanProfilesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkVlanProfilesAsyncWithHttpInfo
     *
     * List VLAN profiles for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfilesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]';
        $request = $this->getNetworkVlanProfilesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkVlanProfiles'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkVlanProfilesRequest($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkVlanProfiles'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkVlanProfilesAssignmentsByDevice
     *
     * Get the assigned VLAN Profiles for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]
     */
    public function getNetworkVlanProfilesAssignmentsByDevice($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {
        list($response) = $this->getNetworkVlanProfilesAssignmentsByDeviceWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $serials, $product_types, $stack_ids, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkVlanProfilesAssignmentsByDeviceWithHttpInfo
     *
     * Get the assigned VLAN Profiles for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkVlanProfilesAssignmentsByDeviceWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {
        $request = $this->getNetworkVlanProfilesAssignmentsByDeviceRequest($network_id, $per_page, $starting_after, $ending_before, $serials, $product_types, $stack_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkVlanProfilesAssignmentsByDeviceAsync
     *
     * Get the assigned VLAN Profiles for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfilesAssignmentsByDeviceAsync($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {
        return $this->getNetworkVlanProfilesAssignmentsByDeviceAsyncWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $serials, $product_types, $stack_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkVlanProfilesAssignmentsByDeviceAsyncWithHttpInfo
     *
     * Get the assigned VLAN Profiles for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfilesAssignmentsByDeviceAsyncWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]';
        $request = $this->getNetworkVlanProfilesAssignmentsByDeviceRequest($network_id, $per_page, $starting_after, $ending_before, $serials, $product_types, $stack_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkVlanProfilesAssignmentsByDevice'
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkVlanProfilesAssignmentsByDeviceRequest($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkVlanProfilesAssignmentsByDevice'
            );
        }








        $resourcePath = '/networks/{networkId}/vlanProfiles/assignments/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stack_ids,
            'stackIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reassignNetworkVlanProfilesAssignments
     *
     * Update the assigned VLAN Profile for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response
     */
    public function reassignNetworkVlanProfilesAssignments($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {
        list($response) = $this->reassignNetworkVlanProfilesAssignmentsWithHttpInfo($network_id, $reassign_network_vlan_profiles_assignments_request, $contentType);
        return $response;
    }

    /**
     * Operation reassignNetworkVlanProfilesAssignmentsWithHttpInfo
     *
     * Update the assigned VLAN Profile for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reassignNetworkVlanProfilesAssignmentsWithHttpInfo($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {
        $request = $this->reassignNetworkVlanProfilesAssignmentsRequest($network_id, $reassign_network_vlan_profiles_assignments_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reassignNetworkVlanProfilesAssignmentsAsync
     *
     * Update the assigned VLAN Profile for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reassignNetworkVlanProfilesAssignmentsAsync($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {
        return $this->reassignNetworkVlanProfilesAssignmentsAsyncWithHttpInfo($network_id, $reassign_network_vlan_profiles_assignments_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reassignNetworkVlanProfilesAssignmentsAsyncWithHttpInfo
     *
     * Update the assigned VLAN Profile for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reassignNetworkVlanProfilesAssignmentsAsyncWithHttpInfo($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {
        $returnType = '\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response';
        $request = $this->reassignNetworkVlanProfilesAssignmentsRequest($network_id, $reassign_network_vlan_profiles_assignments_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reassignNetworkVlanProfilesAssignments'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reassignNetworkVlanProfilesAssignmentsRequest($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling reassignNetworkVlanProfilesAssignments'
            );
        }

        // verify the required parameter 'reassign_network_vlan_profiles_assignments_request' is set
        if ($reassign_network_vlan_profiles_assignments_request === null || (is_array($reassign_network_vlan_profiles_assignments_request) && count($reassign_network_vlan_profiles_assignments_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reassign_network_vlan_profiles_assignments_request when calling reassignNetworkVlanProfilesAssignments'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles/assignments/reassign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reassign_network_vlan_profiles_assignments_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reassign_network_vlan_profiles_assignments_request));
            } else {
                $httpBody = $reassign_network_vlan_profiles_assignments_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkVlanProfile
     *
     * Update an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfiles200ResponseInner
     */
    public function updateNetworkVlanProfile($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {
        list($response) = $this->updateNetworkVlanProfileWithHttpInfo($network_id, $iname, $update_network_vlan_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkVlanProfileWithHttpInfo
     *
     * Update an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkVlanProfileWithHttpInfo($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {
        $request = $this->updateNetworkVlanProfileRequest($network_id, $iname, $update_network_vlan_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkVlanProfileAsync
     *
     * Update an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkVlanProfileAsync($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {
        return $this->updateNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, $update_network_vlan_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkVlanProfileAsyncWithHttpInfo
     *
     * Update an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
        $request = $this->updateNetworkVlanProfileRequest($network_id, $iname, $update_network_vlan_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkVlanProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkVlanProfileRequest($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkVlanProfile'
            );
        }

        // verify the required parameter 'iname' is set
        if ($iname === null || (is_array($iname) && count($iname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iname when calling updateNetworkVlanProfile'
            );
        }

        // verify the required parameter 'update_network_vlan_profile_request' is set
        if ($update_network_vlan_profile_request === null || (is_array($update_network_vlan_profile_request) && count($update_network_vlan_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_vlan_profile_request when calling updateNetworkVlanProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles/{iname}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($iname !== null) {
            $resourcePath = str_replace(
                '{' . 'iname' . '}',
                ObjectSerializer::toPathValue($iname),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_vlan_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_vlan_profile_request));
            } else {
                $httpBody = $update_network_vlan_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
