<?php
/**
 * ApplianceApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Meraki\ApiException;
use Meraki\Configuration;
use Meraki\HeaderSelector;
use Meraki\ObjectSerializer;

/**
 * ApplianceApi Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ApplianceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate' => [
            'application/json',
        ],
        'createDeviceApplianceVmxAuthenticationToken' => [
            'application/json',
        ],
        'createNetworkAppliancePrefixesDelegatedStatic' => [
            'application/json',
        ],
        'createNetworkApplianceRfProfile' => [
            'application/json',
        ],
        'createNetworkApplianceStaticRoute' => [
            'application/json',
        ],
        'createNetworkApplianceTrafficShapingCustomPerformanceClass' => [
            'application/json',
        ],
        'createNetworkApplianceVlan' => [
            'application/json',
        ],
        'createOrganizationApplianceDnsLocalProfile' => [
            'application/json',
        ],
        'createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete' => [
            'application/json',
        ],
        'createOrganizationApplianceDnsLocalRecord' => [
            'application/json',
        ],
        'createOrganizationApplianceDnsSplitProfile' => [
            'application/json',
        ],
        'createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate' => [
            'application/json',
        ],
        'createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete' => [
            'application/json',
        ],
        'deleteNetworkAppliancePrefixesDelegatedStatic' => [
            'application/json',
        ],
        'deleteNetworkApplianceRfProfile' => [
            'application/json',
        ],
        'deleteNetworkApplianceStaticRoute' => [
            'application/json',
        ],
        'deleteNetworkApplianceTrafficShapingCustomPerformanceClass' => [
            'application/json',
        ],
        'deleteNetworkApplianceVlan' => [
            'application/json',
        ],
        'deleteOrganizationApplianceDnsLocalProfile' => [
            'application/json',
        ],
        'deleteOrganizationApplianceDnsLocalRecord' => [
            'application/json',
        ],
        'deleteOrganizationApplianceDnsSplitProfile' => [
            'application/json',
        ],
        'getDeviceApplianceDhcpSubnets' => [
            'application/json',
        ],
        'getDeviceAppliancePerformance' => [
            'application/json',
        ],
        'getDeviceAppliancePrefixesDelegated' => [
            'application/json',
        ],
        'getDeviceAppliancePrefixesDelegatedVlanAssignments' => [
            'application/json',
        ],
        'getDeviceApplianceRadioSettings' => [
            'application/json',
        ],
        'getDeviceApplianceUplinksSettings' => [
            'application/json',
        ],
        'getNetworkApplianceClientSecurityEvents' => [
            'application/json',
        ],
        'getNetworkApplianceConnectivityMonitoringDestinations' => [
            'application/json',
        ],
        'getNetworkApplianceContentFiltering' => [
            'application/json',
        ],
        'getNetworkApplianceContentFilteringCategories' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallCellularFirewallRules' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallFirewalledService' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallFirewalledServices' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallInboundCellularFirewallRules' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallInboundFirewallRules' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallL3FirewallRules' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallL7FirewallRules' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallL7FirewallRulesApplicationCategories' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallOneToManyNatRules' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallOneToOneNatRules' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallPortForwardingRules' => [
            'application/json',
        ],
        'getNetworkApplianceFirewallSettings' => [
            'application/json',
        ],
        'getNetworkAppliancePort' => [
            'application/json',
        ],
        'getNetworkAppliancePorts' => [
            'application/json',
        ],
        'getNetworkAppliancePrefixesDelegatedStatic' => [
            'application/json',
        ],
        'getNetworkAppliancePrefixesDelegatedStatics' => [
            'application/json',
        ],
        'getNetworkApplianceRfProfile' => [
            'application/json',
        ],
        'getNetworkApplianceRfProfiles' => [
            'application/json',
        ],
        'getNetworkApplianceSecurityEvents' => [
            'application/json',
        ],
        'getNetworkApplianceSecurityIntrusion' => [
            'application/json',
        ],
        'getNetworkApplianceSecurityMalware' => [
            'application/json',
        ],
        'getNetworkApplianceSettings' => [
            'application/json',
        ],
        'getNetworkApplianceSingleLan' => [
            'application/json',
        ],
        'getNetworkApplianceSsid' => [
            'application/json',
        ],
        'getNetworkApplianceSsids' => [
            'application/json',
        ],
        'getNetworkApplianceStaticRoute' => [
            'application/json',
        ],
        'getNetworkApplianceStaticRoutes' => [
            'application/json',
        ],
        'getNetworkApplianceTrafficShaping' => [
            'application/json',
        ],
        'getNetworkApplianceTrafficShapingCustomPerformanceClass' => [
            'application/json',
        ],
        'getNetworkApplianceTrafficShapingCustomPerformanceClasses' => [
            'application/json',
        ],
        'getNetworkApplianceTrafficShapingRules' => [
            'application/json',
        ],
        'getNetworkApplianceTrafficShapingUplinkBandwidth' => [
            'application/json',
        ],
        'getNetworkApplianceTrafficShapingUplinkSelection' => [
            'application/json',
        ],
        'getNetworkApplianceUplinksUsageHistory' => [
            'application/json',
        ],
        'getNetworkApplianceVlan' => [
            'application/json',
        ],
        'getNetworkApplianceVlans' => [
            'application/json',
        ],
        'getNetworkApplianceVlansSettings' => [
            'application/json',
        ],
        'getNetworkApplianceVpnBgp' => [
            'application/json',
        ],
        'getNetworkApplianceVpnSiteToSiteVpn' => [
            'application/json',
        ],
        'getNetworkApplianceWarmSpare' => [
            'application/json',
        ],
        'getOrganizationApplianceDnsLocalProfiles' => [
            'application/json',
        ],
        'getOrganizationApplianceDnsLocalProfilesAssignments' => [
            'application/json',
        ],
        'getOrganizationApplianceDnsLocalRecords' => [
            'application/json',
        ],
        'getOrganizationApplianceDnsSplitProfiles' => [
            'application/json',
        ],
        'getOrganizationApplianceDnsSplitProfilesAssignments' => [
            'application/json',
        ],
        'getOrganizationApplianceFirewallMulticastForwardingByNetwork' => [
            'application/json',
        ],
        'getOrganizationApplianceSecurityEvents' => [
            'application/json',
        ],
        'getOrganizationApplianceSecurityIntrusion' => [
            'application/json',
        ],
        'getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork' => [
            'application/json',
        ],
        'getOrganizationApplianceUplinkStatuses' => [
            'application/json',
        ],
        'getOrganizationApplianceUplinksStatusesOverview' => [
            'application/json',
        ],
        'getOrganizationApplianceUplinksUsageByNetwork' => [
            'application/json',
        ],
        'getOrganizationApplianceVpnStats' => [
            'application/json',
        ],
        'getOrganizationApplianceVpnStatuses' => [
            'application/json',
        ],
        'getOrganizationApplianceVpnThirdPartyVPNPeers' => [
            'application/json',
        ],
        'getOrganizationApplianceVpnVpnFirewallRules' => [
            'application/json',
        ],
        'swapNetworkApplianceWarmSpare' => [
            'application/json',
        ],
        'updateDeviceApplianceRadioSettings' => [
            'application/json',
        ],
        'updateDeviceApplianceUplinksSettings' => [
            'application/json',
        ],
        'updateNetworkApplianceConnectivityMonitoringDestinations' => [
            'application/json',
        ],
        'updateNetworkApplianceContentFiltering' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallCellularFirewallRules' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallFirewalledService' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallInboundCellularFirewallRules' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallInboundFirewallRules' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallL3FirewallRules' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallL7FirewallRules' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallMulticastForwarding' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallOneToManyNatRules' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallOneToOneNatRules' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallPortForwardingRules' => [
            'application/json',
        ],
        'updateNetworkApplianceFirewallSettings' => [
            'application/json',
        ],
        'updateNetworkAppliancePort' => [
            'application/json',
        ],
        'updateNetworkAppliancePrefixesDelegatedStatic' => [
            'application/json',
        ],
        'updateNetworkApplianceRfProfile' => [
            'application/json',
        ],
        'updateNetworkApplianceSdwanInternetPolicies' => [
            'application/json',
        ],
        'updateNetworkApplianceSecurityIntrusion' => [
            'application/json',
        ],
        'updateNetworkApplianceSecurityMalware' => [
            'application/json',
        ],
        'updateNetworkApplianceSettings' => [
            'application/json',
        ],
        'updateNetworkApplianceSingleLan' => [
            'application/json',
        ],
        'updateNetworkApplianceSsid' => [
            'application/json',
        ],
        'updateNetworkApplianceStaticRoute' => [
            'application/json',
        ],
        'updateNetworkApplianceTrafficShaping' => [
            'application/json',
        ],
        'updateNetworkApplianceTrafficShapingCustomPerformanceClass' => [
            'application/json',
        ],
        'updateNetworkApplianceTrafficShapingRules' => [
            'application/json',
        ],
        'updateNetworkApplianceTrafficShapingUplinkBandwidth' => [
            'application/json',
        ],
        'updateNetworkApplianceTrafficShapingUplinkSelection' => [
            'application/json',
        ],
        'updateNetworkApplianceTrafficShapingVpnExclusions' => [
            'application/json',
        ],
        'updateNetworkApplianceVlan' => [
            'application/json',
        ],
        'updateNetworkApplianceVlansSettings' => [
            'application/json',
        ],
        'updateNetworkApplianceVpnBgp' => [
            'application/json',
        ],
        'updateNetworkApplianceVpnSiteToSiteVpn' => [
            'application/json',
        ],
        'updateNetworkApplianceWarmSpare' => [
            'application/json',
        ],
        'updateOrganizationApplianceDnsLocalProfile' => [
            'application/json',
        ],
        'updateOrganizationApplianceDnsLocalRecord' => [
            'application/json',
        ],
        'updateOrganizationApplianceDnsSplitProfile' => [
            'application/json',
        ],
        'updateOrganizationApplianceSecurityIntrusion' => [
            'application/json',
        ],
        'updateOrganizationApplianceVpnThirdPartyVPNPeers' => [
            'application/json',
        ],
        'updateOrganizationApplianceVpnVpnFirewallRules' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate
     *
     * Assign the local DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response
     */
    public function bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'][0])
    {
        list($response) = $this->bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateWithHttpInfo($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, $contentType);
        return $response;
    }

    /**
     * Operation bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateWithHttpInfo
     *
     * Assign the local DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateWithHttpInfo($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'][0])
    {
        $request = $this->bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateAsync
     *
     * Assign the local DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateAsync($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'][0])
    {
        return $this->bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateAsyncWithHttpInfo($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateAsyncWithHttpInfo
     *
     * Assign the local DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateAsyncWithHttpInfo($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'][0])
    {
        $returnType = '\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response';
        $request = $this->bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'
            );
        }

        // verify the required parameter 'bulk_organization_appliance_dns_local_profiles_assignments_create_request' is set
        if ($bulk_organization_appliance_dns_local_profiles_assignments_create_request === null || (is_array($bulk_organization_appliance_dns_local_profiles_assignments_create_request) && count($bulk_organization_appliance_dns_local_profiles_assignments_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulk_organization_appliance_dns_local_profiles_assignments_create_request when calling bulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/profiles/assignments/bulkCreate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_organization_appliance_dns_local_profiles_assignments_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_organization_appliance_dns_local_profiles_assignments_create_request));
            } else {
                $httpBody = $bulk_organization_appliance_dns_local_profiles_assignments_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDeviceApplianceVmxAuthenticationToken
     *
     * Generate a new vMX authentication token
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceApplianceVmxAuthenticationToken'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateDeviceApplianceVmxAuthenticationToken201Response
     */
    public function createDeviceApplianceVmxAuthenticationToken($serial, string $contentType = self::contentTypes['createDeviceApplianceVmxAuthenticationToken'][0])
    {
        list($response) = $this->createDeviceApplianceVmxAuthenticationTokenWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation createDeviceApplianceVmxAuthenticationTokenWithHttpInfo
     *
     * Generate a new vMX authentication token
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceApplianceVmxAuthenticationToken'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateDeviceApplianceVmxAuthenticationToken201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeviceApplianceVmxAuthenticationTokenWithHttpInfo($serial, string $contentType = self::contentTypes['createDeviceApplianceVmxAuthenticationToken'][0])
    {
        $request = $this->createDeviceApplianceVmxAuthenticationTokenRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateDeviceApplianceVmxAuthenticationToken201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateDeviceApplianceVmxAuthenticationToken201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateDeviceApplianceVmxAuthenticationToken201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateDeviceApplianceVmxAuthenticationToken201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateDeviceApplianceVmxAuthenticationToken201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeviceApplianceVmxAuthenticationTokenAsync
     *
     * Generate a new vMX authentication token
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceApplianceVmxAuthenticationToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceApplianceVmxAuthenticationTokenAsync($serial, string $contentType = self::contentTypes['createDeviceApplianceVmxAuthenticationToken'][0])
    {
        return $this->createDeviceApplianceVmxAuthenticationTokenAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeviceApplianceVmxAuthenticationTokenAsyncWithHttpInfo
     *
     * Generate a new vMX authentication token
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceApplianceVmxAuthenticationToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceApplianceVmxAuthenticationTokenAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['createDeviceApplianceVmxAuthenticationToken'][0])
    {
        $returnType = '\Meraki\Model\CreateDeviceApplianceVmxAuthenticationToken201Response';
        $request = $this->createDeviceApplianceVmxAuthenticationTokenRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeviceApplianceVmxAuthenticationToken'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceApplianceVmxAuthenticationToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDeviceApplianceVmxAuthenticationTokenRequest($serial, string $contentType = self::contentTypes['createDeviceApplianceVmxAuthenticationToken'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling createDeviceApplianceVmxAuthenticationToken'
            );
        }


        $resourcePath = '/devices/{serial}/appliance/vmx/authenticationToken';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkAppliancePrefixesDelegatedStatic
     *
     * Add a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkAppliancePrefixesDelegatedStaticRequest $create_network_appliance_prefixes_delegated_static_request create_network_appliance_prefixes_delegated_static_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createNetworkAppliancePrefixesDelegatedStatic($network_id, $create_network_appliance_prefixes_delegated_static_request, string $contentType = self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        list($response) = $this->createNetworkAppliancePrefixesDelegatedStaticWithHttpInfo($network_id, $create_network_appliance_prefixes_delegated_static_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkAppliancePrefixesDelegatedStaticWithHttpInfo
     *
     * Add a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkAppliancePrefixesDelegatedStaticRequest $create_network_appliance_prefixes_delegated_static_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkAppliancePrefixesDelegatedStaticWithHttpInfo($network_id, $create_network_appliance_prefixes_delegated_static_request, string $contentType = self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        $request = $this->createNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $create_network_appliance_prefixes_delegated_static_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkAppliancePrefixesDelegatedStaticAsync
     *
     * Add a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkAppliancePrefixesDelegatedStaticRequest $create_network_appliance_prefixes_delegated_static_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkAppliancePrefixesDelegatedStaticAsync($network_id, $create_network_appliance_prefixes_delegated_static_request, string $contentType = self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        return $this->createNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo($network_id, $create_network_appliance_prefixes_delegated_static_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo
     *
     * Add a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkAppliancePrefixesDelegatedStaticRequest $create_network_appliance_prefixes_delegated_static_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo($network_id, $create_network_appliance_prefixes_delegated_static_request, string $contentType = self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        $returnType = 'object';
        $request = $this->createNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $create_network_appliance_prefixes_delegated_static_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkAppliancePrefixesDelegatedStatic'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkAppliancePrefixesDelegatedStaticRequest $create_network_appliance_prefixes_delegated_static_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $create_network_appliance_prefixes_delegated_static_request, string $contentType = self::contentTypes['createNetworkAppliancePrefixesDelegatedStatic'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkAppliancePrefixesDelegatedStatic'
            );
        }

        // verify the required parameter 'create_network_appliance_prefixes_delegated_static_request' is set
        if ($create_network_appliance_prefixes_delegated_static_request === null || (is_array($create_network_appliance_prefixes_delegated_static_request) && count($create_network_appliance_prefixes_delegated_static_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_appliance_prefixes_delegated_static_request when calling createNetworkAppliancePrefixesDelegatedStatic'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/prefixes/delegated/statics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_appliance_prefixes_delegated_static_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_appliance_prefixes_delegated_static_request));
            } else {
                $httpBody = $create_network_appliance_prefixes_delegated_static_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkApplianceRfProfile
     *
     * Creates new RF profile for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceRfProfileRequest $create_network_appliance_rf_profile_request create_network_appliance_rf_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner
     */
    public function createNetworkApplianceRfProfile($network_id, $create_network_appliance_rf_profile_request, string $contentType = self::contentTypes['createNetworkApplianceRfProfile'][0])
    {
        list($response) = $this->createNetworkApplianceRfProfileWithHttpInfo($network_id, $create_network_appliance_rf_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkApplianceRfProfileWithHttpInfo
     *
     * Creates new RF profile for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceRfProfileRequest $create_network_appliance_rf_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkApplianceRfProfileWithHttpInfo($network_id, $create_network_appliance_rf_profile_request, string $contentType = self::contentTypes['createNetworkApplianceRfProfile'][0])
    {
        $request = $this->createNetworkApplianceRfProfileRequest($network_id, $create_network_appliance_rf_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkApplianceRfProfileAsync
     *
     * Creates new RF profile for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceRfProfileRequest $create_network_appliance_rf_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkApplianceRfProfileAsync($network_id, $create_network_appliance_rf_profile_request, string $contentType = self::contentTypes['createNetworkApplianceRfProfile'][0])
    {
        return $this->createNetworkApplianceRfProfileAsyncWithHttpInfo($network_id, $create_network_appliance_rf_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkApplianceRfProfileAsyncWithHttpInfo
     *
     * Creates new RF profile for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceRfProfileRequest $create_network_appliance_rf_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkApplianceRfProfileAsyncWithHttpInfo($network_id, $create_network_appliance_rf_profile_request, string $contentType = self::contentTypes['createNetworkApplianceRfProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner';
        $request = $this->createNetworkApplianceRfProfileRequest($network_id, $create_network_appliance_rf_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkApplianceRfProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceRfProfileRequest $create_network_appliance_rf_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkApplianceRfProfileRequest($network_id, $create_network_appliance_rf_profile_request, string $contentType = self::contentTypes['createNetworkApplianceRfProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkApplianceRfProfile'
            );
        }

        // verify the required parameter 'create_network_appliance_rf_profile_request' is set
        if ($create_network_appliance_rf_profile_request === null || (is_array($create_network_appliance_rf_profile_request) && count($create_network_appliance_rf_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_appliance_rf_profile_request when calling createNetworkApplianceRfProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/rfProfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_appliance_rf_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_appliance_rf_profile_request));
            } else {
                $httpBody = $create_network_appliance_rf_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkApplianceStaticRoute
     *
     * Add a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceStaticRouteRequest $create_network_appliance_static_route_request create_network_appliance_static_route_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner
     */
    public function createNetworkApplianceStaticRoute($network_id, $create_network_appliance_static_route_request, string $contentType = self::contentTypes['createNetworkApplianceStaticRoute'][0])
    {
        list($response) = $this->createNetworkApplianceStaticRouteWithHttpInfo($network_id, $create_network_appliance_static_route_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkApplianceStaticRouteWithHttpInfo
     *
     * Add a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceStaticRouteRequest $create_network_appliance_static_route_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkApplianceStaticRouteWithHttpInfo($network_id, $create_network_appliance_static_route_request, string $contentType = self::contentTypes['createNetworkApplianceStaticRoute'][0])
    {
        $request = $this->createNetworkApplianceStaticRouteRequest($network_id, $create_network_appliance_static_route_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkApplianceStaticRouteAsync
     *
     * Add a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceStaticRouteRequest $create_network_appliance_static_route_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkApplianceStaticRouteAsync($network_id, $create_network_appliance_static_route_request, string $contentType = self::contentTypes['createNetworkApplianceStaticRoute'][0])
    {
        return $this->createNetworkApplianceStaticRouteAsyncWithHttpInfo($network_id, $create_network_appliance_static_route_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkApplianceStaticRouteAsyncWithHttpInfo
     *
     * Add a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceStaticRouteRequest $create_network_appliance_static_route_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkApplianceStaticRouteAsyncWithHttpInfo($network_id, $create_network_appliance_static_route_request, string $contentType = self::contentTypes['createNetworkApplianceStaticRoute'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner';
        $request = $this->createNetworkApplianceStaticRouteRequest($network_id, $create_network_appliance_static_route_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkApplianceStaticRoute'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceStaticRouteRequest $create_network_appliance_static_route_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkApplianceStaticRouteRequest($network_id, $create_network_appliance_static_route_request, string $contentType = self::contentTypes['createNetworkApplianceStaticRoute'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkApplianceStaticRoute'
            );
        }

        // verify the required parameter 'create_network_appliance_static_route_request' is set
        if ($create_network_appliance_static_route_request === null || (is_array($create_network_appliance_static_route_request) && count($create_network_appliance_static_route_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_appliance_static_route_request when calling createNetworkApplianceStaticRoute'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/staticRoutes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_appliance_static_route_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_appliance_static_route_request));
            } else {
                $httpBody = $create_network_appliance_static_route_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkApplianceTrafficShapingCustomPerformanceClass
     *
     * Add a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceTrafficShapingCustomPerformanceClassRequest $create_network_appliance_traffic_shaping_custom_performance_class_request create_network_appliance_traffic_shaping_custom_performance_class_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner
     */
    public function createNetworkApplianceTrafficShapingCustomPerformanceClass($network_id, $create_network_appliance_traffic_shaping_custom_performance_class_request, string $contentType = self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        list($response) = $this->createNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo($network_id, $create_network_appliance_traffic_shaping_custom_performance_class_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo
     *
     * Add a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceTrafficShapingCustomPerformanceClassRequest $create_network_appliance_traffic_shaping_custom_performance_class_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo($network_id, $create_network_appliance_traffic_shaping_custom_performance_class_request, string $contentType = self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        $request = $this->createNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $create_network_appliance_traffic_shaping_custom_performance_class_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkApplianceTrafficShapingCustomPerformanceClassAsync
     *
     * Add a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceTrafficShapingCustomPerformanceClassRequest $create_network_appliance_traffic_shaping_custom_performance_class_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkApplianceTrafficShapingCustomPerformanceClassAsync($network_id, $create_network_appliance_traffic_shaping_custom_performance_class_request, string $contentType = self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        return $this->createNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo($network_id, $create_network_appliance_traffic_shaping_custom_performance_class_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo
     *
     * Add a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceTrafficShapingCustomPerformanceClassRequest $create_network_appliance_traffic_shaping_custom_performance_class_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo($network_id, $create_network_appliance_traffic_shaping_custom_performance_class_request, string $contentType = self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner';
        $request = $this->createNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $create_network_appliance_traffic_shaping_custom_performance_class_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkApplianceTrafficShapingCustomPerformanceClass'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceTrafficShapingCustomPerformanceClassRequest $create_network_appliance_traffic_shaping_custom_performance_class_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $create_network_appliance_traffic_shaping_custom_performance_class_request, string $contentType = self::contentTypes['createNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkApplianceTrafficShapingCustomPerformanceClass'
            );
        }

        // verify the required parameter 'create_network_appliance_traffic_shaping_custom_performance_class_request' is set
        if ($create_network_appliance_traffic_shaping_custom_performance_class_request === null || (is_array($create_network_appliance_traffic_shaping_custom_performance_class_request) && count($create_network_appliance_traffic_shaping_custom_performance_class_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_appliance_traffic_shaping_custom_performance_class_request when calling createNetworkApplianceTrafficShapingCustomPerformanceClass'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_appliance_traffic_shaping_custom_performance_class_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_appliance_traffic_shaping_custom_performance_class_request));
            } else {
                $httpBody = $create_network_appliance_traffic_shaping_custom_performance_class_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkApplianceVlan
     *
     * Add a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceVlanRequest $create_network_appliance_vlan_request create_network_appliance_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateNetworkApplianceVlan201Response
     */
    public function createNetworkApplianceVlan($network_id, $create_network_appliance_vlan_request, string $contentType = self::contentTypes['createNetworkApplianceVlan'][0])
    {
        list($response) = $this->createNetworkApplianceVlanWithHttpInfo($network_id, $create_network_appliance_vlan_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkApplianceVlanWithHttpInfo
     *
     * Add a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceVlanRequest $create_network_appliance_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateNetworkApplianceVlan201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkApplianceVlanWithHttpInfo($network_id, $create_network_appliance_vlan_request, string $contentType = self::contentTypes['createNetworkApplianceVlan'][0])
    {
        $request = $this->createNetworkApplianceVlanRequest($network_id, $create_network_appliance_vlan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateNetworkApplianceVlan201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateNetworkApplianceVlan201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateNetworkApplianceVlan201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateNetworkApplianceVlan201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateNetworkApplianceVlan201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkApplianceVlanAsync
     *
     * Add a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceVlanRequest $create_network_appliance_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkApplianceVlanAsync($network_id, $create_network_appliance_vlan_request, string $contentType = self::contentTypes['createNetworkApplianceVlan'][0])
    {
        return $this->createNetworkApplianceVlanAsyncWithHttpInfo($network_id, $create_network_appliance_vlan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkApplianceVlanAsyncWithHttpInfo
     *
     * Add a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceVlanRequest $create_network_appliance_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkApplianceVlanAsyncWithHttpInfo($network_id, $create_network_appliance_vlan_request, string $contentType = self::contentTypes['createNetworkApplianceVlan'][0])
    {
        $returnType = '\Meraki\Model\CreateNetworkApplianceVlan201Response';
        $request = $this->createNetworkApplianceVlanRequest($network_id, $create_network_appliance_vlan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkApplianceVlan'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkApplianceVlanRequest $create_network_appliance_vlan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkApplianceVlanRequest($network_id, $create_network_appliance_vlan_request, string $contentType = self::contentTypes['createNetworkApplianceVlan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkApplianceVlan'
            );
        }

        // verify the required parameter 'create_network_appliance_vlan_request' is set
        if ($create_network_appliance_vlan_request === null || (is_array($create_network_appliance_vlan_request) && count($create_network_appliance_vlan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_appliance_vlan_request when calling createNetworkApplianceVlan'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/vlans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_appliance_vlan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_appliance_vlan_request));
            } else {
                $httpBody = $create_network_appliance_vlan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationApplianceDnsLocalProfile
     *
     * Create a new local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner
     */
    public function createOrganizationApplianceDnsLocalProfile($organization_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfile'][0])
    {
        list($response) = $this->createOrganizationApplianceDnsLocalProfileWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationApplianceDnsLocalProfileWithHttpInfo
     *
     * Create a new local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationApplianceDnsLocalProfileWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfile'][0])
    {
        $request = $this->createOrganizationApplianceDnsLocalProfileRequest($organization_id, $create_organization_appliance_dns_local_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationApplianceDnsLocalProfileAsync
     *
     * Create a new local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsLocalProfileAsync($organization_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfile'][0])
    {
        return $this->createOrganizationApplianceDnsLocalProfileAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationApplianceDnsLocalProfileAsyncWithHttpInfo
     *
     * Create a new local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsLocalProfileAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfile'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner';
        $request = $this->createOrganizationApplianceDnsLocalProfileRequest($organization_id, $create_organization_appliance_dns_local_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationApplianceDnsLocalProfile'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationApplianceDnsLocalProfileRequest($organization_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfile'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationApplianceDnsLocalProfile'
            );
        }

        // verify the required parameter 'create_organization_appliance_dns_local_profile_request' is set
        if ($create_organization_appliance_dns_local_profile_request === null || (is_array($create_organization_appliance_dns_local_profile_request) && count($create_organization_appliance_dns_local_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_appliance_dns_local_profile_request when calling createOrganizationApplianceDnsLocalProfile'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_appliance_dns_local_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_appliance_dns_local_profile_request));
            } else {
                $httpBody = $create_organization_appliance_dns_local_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete
     *
     * Unassign the local DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response
     */
    public function createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'][0])
    {
        list($response) = $this->createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteWithHttpInfo
     *
     * Unassign the local DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'][0])
    {
        $request = $this->createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteAsync
     *
     * Unassign the local DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteAsync($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'][0])
    {
        return $this->createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteAsyncWithHttpInfo
     *
     * Unassign the local DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'][0])
    {
        $returnType = '\Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreate200Response';
        $request = $this->createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'
            );
        }

        // verify the required parameter 'create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request' is set
        if ($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request === null || (is_array($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request) && count($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request when calling createOrganizationApplianceDnsLocalProfilesAssignmentsBulkDelete'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/profiles/assignments/bulkDelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request));
            } else {
                $httpBody = $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationApplianceDnsLocalRecord
     *
     * Create a new local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalRecordRequest $create_organization_appliance_dns_local_record_request create_organization_appliance_dns_local_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]
     */
    public function createOrganizationApplianceDnsLocalRecord($organization_id, $create_organization_appliance_dns_local_record_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalRecord'][0])
    {
        list($response) = $this->createOrganizationApplianceDnsLocalRecordWithHttpInfo($organization_id, $create_organization_appliance_dns_local_record_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationApplianceDnsLocalRecordWithHttpInfo
     *
     * Create a new local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalRecordRequest $create_organization_appliance_dns_local_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationApplianceDnsLocalRecordWithHttpInfo($organization_id, $create_organization_appliance_dns_local_record_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalRecord'][0])
    {
        $request = $this->createOrganizationApplianceDnsLocalRecordRequest($organization_id, $create_organization_appliance_dns_local_record_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationApplianceDnsLocalRecordAsync
     *
     * Create a new local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalRecordRequest $create_organization_appliance_dns_local_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsLocalRecordAsync($organization_id, $create_organization_appliance_dns_local_record_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalRecord'][0])
    {
        return $this->createOrganizationApplianceDnsLocalRecordAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_local_record_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationApplianceDnsLocalRecordAsyncWithHttpInfo
     *
     * Create a new local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalRecordRequest $create_organization_appliance_dns_local_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsLocalRecordAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_local_record_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalRecord'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]';
        $request = $this->createOrganizationApplianceDnsLocalRecordRequest($organization_id, $create_organization_appliance_dns_local_record_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationApplianceDnsLocalRecord'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalRecordRequest $create_organization_appliance_dns_local_record_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationApplianceDnsLocalRecordRequest($organization_id, $create_organization_appliance_dns_local_record_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsLocalRecord'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationApplianceDnsLocalRecord'
            );
        }

        // verify the required parameter 'create_organization_appliance_dns_local_record_request' is set
        if ($create_organization_appliance_dns_local_record_request === null || (is_array($create_organization_appliance_dns_local_record_request) && count($create_organization_appliance_dns_local_record_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_appliance_dns_local_record_request when calling createOrganizationApplianceDnsLocalRecord'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/records';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_appliance_dns_local_record_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_appliance_dns_local_record_request));
            } else {
                $httpBody = $create_organization_appliance_dns_local_record_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfile
     *
     * Create a new split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsSplitProfileRequest $create_organization_appliance_dns_split_profile_request create_organization_appliance_dns_split_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner
     */
    public function createOrganizationApplianceDnsSplitProfile($organization_id, $create_organization_appliance_dns_split_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfile'][0])
    {
        list($response) = $this->createOrganizationApplianceDnsSplitProfileWithHttpInfo($organization_id, $create_organization_appliance_dns_split_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfileWithHttpInfo
     *
     * Create a new split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsSplitProfileRequest $create_organization_appliance_dns_split_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationApplianceDnsSplitProfileWithHttpInfo($organization_id, $create_organization_appliance_dns_split_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfile'][0])
    {
        $request = $this->createOrganizationApplianceDnsSplitProfileRequest($organization_id, $create_organization_appliance_dns_split_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfileAsync
     *
     * Create a new split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsSplitProfileRequest $create_organization_appliance_dns_split_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsSplitProfileAsync($organization_id, $create_organization_appliance_dns_split_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfile'][0])
    {
        return $this->createOrganizationApplianceDnsSplitProfileAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_split_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfileAsyncWithHttpInfo
     *
     * Create a new split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsSplitProfileRequest $create_organization_appliance_dns_split_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsSplitProfileAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_split_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfile'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner';
        $request = $this->createOrganizationApplianceDnsSplitProfileRequest($organization_id, $create_organization_appliance_dns_split_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationApplianceDnsSplitProfile'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsSplitProfileRequest $create_organization_appliance_dns_split_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationApplianceDnsSplitProfileRequest($organization_id, $create_organization_appliance_dns_split_profile_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfile'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationApplianceDnsSplitProfile'
            );
        }

        // verify the required parameter 'create_organization_appliance_dns_split_profile_request' is set
        if ($create_organization_appliance_dns_split_profile_request === null || (is_array($create_organization_appliance_dns_split_profile_request) && count($create_organization_appliance_dns_split_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_appliance_dns_split_profile_request when calling createOrganizationApplianceDnsSplitProfile'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/split/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_appliance_dns_split_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_appliance_dns_split_profile_request));
            } else {
                $httpBody = $create_organization_appliance_dns_split_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate
     *
     * Assign the split DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'][0])
    {
        list($response) = $this->createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateWithHttpInfo($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateWithHttpInfo
     *
     * Assign the split DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateWithHttpInfo($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'][0])
    {
        $request = $this->createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateRequest($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateAsync
     *
     * Assign the split DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateAsync($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'][0])
    {
        return $this->createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateAsyncWithHttpInfo($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateAsyncWithHttpInfo
     *
     * Assign the split DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateAsyncWithHttpInfo($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'][0])
    {
        $returnType = '\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response';
        $request = $this->createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateRequest($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkOrganizationApplianceDnsLocalProfilesAssignmentsCreateRequest $bulk_organization_appliance_dns_local_profiles_assignments_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreateRequest($organization_id, $bulk_organization_appliance_dns_local_profiles_assignments_create_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'
            );
        }

        // verify the required parameter 'bulk_organization_appliance_dns_local_profiles_assignments_create_request' is set
        if ($bulk_organization_appliance_dns_local_profiles_assignments_create_request === null || (is_array($bulk_organization_appliance_dns_local_profiles_assignments_create_request) && count($bulk_organization_appliance_dns_local_profiles_assignments_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulk_organization_appliance_dns_local_profiles_assignments_create_request when calling createOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/split/profiles/assignments/bulkCreate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_organization_appliance_dns_local_profiles_assignments_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_organization_appliance_dns_local_profiles_assignments_create_request));
            } else {
                $httpBody = $bulk_organization_appliance_dns_local_profiles_assignments_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete
     *
     * Unassign the split DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'][0])
    {
        list($response) = $this->createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteWithHttpInfo
     *
     * Unassign the split DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'][0])
    {
        $request = $this->createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteRequest($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteAsync
     *
     * Unassign the split DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteAsync($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'][0])
    {
        return $this->createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteAsyncWithHttpInfo
     *
     * Unassign the split DNS profile to networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteAsyncWithHttpInfo($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'][0])
    {
        $returnType = '\Meraki\Model\CreateOrganizationApplianceDnsSplitProfilesAssignmentsBulkCreate200Response';
        $request = $this->createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteRequest($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfilesAssignmentsBulkDeleteRequest $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDeleteRequest($organization_id, $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request, string $contentType = self::contentTypes['createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'
            );
        }

        // verify the required parameter 'create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request' is set
        if ($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request === null || (is_array($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request) && count($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request when calling createOrganizationApplianceDnsSplitProfilesAssignmentsBulkDelete'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/split/profiles/assignments/bulkDelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request));
            } else {
                $httpBody = $create_organization_appliance_dns_local_profiles_assignments_bulk_delete_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkAppliancePrefixesDelegatedStatic
     *
     * Delete a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkAppliancePrefixesDelegatedStatic($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        $this->deleteNetworkAppliancePrefixesDelegatedStaticWithHttpInfo($network_id, $static_delegated_prefix_id, $contentType);
    }

    /**
     * Operation deleteNetworkAppliancePrefixesDelegatedStaticWithHttpInfo
     *
     * Delete a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkAppliancePrefixesDelegatedStaticWithHttpInfo($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        $request = $this->deleteNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $static_delegated_prefix_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkAppliancePrefixesDelegatedStaticAsync
     *
     * Delete a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkAppliancePrefixesDelegatedStaticAsync($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        return $this->deleteNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo($network_id, $static_delegated_prefix_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo
     *
     * Delete a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $static_delegated_prefix_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkAppliancePrefixesDelegatedStatic'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['deleteNetworkAppliancePrefixesDelegatedStatic'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkAppliancePrefixesDelegatedStatic'
            );
        }

        // verify the required parameter 'static_delegated_prefix_id' is set
        if ($static_delegated_prefix_id === null || (is_array($static_delegated_prefix_id) && count($static_delegated_prefix_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $static_delegated_prefix_id when calling deleteNetworkAppliancePrefixesDelegatedStatic'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($static_delegated_prefix_id !== null) {
            $resourcePath = str_replace(
                '{' . 'staticDelegatedPrefixId' . '}',
                ObjectSerializer::toPathValue($static_delegated_prefix_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkApplianceRfProfile
     *
     * Delete a RF Profile
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkApplianceRfProfile($network_id, $rf_profile_id, string $contentType = self::contentTypes['deleteNetworkApplianceRfProfile'][0])
    {
        $this->deleteNetworkApplianceRfProfileWithHttpInfo($network_id, $rf_profile_id, $contentType);
    }

    /**
     * Operation deleteNetworkApplianceRfProfileWithHttpInfo
     *
     * Delete a RF Profile
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkApplianceRfProfileWithHttpInfo($network_id, $rf_profile_id, string $contentType = self::contentTypes['deleteNetworkApplianceRfProfile'][0])
    {
        $request = $this->deleteNetworkApplianceRfProfileRequest($network_id, $rf_profile_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkApplianceRfProfileAsync
     *
     * Delete a RF Profile
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkApplianceRfProfileAsync($network_id, $rf_profile_id, string $contentType = self::contentTypes['deleteNetworkApplianceRfProfile'][0])
    {
        return $this->deleteNetworkApplianceRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkApplianceRfProfileAsyncWithHttpInfo
     *
     * Delete a RF Profile
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkApplianceRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id, string $contentType = self::contentTypes['deleteNetworkApplianceRfProfile'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkApplianceRfProfileRequest($network_id, $rf_profile_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkApplianceRfProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkApplianceRfProfileRequest($network_id, $rf_profile_id, string $contentType = self::contentTypes['deleteNetworkApplianceRfProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkApplianceRfProfile'
            );
        }

        // verify the required parameter 'rf_profile_id' is set
        if ($rf_profile_id === null || (is_array($rf_profile_id) && count($rf_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rf_profile_id when calling deleteNetworkApplianceRfProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/rfProfiles/{rfProfileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($rf_profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rfProfileId' . '}',
                ObjectSerializer::toPathValue($rf_profile_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkApplianceStaticRoute
     *
     * Delete a static route from an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkApplianceStaticRoute($network_id, $static_route_id, string $contentType = self::contentTypes['deleteNetworkApplianceStaticRoute'][0])
    {
        $this->deleteNetworkApplianceStaticRouteWithHttpInfo($network_id, $static_route_id, $contentType);
    }

    /**
     * Operation deleteNetworkApplianceStaticRouteWithHttpInfo
     *
     * Delete a static route from an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkApplianceStaticRouteWithHttpInfo($network_id, $static_route_id, string $contentType = self::contentTypes['deleteNetworkApplianceStaticRoute'][0])
    {
        $request = $this->deleteNetworkApplianceStaticRouteRequest($network_id, $static_route_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkApplianceStaticRouteAsync
     *
     * Delete a static route from an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkApplianceStaticRouteAsync($network_id, $static_route_id, string $contentType = self::contentTypes['deleteNetworkApplianceStaticRoute'][0])
    {
        return $this->deleteNetworkApplianceStaticRouteAsyncWithHttpInfo($network_id, $static_route_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkApplianceStaticRouteAsyncWithHttpInfo
     *
     * Delete a static route from an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkApplianceStaticRouteAsyncWithHttpInfo($network_id, $static_route_id, string $contentType = self::contentTypes['deleteNetworkApplianceStaticRoute'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkApplianceStaticRouteRequest($network_id, $static_route_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkApplianceStaticRoute'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkApplianceStaticRouteRequest($network_id, $static_route_id, string $contentType = self::contentTypes['deleteNetworkApplianceStaticRoute'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkApplianceStaticRoute'
            );
        }

        // verify the required parameter 'static_route_id' is set
        if ($static_route_id === null || (is_array($static_route_id) && count($static_route_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $static_route_id when calling deleteNetworkApplianceStaticRoute'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/staticRoutes/{staticRouteId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($static_route_id !== null) {
            $resourcePath = str_replace(
                '{' . 'staticRouteId' . '}',
                ObjectSerializer::toPathValue($static_route_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkApplianceTrafficShapingCustomPerformanceClass
     *
     * Delete a custom performance class from an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkApplianceTrafficShapingCustomPerformanceClass($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        $this->deleteNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo($network_id, $custom_performance_class_id, $contentType);
    }

    /**
     * Operation deleteNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo
     *
     * Delete a custom performance class from an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        $request = $this->deleteNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $custom_performance_class_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkApplianceTrafficShapingCustomPerformanceClassAsync
     *
     * Delete a custom performance class from an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkApplianceTrafficShapingCustomPerformanceClassAsync($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        return $this->deleteNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo($network_id, $custom_performance_class_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo
     *
     * Delete a custom performance class from an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $custom_performance_class_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkApplianceTrafficShapingCustomPerformanceClass'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['deleteNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkApplianceTrafficShapingCustomPerformanceClass'
            );
        }

        // verify the required parameter 'custom_performance_class_id' is set
        if ($custom_performance_class_id === null || (is_array($custom_performance_class_id) && count($custom_performance_class_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_performance_class_id when calling deleteNetworkApplianceTrafficShapingCustomPerformanceClass'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($custom_performance_class_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customPerformanceClassId' . '}',
                ObjectSerializer::toPathValue($custom_performance_class_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkApplianceVlan
     *
     * Delete a VLAN from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkApplianceVlan($network_id, $vlan_id, string $contentType = self::contentTypes['deleteNetworkApplianceVlan'][0])
    {
        $this->deleteNetworkApplianceVlanWithHttpInfo($network_id, $vlan_id, $contentType);
    }

    /**
     * Operation deleteNetworkApplianceVlanWithHttpInfo
     *
     * Delete a VLAN from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkApplianceVlanWithHttpInfo($network_id, $vlan_id, string $contentType = self::contentTypes['deleteNetworkApplianceVlan'][0])
    {
        $request = $this->deleteNetworkApplianceVlanRequest($network_id, $vlan_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkApplianceVlanAsync
     *
     * Delete a VLAN from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkApplianceVlanAsync($network_id, $vlan_id, string $contentType = self::contentTypes['deleteNetworkApplianceVlan'][0])
    {
        return $this->deleteNetworkApplianceVlanAsyncWithHttpInfo($network_id, $vlan_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkApplianceVlanAsyncWithHttpInfo
     *
     * Delete a VLAN from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkApplianceVlanAsyncWithHttpInfo($network_id, $vlan_id, string $contentType = self::contentTypes['deleteNetworkApplianceVlan'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkApplianceVlanRequest($network_id, $vlan_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkApplianceVlan'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkApplianceVlanRequest($network_id, $vlan_id, string $contentType = self::contentTypes['deleteNetworkApplianceVlan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkApplianceVlan'
            );
        }

        // verify the required parameter 'vlan_id' is set
        if ($vlan_id === null || (is_array($vlan_id) && count($vlan_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_id when calling deleteNetworkApplianceVlan'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/vlans/{vlanId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($vlan_id !== null) {
            $resourcePath = str_replace(
                '{' . 'vlanId' . '}',
                ObjectSerializer::toPathValue($vlan_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOrganizationApplianceDnsLocalProfile
     *
     * Deletes a local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOrganizationApplianceDnsLocalProfile($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'][0])
    {
        $this->deleteOrganizationApplianceDnsLocalProfileWithHttpInfo($organization_id, $profile_id, $contentType);
    }

    /**
     * Operation deleteOrganizationApplianceDnsLocalProfileWithHttpInfo
     *
     * Deletes a local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOrganizationApplianceDnsLocalProfileWithHttpInfo($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'][0])
    {
        $request = $this->deleteOrganizationApplianceDnsLocalProfileRequest($organization_id, $profile_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOrganizationApplianceDnsLocalProfileAsync
     *
     * Deletes a local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrganizationApplianceDnsLocalProfileAsync($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'][0])
    {
        return $this->deleteOrganizationApplianceDnsLocalProfileAsyncWithHttpInfo($organization_id, $profile_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOrganizationApplianceDnsLocalProfileAsyncWithHttpInfo
     *
     * Deletes a local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrganizationApplianceDnsLocalProfileAsyncWithHttpInfo($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'][0])
    {
        $returnType = '';
        $request = $this->deleteOrganizationApplianceDnsLocalProfileRequest($organization_id, $profile_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOrganizationApplianceDnsLocalProfile'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteOrganizationApplianceDnsLocalProfileRequest($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalProfile'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling deleteOrganizationApplianceDnsLocalProfile'
            );
        }

        // verify the required parameter 'profile_id' is set
        if ($profile_id === null || (is_array($profile_id) && count($profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $profile_id when calling deleteOrganizationApplianceDnsLocalProfile'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/profiles/{profileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'profileId' . '}',
                ObjectSerializer::toPathValue($profile_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOrganizationApplianceDnsLocalRecord
     *
     * Deletes a local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOrganizationApplianceDnsLocalRecord($organization_id, $record_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'][0])
    {
        $this->deleteOrganizationApplianceDnsLocalRecordWithHttpInfo($organization_id, $record_id, $contentType);
    }

    /**
     * Operation deleteOrganizationApplianceDnsLocalRecordWithHttpInfo
     *
     * Deletes a local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOrganizationApplianceDnsLocalRecordWithHttpInfo($organization_id, $record_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'][0])
    {
        $request = $this->deleteOrganizationApplianceDnsLocalRecordRequest($organization_id, $record_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOrganizationApplianceDnsLocalRecordAsync
     *
     * Deletes a local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrganizationApplianceDnsLocalRecordAsync($organization_id, $record_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'][0])
    {
        return $this->deleteOrganizationApplianceDnsLocalRecordAsyncWithHttpInfo($organization_id, $record_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOrganizationApplianceDnsLocalRecordAsyncWithHttpInfo
     *
     * Deletes a local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrganizationApplianceDnsLocalRecordAsyncWithHttpInfo($organization_id, $record_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'][0])
    {
        $returnType = '';
        $request = $this->deleteOrganizationApplianceDnsLocalRecordRequest($organization_id, $record_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOrganizationApplianceDnsLocalRecord'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteOrganizationApplianceDnsLocalRecordRequest($organization_id, $record_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsLocalRecord'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling deleteOrganizationApplianceDnsLocalRecord'
            );
        }

        // verify the required parameter 'record_id' is set
        if ($record_id === null || (is_array($record_id) && count($record_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $record_id when calling deleteOrganizationApplianceDnsLocalRecord'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/records/{recordId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($record_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordId' . '}',
                ObjectSerializer::toPathValue($record_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOrganizationApplianceDnsSplitProfile
     *
     * Deletes a split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOrganizationApplianceDnsSplitProfile($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'][0])
    {
        $this->deleteOrganizationApplianceDnsSplitProfileWithHttpInfo($organization_id, $profile_id, $contentType);
    }

    /**
     * Operation deleteOrganizationApplianceDnsSplitProfileWithHttpInfo
     *
     * Deletes a split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOrganizationApplianceDnsSplitProfileWithHttpInfo($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'][0])
    {
        $request = $this->deleteOrganizationApplianceDnsSplitProfileRequest($organization_id, $profile_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOrganizationApplianceDnsSplitProfileAsync
     *
     * Deletes a split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrganizationApplianceDnsSplitProfileAsync($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'][0])
    {
        return $this->deleteOrganizationApplianceDnsSplitProfileAsyncWithHttpInfo($organization_id, $profile_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOrganizationApplianceDnsSplitProfileAsyncWithHttpInfo
     *
     * Deletes a split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOrganizationApplianceDnsSplitProfileAsyncWithHttpInfo($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'][0])
    {
        $returnType = '';
        $request = $this->deleteOrganizationApplianceDnsSplitProfileRequest($organization_id, $profile_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOrganizationApplianceDnsSplitProfile'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteOrganizationApplianceDnsSplitProfileRequest($organization_id, $profile_id, string $contentType = self::contentTypes['deleteOrganizationApplianceDnsSplitProfile'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling deleteOrganizationApplianceDnsSplitProfile'
            );
        }

        // verify the required parameter 'profile_id' is set
        if ($profile_id === null || (is_array($profile_id) && count($profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $profile_id when calling deleteOrganizationApplianceDnsSplitProfile'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/split/profiles/{profileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'profileId' . '}',
                ObjectSerializer::toPathValue($profile_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceApplianceDhcpSubnets
     *
     * Return the DHCP subnet information for an appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceDhcpSubnets'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceApplianceDhcpSubnets200ResponseInner[]
     */
    public function getDeviceApplianceDhcpSubnets($serial, string $contentType = self::contentTypes['getDeviceApplianceDhcpSubnets'][0])
    {
        list($response) = $this->getDeviceApplianceDhcpSubnetsWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceApplianceDhcpSubnetsWithHttpInfo
     *
     * Return the DHCP subnet information for an appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceDhcpSubnets'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceApplianceDhcpSubnets200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceApplianceDhcpSubnetsWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceApplianceDhcpSubnets'][0])
    {
        $request = $this->getDeviceApplianceDhcpSubnetsRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceApplianceDhcpSubnets200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceApplianceDhcpSubnets200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceApplianceDhcpSubnets200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceApplianceDhcpSubnets200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceApplianceDhcpSubnets200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceApplianceDhcpSubnetsAsync
     *
     * Return the DHCP subnet information for an appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceDhcpSubnets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceDhcpSubnetsAsync($serial, string $contentType = self::contentTypes['getDeviceApplianceDhcpSubnets'][0])
    {
        return $this->getDeviceApplianceDhcpSubnetsAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceApplianceDhcpSubnetsAsyncWithHttpInfo
     *
     * Return the DHCP subnet information for an appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceDhcpSubnets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceDhcpSubnetsAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceApplianceDhcpSubnets'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceApplianceDhcpSubnets200ResponseInner[]';
        $request = $this->getDeviceApplianceDhcpSubnetsRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceApplianceDhcpSubnets'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceDhcpSubnets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceApplianceDhcpSubnetsRequest($serial, string $contentType = self::contentTypes['getDeviceApplianceDhcpSubnets'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceApplianceDhcpSubnets'
            );
        }


        $resourcePath = '/devices/{serial}/appliance/dhcp/subnets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceAppliancePerformance
     *
     * Return the performance score for a single MX
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 30 minutes and be less than or equal to 14 days. The default is 30 minutes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePerformance'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceAppliancePerformance200Response
     */
    public function getDeviceAppliancePerformance($serial, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceAppliancePerformance'][0])
    {
        list($response) = $this->getDeviceAppliancePerformanceWithHttpInfo($serial, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceAppliancePerformanceWithHttpInfo
     *
     * Return the performance score for a single MX
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 30 minutes and be less than or equal to 14 days. The default is 30 minutes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePerformance'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceAppliancePerformance200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceAppliancePerformanceWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceAppliancePerformance'][0])
    {
        $request = $this->getDeviceAppliancePerformanceRequest($serial, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceAppliancePerformance200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceAppliancePerformance200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceAppliancePerformance200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceAppliancePerformance200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceAppliancePerformance200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceAppliancePerformanceAsync
     *
     * Return the performance score for a single MX
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 30 minutes and be less than or equal to 14 days. The default is 30 minutes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePerformance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAppliancePerformanceAsync($serial, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceAppliancePerformance'][0])
    {
        return $this->getDeviceAppliancePerformanceAsyncWithHttpInfo($serial, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceAppliancePerformanceAsyncWithHttpInfo
     *
     * Return the performance score for a single MX
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 30 minutes and be less than or equal to 14 days. The default is 30 minutes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePerformance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAppliancePerformanceAsyncWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceAppliancePerformance'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceAppliancePerformance200Response';
        $request = $this->getDeviceAppliancePerformanceRequest($serial, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceAppliancePerformance'
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 30 minutes and be less than or equal to 14 days. The default is 30 minutes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePerformance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceAppliancePerformanceRequest($serial, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceAppliancePerformance'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceAppliancePerformance'
            );
        }



        if ($timespan !== null && $timespan > 1209600) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ApplianceApi.getDeviceAppliancePerformance, must be smaller than or equal to 1209600.');
        }
        if ($timespan !== null && $timespan < 1800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ApplianceApi.getDeviceAppliancePerformance, must be bigger than or equal to 1800.');
        }
        

        $resourcePath = '/devices/{serial}/appliance/performance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceAppliancePrefixesDelegated
     *
     * Return current delegated IPv6 prefixes on an appliance.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegated'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getDeviceAppliancePrefixesDelegated($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegated'][0])
    {
        list($response) = $this->getDeviceAppliancePrefixesDelegatedWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceAppliancePrefixesDelegatedWithHttpInfo
     *
     * Return current delegated IPv6 prefixes on an appliance.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegated'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceAppliancePrefixesDelegatedWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegated'][0])
    {
        $request = $this->getDeviceAppliancePrefixesDelegatedRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceAppliancePrefixesDelegatedAsync
     *
     * Return current delegated IPv6 prefixes on an appliance.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAppliancePrefixesDelegatedAsync($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegated'][0])
    {
        return $this->getDeviceAppliancePrefixesDelegatedAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceAppliancePrefixesDelegatedAsyncWithHttpInfo
     *
     * Return current delegated IPv6 prefixes on an appliance.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAppliancePrefixesDelegatedAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegated'][0])
    {
        $returnType = 'object[]';
        $request = $this->getDeviceAppliancePrefixesDelegatedRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceAppliancePrefixesDelegated'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceAppliancePrefixesDelegatedRequest($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegated'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceAppliancePrefixesDelegated'
            );
        }


        $resourcePath = '/devices/{serial}/appliance/prefixes/delegated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceAppliancePrefixesDelegatedVlanAssignments
     *
     * Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getDeviceAppliancePrefixesDelegatedVlanAssignments($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'][0])
    {
        list($response) = $this->getDeviceAppliancePrefixesDelegatedVlanAssignmentsWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceAppliancePrefixesDelegatedVlanAssignmentsWithHttpInfo
     *
     * Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceAppliancePrefixesDelegatedVlanAssignmentsWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'][0])
    {
        $request = $this->getDeviceAppliancePrefixesDelegatedVlanAssignmentsRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceAppliancePrefixesDelegatedVlanAssignmentsAsync
     *
     * Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAppliancePrefixesDelegatedVlanAssignmentsAsync($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'][0])
    {
        return $this->getDeviceAppliancePrefixesDelegatedVlanAssignmentsAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceAppliancePrefixesDelegatedVlanAssignmentsAsyncWithHttpInfo
     *
     * Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAppliancePrefixesDelegatedVlanAssignmentsAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'][0])
    {
        $returnType = 'object[]';
        $request = $this->getDeviceAppliancePrefixesDelegatedVlanAssignmentsRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceAppliancePrefixesDelegatedVlanAssignments'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceAppliancePrefixesDelegatedVlanAssignmentsRequest($serial, string $contentType = self::contentTypes['getDeviceAppliancePrefixesDelegatedVlanAssignments'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceAppliancePrefixesDelegatedVlanAssignments'
            );
        }


        $resourcePath = '/devices/{serial}/appliance/prefixes/delegated/vlanAssignments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceApplianceRadioSettings
     *
     * Return the radio settings of an appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceApplianceRadioSettings200Response
     */
    public function getDeviceApplianceRadioSettings($serial, string $contentType = self::contentTypes['getDeviceApplianceRadioSettings'][0])
    {
        list($response) = $this->getDeviceApplianceRadioSettingsWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceApplianceRadioSettingsWithHttpInfo
     *
     * Return the radio settings of an appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceApplianceRadioSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceApplianceRadioSettingsWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceApplianceRadioSettings'][0])
    {
        $request = $this->getDeviceApplianceRadioSettingsRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceApplianceRadioSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceApplianceRadioSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceApplianceRadioSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceApplianceRadioSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceApplianceRadioSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceApplianceRadioSettingsAsync
     *
     * Return the radio settings of an appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceRadioSettingsAsync($serial, string $contentType = self::contentTypes['getDeviceApplianceRadioSettings'][0])
    {
        return $this->getDeviceApplianceRadioSettingsAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceApplianceRadioSettingsAsyncWithHttpInfo
     *
     * Return the radio settings of an appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceRadioSettingsAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceApplianceRadioSettings'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceApplianceRadioSettings200Response';
        $request = $this->getDeviceApplianceRadioSettingsRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceApplianceRadioSettings'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceApplianceRadioSettingsRequest($serial, string $contentType = self::contentTypes['getDeviceApplianceRadioSettings'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceApplianceRadioSettings'
            );
        }


        $resourcePath = '/devices/{serial}/appliance/radio/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceApplianceUplinksSettings
     *
     * Return the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceApplianceUplinksSettings200Response
     */
    public function getDeviceApplianceUplinksSettings($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {
        list($response) = $this->getDeviceApplianceUplinksSettingsWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceApplianceUplinksSettingsWithHttpInfo
     *
     * Return the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceApplianceUplinksSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceApplianceUplinksSettingsWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {
        $request = $this->getDeviceApplianceUplinksSettingsRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceApplianceUplinksSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceApplianceUplinksSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceApplianceUplinksSettingsAsync
     *
     * Return the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceUplinksSettingsAsync($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {
        return $this->getDeviceApplianceUplinksSettingsAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceApplianceUplinksSettingsAsyncWithHttpInfo
     *
     * Return the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceUplinksSettingsAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response';
        $request = $this->getDeviceApplianceUplinksSettingsRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceApplianceUplinksSettings'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceApplianceUplinksSettingsRequest($serial, string $contentType = self::contentTypes['getDeviceApplianceUplinksSettings'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceApplianceUplinksSettings'
            );
        }


        $resourcePath = '/devices/{serial}/appliance/uplinks/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceClientSecurityEvents
     *
     * List the security events for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>[]
     */
    public function getNetworkApplianceClientSecurityEvents($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {
        list($response) = $this->getNetworkApplianceClientSecurityEventsWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceClientSecurityEventsWithHttpInfo
     *
     * List the security events for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceClientSecurityEventsWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {
        $request = $this->getNetworkApplianceClientSecurityEventsRequest($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'array<string,mixed>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceClientSecurityEventsAsync
     *
     * List the security events for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceClientSecurityEventsAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {
        return $this->getNetworkApplianceClientSecurityEventsAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceClientSecurityEventsAsyncWithHttpInfo
     *
     * List the security events for a client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceClientSecurityEventsAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {
        $returnType = 'array<string,mixed>[]';
        $request = $this->getNetworkApplianceClientSecurityEventsRequest($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceClientSecurityEvents'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceClientSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceClientSecurityEventsRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceClientSecurityEvents'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceClientSecurityEvents'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkApplianceClientSecurityEvents'
            );
        }



        if ($timespan !== null && $timespan > 68342400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ApplianceApi.getNetworkApplianceClientSecurityEvents, must be smaller than or equal to 68342400.');
        }
        





        $resourcePath = '/networks/{networkId}/appliance/clients/{clientId}/security/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceConnectivityMonitoringDestinations
     *
     * Return the connectivity testing destinations for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response
     */
    public function getNetworkApplianceConnectivityMonitoringDestinations($network_id, string $contentType = self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'][0])
    {
        list($response) = $this->getNetworkApplianceConnectivityMonitoringDestinationsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceConnectivityMonitoringDestinationsWithHttpInfo
     *
     * Return the connectivity testing destinations for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceConnectivityMonitoringDestinationsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'][0])
    {
        $request = $this->getNetworkApplianceConnectivityMonitoringDestinationsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceConnectivityMonitoringDestinationsAsync
     *
     * Return the connectivity testing destinations for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceConnectivityMonitoringDestinationsAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'][0])
    {
        return $this->getNetworkApplianceConnectivityMonitoringDestinationsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceConnectivityMonitoringDestinationsAsyncWithHttpInfo
     *
     * Return the connectivity testing destinations for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceConnectivityMonitoringDestinationsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response';
        $request = $this->getNetworkApplianceConnectivityMonitoringDestinationsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceConnectivityMonitoringDestinations'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceConnectivityMonitoringDestinationsRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceConnectivityMonitoringDestinations'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceConnectivityMonitoringDestinations'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/connectivityMonitoringDestinations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceContentFiltering
     *
     * Return the content filtering settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceContentFiltering($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFiltering'][0])
    {
        list($response) = $this->getNetworkApplianceContentFilteringWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceContentFilteringWithHttpInfo
     *
     * Return the content filtering settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceContentFilteringWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFiltering'][0])
    {
        $request = $this->getNetworkApplianceContentFilteringRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceContentFilteringAsync
     *
     * Return the content filtering settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceContentFilteringAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFiltering'][0])
    {
        return $this->getNetworkApplianceContentFilteringAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceContentFilteringAsyncWithHttpInfo
     *
     * Return the content filtering settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceContentFilteringAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFiltering'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceContentFilteringRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceContentFiltering'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceContentFilteringRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFiltering'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceContentFiltering'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/contentFiltering';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceContentFilteringCategories
     *
     * List all available content filtering categories for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFilteringCategories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceContentFilteringCategories($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFilteringCategories'][0])
    {
        list($response) = $this->getNetworkApplianceContentFilteringCategoriesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceContentFilteringCategoriesWithHttpInfo
     *
     * List all available content filtering categories for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFilteringCategories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceContentFilteringCategoriesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFilteringCategories'][0])
    {
        $request = $this->getNetworkApplianceContentFilteringCategoriesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceContentFilteringCategoriesAsync
     *
     * List all available content filtering categories for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFilteringCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceContentFilteringCategoriesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFilteringCategories'][0])
    {
        return $this->getNetworkApplianceContentFilteringCategoriesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceContentFilteringCategoriesAsyncWithHttpInfo
     *
     * List all available content filtering categories for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFilteringCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceContentFilteringCategoriesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFilteringCategories'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceContentFilteringCategoriesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceContentFilteringCategories'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceContentFilteringCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceContentFilteringCategoriesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceContentFilteringCategories'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceContentFilteringCategories'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/contentFiltering/categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallCellularFirewallRules
     *
     * Return the cellular firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceFirewallCellularFirewallRules($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallCellularFirewallRulesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallCellularFirewallRulesWithHttpInfo
     *
     * Return the cellular firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallCellularFirewallRulesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'][0])
    {
        $request = $this->getNetworkApplianceFirewallCellularFirewallRulesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallCellularFirewallRulesAsync
     *
     * Return the cellular firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallCellularFirewallRulesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'][0])
    {
        return $this->getNetworkApplianceFirewallCellularFirewallRulesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallCellularFirewallRulesAsyncWithHttpInfo
     *
     * Return the cellular firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallCellularFirewallRulesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceFirewallCellularFirewallRulesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallCellularFirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallCellularFirewallRulesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallCellularFirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallCellularFirewallRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/cellularFirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallFirewalledService
     *
     * Return the accessibility settings of the given service (&#39;ICMP&#39;, &#39;web&#39;, or &#39;SNMP&#39;)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner
     */
    public function getNetworkApplianceFirewallFirewalledService($network_id, $service, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledService'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallFirewalledServiceWithHttpInfo($network_id, $service, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallFirewalledServiceWithHttpInfo
     *
     * Return the accessibility settings of the given service (&#39;ICMP&#39;, &#39;web&#39;, or &#39;SNMP&#39;)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallFirewalledServiceWithHttpInfo($network_id, $service, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledService'][0])
    {
        $request = $this->getNetworkApplianceFirewallFirewalledServiceRequest($network_id, $service, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallFirewalledServiceAsync
     *
     * Return the accessibility settings of the given service (&#39;ICMP&#39;, &#39;web&#39;, or &#39;SNMP&#39;)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallFirewalledServiceAsync($network_id, $service, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledService'][0])
    {
        return $this->getNetworkApplianceFirewallFirewalledServiceAsyncWithHttpInfo($network_id, $service, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallFirewalledServiceAsyncWithHttpInfo
     *
     * Return the accessibility settings of the given service (&#39;ICMP&#39;, &#39;web&#39;, or &#39;SNMP&#39;)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallFirewalledServiceAsyncWithHttpInfo($network_id, $service, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledService'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner';
        $request = $this->getNetworkApplianceFirewallFirewalledServiceRequest($network_id, $service, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallFirewalledService'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallFirewalledServiceRequest($network_id, $service, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledService'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallFirewalledService'
            );
        }

        // verify the required parameter 'service' is set
        if ($service === null || (is_array($service) && count($service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service when calling getNetworkApplianceFirewallFirewalledService'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/firewalledServices/{service}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($service !== null) {
            $resourcePath = str_replace(
                '{' . 'service' . '}',
                ObjectSerializer::toPathValue($service),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallFirewalledServices
     *
     * List the appliance services and their accessibility rules
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledServices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner[]
     */
    public function getNetworkApplianceFirewallFirewalledServices($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledServices'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallFirewalledServicesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallFirewalledServicesWithHttpInfo
     *
     * List the appliance services and their accessibility rules
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledServices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallFirewalledServicesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledServices'][0])
    {
        $request = $this->getNetworkApplianceFirewallFirewalledServicesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallFirewalledServicesAsync
     *
     * List the appliance services and their accessibility rules
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledServices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallFirewalledServicesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledServices'][0])
    {
        return $this->getNetworkApplianceFirewallFirewalledServicesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallFirewalledServicesAsyncWithHttpInfo
     *
     * List the appliance services and their accessibility rules
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledServices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallFirewalledServicesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledServices'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner[]';
        $request = $this->getNetworkApplianceFirewallFirewalledServicesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallFirewalledServices'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallFirewalledServices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallFirewalledServicesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallFirewalledServices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallFirewalledServices'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/firewalledServices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallInboundCellularFirewallRules
     *
     * Return the inbound cellular firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response
     */
    public function getNetworkApplianceFirewallInboundCellularFirewallRules($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallInboundCellularFirewallRulesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallInboundCellularFirewallRulesWithHttpInfo
     *
     * Return the inbound cellular firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallInboundCellularFirewallRulesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {
        $request = $this->getNetworkApplianceFirewallInboundCellularFirewallRulesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallInboundCellularFirewallRulesAsync
     *
     * Return the inbound cellular firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallInboundCellularFirewallRulesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {
        return $this->getNetworkApplianceFirewallInboundCellularFirewallRulesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallInboundCellularFirewallRulesAsyncWithHttpInfo
     *
     * Return the inbound cellular firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallInboundCellularFirewallRulesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response';
        $request = $this->getNetworkApplianceFirewallInboundCellularFirewallRulesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallInboundCellularFirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallInboundCellularFirewallRulesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallInboundCellularFirewallRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/inboundCellularFirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallInboundFirewallRules
     *
     * Return the inbound firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response
     */
    public function getNetworkApplianceFirewallInboundFirewallRules($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallInboundFirewallRulesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallInboundFirewallRulesWithHttpInfo
     *
     * Return the inbound firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallInboundFirewallRulesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'][0])
    {
        $request = $this->getNetworkApplianceFirewallInboundFirewallRulesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallInboundFirewallRulesAsync
     *
     * Return the inbound firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallInboundFirewallRulesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'][0])
    {
        return $this->getNetworkApplianceFirewallInboundFirewallRulesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallInboundFirewallRulesAsyncWithHttpInfo
     *
     * Return the inbound firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallInboundFirewallRulesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response';
        $request = $this->getNetworkApplianceFirewallInboundFirewallRulesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallInboundFirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallInboundFirewallRulesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallInboundFirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallInboundFirewallRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/inboundFirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallL3FirewallRules
     *
     * Return the L3 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceFirewallL3FirewallRules($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallL3FirewallRulesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallL3FirewallRulesWithHttpInfo
     *
     * Return the L3 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallL3FirewallRulesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'][0])
    {
        $request = $this->getNetworkApplianceFirewallL3FirewallRulesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallL3FirewallRulesAsync
     *
     * Return the L3 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallL3FirewallRulesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'][0])
    {
        return $this->getNetworkApplianceFirewallL3FirewallRulesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallL3FirewallRulesAsyncWithHttpInfo
     *
     * Return the L3 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallL3FirewallRulesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceFirewallL3FirewallRulesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallL3FirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallL3FirewallRulesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL3FirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallL3FirewallRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/l3FirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallL7FirewallRules
     *
     * List the MX L7 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceFirewallL7FirewallRules($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallL7FirewallRulesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallL7FirewallRulesWithHttpInfo
     *
     * List the MX L7 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallL7FirewallRulesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'][0])
    {
        $request = $this->getNetworkApplianceFirewallL7FirewallRulesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallL7FirewallRulesAsync
     *
     * List the MX L7 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallL7FirewallRulesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'][0])
    {
        return $this->getNetworkApplianceFirewallL7FirewallRulesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallL7FirewallRulesAsyncWithHttpInfo
     *
     * List the MX L7 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallL7FirewallRulesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceFirewallL7FirewallRulesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallL7FirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallL7FirewallRulesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallL7FirewallRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/l7FirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallL7FirewallRulesApplicationCategories
     *
     * Return the L7 firewall application categories and their associated applications for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories200Response
     */
    public function getNetworkApplianceFirewallL7FirewallRulesApplicationCategories($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesWithHttpInfo
     *
     * Return the L7 firewall application categories and their associated applications for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'][0])
    {
        $request = $this->getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesAsync
     *
     * Return the L7 firewall application categories and their associated applications for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'][0])
    {
        return $this->getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesAsyncWithHttpInfo
     *
     * Return the L7 firewall application categories and their associated applications for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallL7FirewallRulesApplicationCategories200Response';
        $request = $this->getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallL7FirewallRulesApplicationCategories'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/l7FirewallRules/applicationCategories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallOneToManyNatRules
     *
     * Return the 1:Many NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceFirewallOneToManyNatRules($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallOneToManyNatRulesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallOneToManyNatRulesWithHttpInfo
     *
     * Return the 1:Many NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallOneToManyNatRulesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'][0])
    {
        $request = $this->getNetworkApplianceFirewallOneToManyNatRulesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallOneToManyNatRulesAsync
     *
     * Return the 1:Many NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallOneToManyNatRulesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'][0])
    {
        return $this->getNetworkApplianceFirewallOneToManyNatRulesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallOneToManyNatRulesAsyncWithHttpInfo
     *
     * Return the 1:Many NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallOneToManyNatRulesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceFirewallOneToManyNatRulesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallOneToManyNatRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallOneToManyNatRulesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToManyNatRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallOneToManyNatRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/oneToManyNatRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallOneToOneNatRules
     *
     * Return the 1:1 NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceFirewallOneToOneNatRules($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallOneToOneNatRulesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallOneToOneNatRulesWithHttpInfo
     *
     * Return the 1:1 NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallOneToOneNatRulesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'][0])
    {
        $request = $this->getNetworkApplianceFirewallOneToOneNatRulesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallOneToOneNatRulesAsync
     *
     * Return the 1:1 NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallOneToOneNatRulesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'][0])
    {
        return $this->getNetworkApplianceFirewallOneToOneNatRulesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallOneToOneNatRulesAsyncWithHttpInfo
     *
     * Return the 1:1 NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallOneToOneNatRulesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceFirewallOneToOneNatRulesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallOneToOneNatRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallOneToOneNatRulesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallOneToOneNatRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallOneToOneNatRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/oneToOneNatRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallPortForwardingRules
     *
     * Return the port forwarding rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response
     */
    public function getNetworkApplianceFirewallPortForwardingRules($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallPortForwardingRulesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallPortForwardingRulesWithHttpInfo
     *
     * Return the port forwarding rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallPortForwardingRulesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'][0])
    {
        $request = $this->getNetworkApplianceFirewallPortForwardingRulesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallPortForwardingRulesAsync
     *
     * Return the port forwarding rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallPortForwardingRulesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'][0])
    {
        return $this->getNetworkApplianceFirewallPortForwardingRulesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallPortForwardingRulesAsyncWithHttpInfo
     *
     * Return the port forwarding rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallPortForwardingRulesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response';
        $request = $this->getNetworkApplianceFirewallPortForwardingRulesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallPortForwardingRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallPortForwardingRulesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallPortForwardingRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallPortForwardingRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/portForwardingRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceFirewallSettings
     *
     * Return the firewall settings for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceFirewallSettings($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallSettings'][0])
    {
        list($response) = $this->getNetworkApplianceFirewallSettingsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceFirewallSettingsWithHttpInfo
     *
     * Return the firewall settings for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceFirewallSettingsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallSettings'][0])
    {
        $request = $this->getNetworkApplianceFirewallSettingsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceFirewallSettingsAsync
     *
     * Return the firewall settings for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallSettingsAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallSettings'][0])
    {
        return $this->getNetworkApplianceFirewallSettingsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceFirewallSettingsAsyncWithHttpInfo
     *
     * Return the firewall settings for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceFirewallSettingsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallSettings'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceFirewallSettingsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceFirewallSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceFirewallSettingsRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceFirewallSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceFirewallSettings'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkAppliancePort
     *
     * Return per-port VLAN settings for a single MX port.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAppliancePorts200ResponseInner
     */
    public function getNetworkAppliancePort($network_id, $port_id, string $contentType = self::contentTypes['getNetworkAppliancePort'][0])
    {
        list($response) = $this->getNetworkAppliancePortWithHttpInfo($network_id, $port_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkAppliancePortWithHttpInfo
     *
     * Return per-port VLAN settings for a single MX port.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAppliancePorts200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkAppliancePortWithHttpInfo($network_id, $port_id, string $contentType = self::contentTypes['getNetworkAppliancePort'][0])
    {
        $request = $this->getNetworkAppliancePortRequest($network_id, $port_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAppliancePorts200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAppliancePorts200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkAppliancePortAsync
     *
     * Return per-port VLAN settings for a single MX port.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAppliancePortAsync($network_id, $port_id, string $contentType = self::contentTypes['getNetworkAppliancePort'][0])
    {
        return $this->getNetworkAppliancePortAsyncWithHttpInfo($network_id, $port_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkAppliancePortAsyncWithHttpInfo
     *
     * Return per-port VLAN settings for a single MX port.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAppliancePortAsyncWithHttpInfo($network_id, $port_id, string $contentType = self::contentTypes['getNetworkAppliancePort'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner';
        $request = $this->getNetworkAppliancePortRequest($network_id, $port_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkAppliancePort'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkAppliancePortRequest($network_id, $port_id, string $contentType = self::contentTypes['getNetworkAppliancePort'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkAppliancePort'
            );
        }

        // verify the required parameter 'port_id' is set
        if ($port_id === null || (is_array($port_id) && count($port_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $port_id when calling getNetworkAppliancePort'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/ports/{portId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($port_id !== null) {
            $resourcePath = str_replace(
                '{' . 'portId' . '}',
                ObjectSerializer::toPathValue($port_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkAppliancePorts
     *
     * List per-port VLAN settings for all ports of a MX.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePorts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAppliancePorts200ResponseInner[]
     */
    public function getNetworkAppliancePorts($network_id, string $contentType = self::contentTypes['getNetworkAppliancePorts'][0])
    {
        list($response) = $this->getNetworkAppliancePortsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkAppliancePortsWithHttpInfo
     *
     * List per-port VLAN settings for all ports of a MX.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePorts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAppliancePorts200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkAppliancePortsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkAppliancePorts'][0])
    {
        $request = $this->getNetworkAppliancePortsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAppliancePorts200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAppliancePorts200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkAppliancePortsAsync
     *
     * List per-port VLAN settings for all ports of a MX.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePorts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAppliancePortsAsync($network_id, string $contentType = self::contentTypes['getNetworkAppliancePorts'][0])
    {
        return $this->getNetworkAppliancePortsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkAppliancePortsAsyncWithHttpInfo
     *
     * List per-port VLAN settings for all ports of a MX.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePorts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAppliancePortsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkAppliancePorts'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner[]';
        $request = $this->getNetworkAppliancePortsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkAppliancePorts'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePorts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkAppliancePortsRequest($network_id, string $contentType = self::contentTypes['getNetworkAppliancePorts'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkAppliancePorts'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/ports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkAppliancePrefixesDelegatedStatic
     *
     * Return a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner
     */
    public function getNetworkAppliancePrefixesDelegatedStatic($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        list($response) = $this->getNetworkAppliancePrefixesDelegatedStaticWithHttpInfo($network_id, $static_delegated_prefix_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkAppliancePrefixesDelegatedStaticWithHttpInfo
     *
     * Return a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkAppliancePrefixesDelegatedStaticWithHttpInfo($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        $request = $this->getNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $static_delegated_prefix_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkAppliancePrefixesDelegatedStaticAsync
     *
     * Return a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAppliancePrefixesDelegatedStaticAsync($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        return $this->getNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo($network_id, $static_delegated_prefix_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo
     *
     * Return a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner';
        $request = $this->getNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $static_delegated_prefix_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkAppliancePrefixesDelegatedStatic'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $static_delegated_prefix_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatic'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkAppliancePrefixesDelegatedStatic'
            );
        }

        // verify the required parameter 'static_delegated_prefix_id' is set
        if ($static_delegated_prefix_id === null || (is_array($static_delegated_prefix_id) && count($static_delegated_prefix_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $static_delegated_prefix_id when calling getNetworkAppliancePrefixesDelegatedStatic'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($static_delegated_prefix_id !== null) {
            $resourcePath = str_replace(
                '{' . 'staticDelegatedPrefixId' . '}',
                ObjectSerializer::toPathValue($static_delegated_prefix_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkAppliancePrefixesDelegatedStatics
     *
     * List static delegated prefixes for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner[]
     */
    public function getNetworkAppliancePrefixesDelegatedStatics($network_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'][0])
    {
        list($response) = $this->getNetworkAppliancePrefixesDelegatedStaticsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkAppliancePrefixesDelegatedStaticsWithHttpInfo
     *
     * List static delegated prefixes for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkAppliancePrefixesDelegatedStaticsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'][0])
    {
        $request = $this->getNetworkAppliancePrefixesDelegatedStaticsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkAppliancePrefixesDelegatedStaticsAsync
     *
     * List static delegated prefixes for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAppliancePrefixesDelegatedStaticsAsync($network_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'][0])
    {
        return $this->getNetworkAppliancePrefixesDelegatedStaticsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkAppliancePrefixesDelegatedStaticsAsyncWithHttpInfo
     *
     * List static delegated prefixes for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAppliancePrefixesDelegatedStaticsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAppliancePrefixesDelegatedStatics200ResponseInner[]';
        $request = $this->getNetworkAppliancePrefixesDelegatedStaticsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkAppliancePrefixesDelegatedStatics'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkAppliancePrefixesDelegatedStaticsRequest($network_id, string $contentType = self::contentTypes['getNetworkAppliancePrefixesDelegatedStatics'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkAppliancePrefixesDelegatedStatics'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/prefixes/delegated/statics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceRfProfile
     *
     * Return a RF profile
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner
     */
    public function getNetworkApplianceRfProfile($network_id, $rf_profile_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfile'][0])
    {
        list($response) = $this->getNetworkApplianceRfProfileWithHttpInfo($network_id, $rf_profile_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceRfProfileWithHttpInfo
     *
     * Return a RF profile
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceRfProfileWithHttpInfo($network_id, $rf_profile_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfile'][0])
    {
        $request = $this->getNetworkApplianceRfProfileRequest($network_id, $rf_profile_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceRfProfileAsync
     *
     * Return a RF profile
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceRfProfileAsync($network_id, $rf_profile_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfile'][0])
    {
        return $this->getNetworkApplianceRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceRfProfileAsyncWithHttpInfo
     *
     * Return a RF profile
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner';
        $request = $this->getNetworkApplianceRfProfileRequest($network_id, $rf_profile_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceRfProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceRfProfileRequest($network_id, $rf_profile_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceRfProfile'
            );
        }

        // verify the required parameter 'rf_profile_id' is set
        if ($rf_profile_id === null || (is_array($rf_profile_id) && count($rf_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rf_profile_id when calling getNetworkApplianceRfProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/rfProfiles/{rfProfileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($rf_profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rfProfileId' . '}',
                ObjectSerializer::toPathValue($rf_profile_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceRfProfiles
     *
     * List the RF profiles for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceRfProfiles200Response
     */
    public function getNetworkApplianceRfProfiles($network_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfiles'][0])
    {
        list($response) = $this->getNetworkApplianceRfProfilesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceRfProfilesWithHttpInfo
     *
     * List the RF profiles for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceRfProfiles200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceRfProfilesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfiles'][0])
    {
        $request = $this->getNetworkApplianceRfProfilesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceRfProfiles200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceRfProfiles200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceRfProfiles200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceRfProfiles200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceRfProfiles200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceRfProfilesAsync
     *
     * List the RF profiles for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceRfProfilesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfiles'][0])
    {
        return $this->getNetworkApplianceRfProfilesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceRfProfilesAsyncWithHttpInfo
     *
     * List the RF profiles for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceRfProfilesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfiles'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceRfProfiles200Response';
        $request = $this->getNetworkApplianceRfProfilesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceRfProfiles'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceRfProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceRfProfilesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceRfProfiles'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceRfProfiles'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/rfProfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceSecurityEvents
     *
     * List the security events for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>[]
     */
    public function getNetworkApplianceSecurityEvents($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceSecurityEvents'][0])
    {
        list($response) = $this->getNetworkApplianceSecurityEventsWithHttpInfo($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceSecurityEventsWithHttpInfo
     *
     * List the security events for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceSecurityEventsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceSecurityEvents'][0])
    {
        $request = $this->getNetworkApplianceSecurityEventsRequest($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'array<string,mixed>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceSecurityEventsAsync
     *
     * List the security events for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSecurityEventsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceSecurityEvents'][0])
    {
        return $this->getNetworkApplianceSecurityEventsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceSecurityEventsAsyncWithHttpInfo
     *
     * List the security events for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSecurityEventsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceSecurityEvents'][0])
    {
        $returnType = 'array<string,mixed>[]';
        $request = $this->getNetworkApplianceSecurityEventsRequest($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceSecurityEvents'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceSecurityEventsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getNetworkApplianceSecurityEvents'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceSecurityEvents'
            );
        }



        if ($timespan !== null && $timespan > 31536000) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ApplianceApi.getNetworkApplianceSecurityEvents, must be smaller than or equal to 31536000.');
        }
        





        $resourcePath = '/networks/{networkId}/appliance/security/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceSecurityIntrusion
     *
     * Returns all supported intrusion settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response
     */
    public function getNetworkApplianceSecurityIntrusion($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityIntrusion'][0])
    {
        list($response) = $this->getNetworkApplianceSecurityIntrusionWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceSecurityIntrusionWithHttpInfo
     *
     * Returns all supported intrusion settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceSecurityIntrusionWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityIntrusion'][0])
    {
        $request = $this->getNetworkApplianceSecurityIntrusionRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceSecurityIntrusionAsync
     *
     * Returns all supported intrusion settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSecurityIntrusionAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityIntrusion'][0])
    {
        return $this->getNetworkApplianceSecurityIntrusionAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceSecurityIntrusionAsyncWithHttpInfo
     *
     * Returns all supported intrusion settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSecurityIntrusionAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityIntrusion'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response';
        $request = $this->getNetworkApplianceSecurityIntrusionRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceSecurityIntrusion'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceSecurityIntrusionRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityIntrusion'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceSecurityIntrusion'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/security/intrusion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceSecurityMalware
     *
     * Returns all supported malware settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSecurityMalware200Response
     */
    public function getNetworkApplianceSecurityMalware($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityMalware'][0])
    {
        list($response) = $this->getNetworkApplianceSecurityMalwareWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceSecurityMalwareWithHttpInfo
     *
     * Returns all supported malware settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSecurityMalware200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceSecurityMalwareWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityMalware'][0])
    {
        $request = $this->getNetworkApplianceSecurityMalwareRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSecurityMalware200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSecurityMalware200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSecurityMalware200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSecurityMalware200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSecurityMalware200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceSecurityMalwareAsync
     *
     * Returns all supported malware settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSecurityMalwareAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityMalware'][0])
    {
        return $this->getNetworkApplianceSecurityMalwareAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceSecurityMalwareAsyncWithHttpInfo
     *
     * Returns all supported malware settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSecurityMalwareAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityMalware'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSecurityMalware200Response';
        $request = $this->getNetworkApplianceSecurityMalwareRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceSecurityMalware'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceSecurityMalwareRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceSecurityMalware'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceSecurityMalware'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/security/malware';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceSettings
     *
     * Return the appliance settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSettings200Response
     */
    public function getNetworkApplianceSettings($network_id, string $contentType = self::contentTypes['getNetworkApplianceSettings'][0])
    {
        list($response) = $this->getNetworkApplianceSettingsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceSettingsWithHttpInfo
     *
     * Return the appliance settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceSettingsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSettings'][0])
    {
        $request = $this->getNetworkApplianceSettingsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceSettingsAsync
     *
     * Return the appliance settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSettingsAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceSettings'][0])
    {
        return $this->getNetworkApplianceSettingsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceSettingsAsyncWithHttpInfo
     *
     * Return the appliance settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSettingsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSettings200Response';
        $request = $this->getNetworkApplianceSettingsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceSettingsRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceSettings'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceSingleLan
     *
     * Return single LAN configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSingleLan200Response
     */
    public function getNetworkApplianceSingleLan($network_id, string $contentType = self::contentTypes['getNetworkApplianceSingleLan'][0])
    {
        list($response) = $this->getNetworkApplianceSingleLanWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceSingleLanWithHttpInfo
     *
     * Return single LAN configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSingleLan200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceSingleLanWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSingleLan'][0])
    {
        $request = $this->getNetworkApplianceSingleLanRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSingleLan200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSingleLan200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSingleLan200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSingleLan200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSingleLan200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceSingleLanAsync
     *
     * Return single LAN configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSingleLanAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceSingleLan'][0])
    {
        return $this->getNetworkApplianceSingleLanAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceSingleLanAsyncWithHttpInfo
     *
     * Return single LAN configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSingleLanAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSingleLan'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSingleLan200Response';
        $request = $this->getNetworkApplianceSingleLanRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceSingleLan'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceSingleLanRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceSingleLan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceSingleLan'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/singleLan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceSsid
     *
     * Return a single MX SSID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSsids200ResponseInner
     */
    public function getNetworkApplianceSsid($network_id, $number, string $contentType = self::contentTypes['getNetworkApplianceSsid'][0])
    {
        list($response) = $this->getNetworkApplianceSsidWithHttpInfo($network_id, $number, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceSsidWithHttpInfo
     *
     * Return a single MX SSID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSsids200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceSsidWithHttpInfo($network_id, $number, string $contentType = self::contentTypes['getNetworkApplianceSsid'][0])
    {
        $request = $this->getNetworkApplianceSsidRequest($network_id, $number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSsids200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSsids200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceSsidAsync
     *
     * Return a single MX SSID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSsidAsync($network_id, $number, string $contentType = self::contentTypes['getNetworkApplianceSsid'][0])
    {
        return $this->getNetworkApplianceSsidAsyncWithHttpInfo($network_id, $number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceSsidAsyncWithHttpInfo
     *
     * Return a single MX SSID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSsidAsyncWithHttpInfo($network_id, $number, string $contentType = self::contentTypes['getNetworkApplianceSsid'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner';
        $request = $this->getNetworkApplianceSsidRequest($network_id, $number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceSsid'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceSsidRequest($network_id, $number, string $contentType = self::contentTypes['getNetworkApplianceSsid'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceSsid'
            );
        }

        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkApplianceSsid'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/ssids/{number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceSsids
     *
     * List the MX SSIDs in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsids'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSsids200ResponseInner[]
     */
    public function getNetworkApplianceSsids($network_id, string $contentType = self::contentTypes['getNetworkApplianceSsids'][0])
    {
        list($response) = $this->getNetworkApplianceSsidsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceSsidsWithHttpInfo
     *
     * List the MX SSIDs in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsids'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSsids200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceSsidsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSsids'][0])
    {
        $request = $this->getNetworkApplianceSsidsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSsids200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSsids200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceSsidsAsync
     *
     * List the MX SSIDs in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsids'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSsidsAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceSsids'][0])
    {
        return $this->getNetworkApplianceSsidsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceSsidsAsyncWithHttpInfo
     *
     * List the MX SSIDs in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsids'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSsidsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceSsids'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner[]';
        $request = $this->getNetworkApplianceSsidsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceSsids'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceSsids'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceSsidsRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceSsids'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceSsids'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/ssids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceStaticRoute
     *
     * Return a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner
     */
    public function getNetworkApplianceStaticRoute($network_id, $static_route_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoute'][0])
    {
        list($response) = $this->getNetworkApplianceStaticRouteWithHttpInfo($network_id, $static_route_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceStaticRouteWithHttpInfo
     *
     * Return a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceStaticRouteWithHttpInfo($network_id, $static_route_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoute'][0])
    {
        $request = $this->getNetworkApplianceStaticRouteRequest($network_id, $static_route_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceStaticRouteAsync
     *
     * Return a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceStaticRouteAsync($network_id, $static_route_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoute'][0])
    {
        return $this->getNetworkApplianceStaticRouteAsyncWithHttpInfo($network_id, $static_route_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceStaticRouteAsyncWithHttpInfo
     *
     * Return a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceStaticRouteAsyncWithHttpInfo($network_id, $static_route_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoute'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner';
        $request = $this->getNetworkApplianceStaticRouteRequest($network_id, $static_route_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceStaticRoute'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceStaticRouteRequest($network_id, $static_route_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoute'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceStaticRoute'
            );
        }

        // verify the required parameter 'static_route_id' is set
        if ($static_route_id === null || (is_array($static_route_id) && count($static_route_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $static_route_id when calling getNetworkApplianceStaticRoute'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/staticRoutes/{staticRouteId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($static_route_id !== null) {
            $resourcePath = str_replace(
                '{' . 'staticRouteId' . '}',
                ObjectSerializer::toPathValue($static_route_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceStaticRoutes
     *
     * List the static routes for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoutes'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner[]
     */
    public function getNetworkApplianceStaticRoutes($network_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoutes'][0])
    {
        list($response) = $this->getNetworkApplianceStaticRoutesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceStaticRoutesWithHttpInfo
     *
     * List the static routes for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoutes'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceStaticRoutesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoutes'][0])
    {
        $request = $this->getNetworkApplianceStaticRoutesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceStaticRoutesAsync
     *
     * List the static routes for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoutes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceStaticRoutesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoutes'][0])
    {
        return $this->getNetworkApplianceStaticRoutesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceStaticRoutesAsyncWithHttpInfo
     *
     * List the static routes for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoutes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceStaticRoutesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoutes'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner[]';
        $request = $this->getNetworkApplianceStaticRoutesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceStaticRoutes'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceStaticRoutes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceStaticRoutesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceStaticRoutes'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceStaticRoutes'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/staticRoutes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceTrafficShaping
     *
     * Display the traffic shaping settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceTrafficShaping($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShaping'][0])
    {
        list($response) = $this->getNetworkApplianceTrafficShapingWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceTrafficShapingWithHttpInfo
     *
     * Display the traffic shaping settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceTrafficShapingWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShaping'][0])
    {
        $request = $this->getNetworkApplianceTrafficShapingRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceTrafficShapingAsync
     *
     * Display the traffic shaping settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShaping'][0])
    {
        return $this->getNetworkApplianceTrafficShapingAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingAsyncWithHttpInfo
     *
     * Display the traffic shaping settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShaping'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceTrafficShapingRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceTrafficShaping'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceTrafficShapingRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShaping'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceTrafficShaping'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/trafficShaping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingCustomPerformanceClass
     *
     * Return a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClass($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        list($response) = $this->getNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo($network_id, $custom_performance_class_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo
     *
     * Return a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        $request = $this->getNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $custom_performance_class_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceTrafficShapingCustomPerformanceClassAsync
     *
     * Return a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClassAsync($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        return $this->getNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo($network_id, $custom_performance_class_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo
     *
     * Return a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner';
        $request = $this->getNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $custom_performance_class_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceTrafficShapingCustomPerformanceClass'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $custom_performance_class_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceTrafficShapingCustomPerformanceClass'
            );
        }

        // verify the required parameter 'custom_performance_class_id' is set
        if ($custom_performance_class_id === null || (is_array($custom_performance_class_id) && count($custom_performance_class_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_performance_class_id when calling getNetworkApplianceTrafficShapingCustomPerformanceClass'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($custom_performance_class_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customPerformanceClassId' . '}',
                ObjectSerializer::toPathValue($custom_performance_class_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingCustomPerformanceClasses
     *
     * List all custom performance classes for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner[]
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClasses($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'][0])
    {
        list($response) = $this->getNetworkApplianceTrafficShapingCustomPerformanceClassesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceTrafficShapingCustomPerformanceClassesWithHttpInfo
     *
     * List all custom performance classes for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClassesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'][0])
    {
        $request = $this->getNetworkApplianceTrafficShapingCustomPerformanceClassesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceTrafficShapingCustomPerformanceClassesAsync
     *
     * List all custom performance classes for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClassesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'][0])
    {
        return $this->getNetworkApplianceTrafficShapingCustomPerformanceClassesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingCustomPerformanceClassesAsyncWithHttpInfo
     *
     * List all custom performance classes for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClassesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner[]';
        $request = $this->getNetworkApplianceTrafficShapingCustomPerformanceClassesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceTrafficShapingCustomPerformanceClasses'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceTrafficShapingCustomPerformanceClassesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingCustomPerformanceClasses'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceTrafficShapingCustomPerformanceClasses'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingRules
     *
     * Display the traffic shaping settings rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceTrafficShapingRules($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingRules'][0])
    {
        list($response) = $this->getNetworkApplianceTrafficShapingRulesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceTrafficShapingRulesWithHttpInfo
     *
     * Display the traffic shaping settings rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceTrafficShapingRulesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingRules'][0])
    {
        $request = $this->getNetworkApplianceTrafficShapingRulesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceTrafficShapingRulesAsync
     *
     * Display the traffic shaping settings rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingRulesAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingRules'][0])
    {
        return $this->getNetworkApplianceTrafficShapingRulesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingRulesAsyncWithHttpInfo
     *
     * Display the traffic shaping settings rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingRulesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingRules'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceTrafficShapingRulesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceTrafficShapingRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceTrafficShapingRulesRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceTrafficShapingRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingUplinkBandwidth
     *
     * Returns the uplink bandwidth limits for your MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceTrafficShapingUplinkBandwidth200Response
     */
    public function getNetworkApplianceTrafficShapingUplinkBandwidth($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {
        list($response) = $this->getNetworkApplianceTrafficShapingUplinkBandwidthWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceTrafficShapingUplinkBandwidthWithHttpInfo
     *
     * Returns the uplink bandwidth limits for your MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceTrafficShapingUplinkBandwidth200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceTrafficShapingUplinkBandwidthWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {
        $request = $this->getNetworkApplianceTrafficShapingUplinkBandwidthRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkBandwidth200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkBandwidth200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkBandwidth200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkBandwidth200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkBandwidth200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceTrafficShapingUplinkBandwidthAsync
     *
     * Returns the uplink bandwidth limits for your MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingUplinkBandwidthAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {
        return $this->getNetworkApplianceTrafficShapingUplinkBandwidthAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingUplinkBandwidthAsyncWithHttpInfo
     *
     * Returns the uplink bandwidth limits for your MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingUplinkBandwidthAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkBandwidth200Response';
        $request = $this->getNetworkApplianceTrafficShapingUplinkBandwidthRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceTrafficShapingUplinkBandwidth'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceTrafficShapingUplinkBandwidthRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceTrafficShapingUplinkBandwidth'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingUplinkSelection
     *
     * Show uplink selection settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response
     */
    public function getNetworkApplianceTrafficShapingUplinkSelection($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'][0])
    {
        list($response) = $this->getNetworkApplianceTrafficShapingUplinkSelectionWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceTrafficShapingUplinkSelectionWithHttpInfo
     *
     * Show uplink selection settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceTrafficShapingUplinkSelectionWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'][0])
    {
        $request = $this->getNetworkApplianceTrafficShapingUplinkSelectionRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceTrafficShapingUplinkSelectionAsync
     *
     * Show uplink selection settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingUplinkSelectionAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'][0])
    {
        return $this->getNetworkApplianceTrafficShapingUplinkSelectionAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceTrafficShapingUplinkSelectionAsyncWithHttpInfo
     *
     * Show uplink selection settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceTrafficShapingUplinkSelectionAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response';
        $request = $this->getNetworkApplianceTrafficShapingUplinkSelectionRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceTrafficShapingUplinkSelection'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceTrafficShapingUplinkSelectionRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceTrafficShapingUplinkSelection'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceTrafficShapingUplinkSelection'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/uplinkSelection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceUplinksUsageHistory
     *
     * Get the sent and received bytes for each uplink of a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]
     */
    public function getNetworkApplianceUplinksUsageHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {
        list($response) = $this->getNetworkApplianceUplinksUsageHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceUplinksUsageHistoryWithHttpInfo
     *
     * Get the sent and received bytes for each uplink of a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceUplinksUsageHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {
        $request = $this->getNetworkApplianceUplinksUsageHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceUplinksUsageHistoryAsync
     *
     * Get the sent and received bytes for each uplink of a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceUplinksUsageHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {
        return $this->getNetworkApplianceUplinksUsageHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceUplinksUsageHistoryAsyncWithHttpInfo
     *
     * Get the sent and received bytes for each uplink of a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceUplinksUsageHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceUplinksUsageHistory200ResponseInner[]';
        $request = $this->getNetworkApplianceUplinksUsageHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceUplinksUsageHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 10 minutes. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 600, 1800, 3600, 86400. The default is 60. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceUplinksUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceUplinksUsageHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkApplianceUplinksUsageHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceUplinksUsageHistory'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ApplianceApi.getNetworkApplianceUplinksUsageHistory, must be smaller than or equal to 2678400.');
        }
        


        $resourcePath = '/networks/{networkId}/appliance/uplinks/usageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceVlan
     *
     * Return a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceVlans200ResponseInner
     */
    public function getNetworkApplianceVlan($network_id, $vlan_id, string $contentType = self::contentTypes['getNetworkApplianceVlan'][0])
    {
        list($response) = $this->getNetworkApplianceVlanWithHttpInfo($network_id, $vlan_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceVlanWithHttpInfo
     *
     * Return a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceVlans200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceVlanWithHttpInfo($network_id, $vlan_id, string $contentType = self::contentTypes['getNetworkApplianceVlan'][0])
    {
        $request = $this->getNetworkApplianceVlanRequest($network_id, $vlan_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceVlans200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceVlans200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceVlanAsync
     *
     * Return a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVlanAsync($network_id, $vlan_id, string $contentType = self::contentTypes['getNetworkApplianceVlan'][0])
    {
        return $this->getNetworkApplianceVlanAsyncWithHttpInfo($network_id, $vlan_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceVlanAsyncWithHttpInfo
     *
     * Return a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVlanAsyncWithHttpInfo($network_id, $vlan_id, string $contentType = self::contentTypes['getNetworkApplianceVlan'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner';
        $request = $this->getNetworkApplianceVlanRequest($network_id, $vlan_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceVlan'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceVlanRequest($network_id, $vlan_id, string $contentType = self::contentTypes['getNetworkApplianceVlan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceVlan'
            );
        }

        // verify the required parameter 'vlan_id' is set
        if ($vlan_id === null || (is_array($vlan_id) && count($vlan_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_id when calling getNetworkApplianceVlan'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/vlans/{vlanId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($vlan_id !== null) {
            $resourcePath = str_replace(
                '{' . 'vlanId' . '}',
                ObjectSerializer::toPathValue($vlan_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceVlans
     *
     * List the VLANs for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlans'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceVlans200ResponseInner[]
     */
    public function getNetworkApplianceVlans($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlans'][0])
    {
        list($response) = $this->getNetworkApplianceVlansWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceVlansWithHttpInfo
     *
     * List the VLANs for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlans'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceVlans200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceVlansWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlans'][0])
    {
        $request = $this->getNetworkApplianceVlansRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceVlans200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceVlans200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceVlansAsync
     *
     * List the VLANs for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVlansAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlans'][0])
    {
        return $this->getNetworkApplianceVlansAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceVlansAsyncWithHttpInfo
     *
     * List the VLANs for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVlansAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlans'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner[]';
        $request = $this->getNetworkApplianceVlansRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceVlans'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceVlansRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlans'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceVlans'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/vlans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceVlansSettings
     *
     * Returns the enabled status of VLANs for the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceVlansSettings200Response
     */
    public function getNetworkApplianceVlansSettings($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlansSettings'][0])
    {
        list($response) = $this->getNetworkApplianceVlansSettingsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceVlansSettingsWithHttpInfo
     *
     * Returns the enabled status of VLANs for the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceVlansSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceVlansSettingsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlansSettings'][0])
    {
        $request = $this->getNetworkApplianceVlansSettingsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceVlansSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceVlansSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceVlansSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceVlansSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceVlansSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceVlansSettingsAsync
     *
     * Returns the enabled status of VLANs for the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVlansSettingsAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlansSettings'][0])
    {
        return $this->getNetworkApplianceVlansSettingsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceVlansSettingsAsyncWithHttpInfo
     *
     * Returns the enabled status of VLANs for the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVlansSettingsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlansSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceVlansSettings200Response';
        $request = $this->getNetworkApplianceVlansSettingsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceVlansSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceVlansSettingsRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceVlansSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceVlansSettings'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/vlans/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceVpnBgp
     *
     * Return a Hub BGP Configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceVpnBgp200Response
     */
    public function getNetworkApplianceVpnBgp($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnBgp'][0])
    {
        list($response) = $this->getNetworkApplianceVpnBgpWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceVpnBgpWithHttpInfo
     *
     * Return a Hub BGP Configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceVpnBgp200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceVpnBgpWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnBgp'][0])
    {
        $request = $this->getNetworkApplianceVpnBgpRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceVpnBgp200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceVpnBgp200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceVpnBgp200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceVpnBgp200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceVpnBgp200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceVpnBgpAsync
     *
     * Return a Hub BGP Configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVpnBgpAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnBgp'][0])
    {
        return $this->getNetworkApplianceVpnBgpAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceVpnBgpAsyncWithHttpInfo
     *
     * Return a Hub BGP Configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVpnBgpAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnBgp'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceVpnBgp200Response';
        $request = $this->getNetworkApplianceVpnBgpRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceVpnBgp'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceVpnBgpRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnBgp'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceVpnBgp'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/vpn/bgp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceVpnSiteToSiteVpn
     *
     * Return the site-to-site VPN settings of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response
     */
    public function getNetworkApplianceVpnSiteToSiteVpn($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'][0])
    {
        list($response) = $this->getNetworkApplianceVpnSiteToSiteVpnWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceVpnSiteToSiteVpnWithHttpInfo
     *
     * Return the site-to-site VPN settings of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceVpnSiteToSiteVpnWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'][0])
    {
        $request = $this->getNetworkApplianceVpnSiteToSiteVpnRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceVpnSiteToSiteVpnAsync
     *
     * Return the site-to-site VPN settings of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVpnSiteToSiteVpnAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'][0])
    {
        return $this->getNetworkApplianceVpnSiteToSiteVpnAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceVpnSiteToSiteVpnAsyncWithHttpInfo
     *
     * Return the site-to-site VPN settings of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceVpnSiteToSiteVpnAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response';
        $request = $this->getNetworkApplianceVpnSiteToSiteVpnRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceVpnSiteToSiteVpn'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceVpnSiteToSiteVpnRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceVpnSiteToSiteVpn'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceVpnSiteToSiteVpn'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/vpn/siteToSiteVpn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceWarmSpare
     *
     * Return MX warm spare settings
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceWarmSpare200Response
     */
    public function getNetworkApplianceWarmSpare($network_id, string $contentType = self::contentTypes['getNetworkApplianceWarmSpare'][0])
    {
        list($response) = $this->getNetworkApplianceWarmSpareWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkApplianceWarmSpareWithHttpInfo
     *
     * Return MX warm spare settings
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceWarmSpare200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceWarmSpareWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceWarmSpare'][0])
    {
        $request = $this->getNetworkApplianceWarmSpareRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceWarmSpare200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceWarmSpare200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceWarmSpare200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceWarmSpare200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceWarmSpare200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceWarmSpareAsync
     *
     * Return MX warm spare settings
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceWarmSpareAsync($network_id, string $contentType = self::contentTypes['getNetworkApplianceWarmSpare'][0])
    {
        return $this->getNetworkApplianceWarmSpareAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceWarmSpareAsyncWithHttpInfo
     *
     * Return MX warm spare settings
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceWarmSpareAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkApplianceWarmSpare'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceWarmSpare200Response';
        $request = $this->getNetworkApplianceWarmSpareRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceWarmSpare'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkApplianceWarmSpareRequest($network_id, string $contentType = self::contentTypes['getNetworkApplianceWarmSpare'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceWarmSpare'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/warmSpare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceDnsLocalProfiles
     *
     * Fetch the local DNS profiles used in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner[]
     */
    public function getOrganizationApplianceDnsLocalProfiles($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfiles'][0])
    {
        list($response) = $this->getOrganizationApplianceDnsLocalProfilesWithHttpInfo($organization_id, $profile_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceDnsLocalProfilesWithHttpInfo
     *
     * Fetch the local DNS profiles used in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceDnsLocalProfilesWithHttpInfo($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfiles'][0])
    {
        $request = $this->getOrganizationApplianceDnsLocalProfilesRequest($organization_id, $profile_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceDnsLocalProfilesAsync
     *
     * Fetch the local DNS profiles used in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsLocalProfilesAsync($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfiles'][0])
    {
        return $this->getOrganizationApplianceDnsLocalProfilesAsyncWithHttpInfo($organization_id, $profile_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceDnsLocalProfilesAsyncWithHttpInfo
     *
     * Fetch the local DNS profiles used in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsLocalProfilesAsyncWithHttpInfo($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfiles'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner[]';
        $request = $this->getOrganizationApplianceDnsLocalProfilesRequest($organization_id, $profile_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceDnsLocalProfiles'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceDnsLocalProfilesRequest($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfiles'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceDnsLocalProfiles'
            );
        }



        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile_ids,
            'profileIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceDnsLocalProfilesAssignments
     *
     * Fetch the local DNS profile assignments in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsLocalProfilesAssignments200Response
     */
    public function getOrganizationApplianceDnsLocalProfilesAssignments($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'][0])
    {
        list($response) = $this->getOrganizationApplianceDnsLocalProfilesAssignmentsWithHttpInfo($organization_id, $profile_ids, $network_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceDnsLocalProfilesAssignmentsWithHttpInfo
     *
     * Fetch the local DNS profile assignments in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsLocalProfilesAssignments200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceDnsLocalProfilesAssignmentsWithHttpInfo($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'][0])
    {
        $request = $this->getOrganizationApplianceDnsLocalProfilesAssignmentsRequest($organization_id, $profile_ids, $network_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsLocalProfilesAssignments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsLocalProfilesAssignments200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsLocalProfilesAssignments200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalProfilesAssignments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsLocalProfilesAssignments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceDnsLocalProfilesAssignmentsAsync
     *
     * Fetch the local DNS profile assignments in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsLocalProfilesAssignmentsAsync($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'][0])
    {
        return $this->getOrganizationApplianceDnsLocalProfilesAssignmentsAsyncWithHttpInfo($organization_id, $profile_ids, $network_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceDnsLocalProfilesAssignmentsAsyncWithHttpInfo
     *
     * Fetch the local DNS profile assignments in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsLocalProfilesAssignmentsAsyncWithHttpInfo($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalProfilesAssignments200Response';
        $request = $this->getOrganizationApplianceDnsLocalProfilesAssignmentsRequest($organization_id, $profile_ids, $network_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceDnsLocalProfilesAssignments'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceDnsLocalProfilesAssignmentsRequest($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalProfilesAssignments'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceDnsLocalProfilesAssignments'
            );
        }




        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/profiles/assignments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile_ids,
            'profileIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceDnsLocalRecords
     *
     * Fetch the DNS records used in local DNS profiles
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalRecords'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]
     */
    public function getOrganizationApplianceDnsLocalRecords($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalRecords'][0])
    {
        list($response) = $this->getOrganizationApplianceDnsLocalRecordsWithHttpInfo($organization_id, $profile_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceDnsLocalRecordsWithHttpInfo
     *
     * Fetch the DNS records used in local DNS profiles
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalRecords'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceDnsLocalRecordsWithHttpInfo($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalRecords'][0])
    {
        $request = $this->getOrganizationApplianceDnsLocalRecordsRequest($organization_id, $profile_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceDnsLocalRecordsAsync
     *
     * Fetch the DNS records used in local DNS profiles
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsLocalRecordsAsync($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalRecords'][0])
    {
        return $this->getOrganizationApplianceDnsLocalRecordsAsyncWithHttpInfo($organization_id, $profile_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceDnsLocalRecordsAsyncWithHttpInfo
     *
     * Fetch the DNS records used in local DNS profiles
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsLocalRecordsAsyncWithHttpInfo($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalRecords'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner[]';
        $request = $this->getOrganizationApplianceDnsLocalRecordsRequest($organization_id, $profile_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceDnsLocalRecords'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsLocalRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceDnsLocalRecordsRequest($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsLocalRecords'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceDnsLocalRecords'
            );
        }



        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/records';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile_ids,
            'profileIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceDnsSplitProfiles
     *
     * Fetch the split DNS profiles used in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner[]
     */
    public function getOrganizationApplianceDnsSplitProfiles($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfiles'][0])
    {
        list($response) = $this->getOrganizationApplianceDnsSplitProfilesWithHttpInfo($organization_id, $profile_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceDnsSplitProfilesWithHttpInfo
     *
     * Fetch the split DNS profiles used in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceDnsSplitProfilesWithHttpInfo($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfiles'][0])
    {
        $request = $this->getOrganizationApplianceDnsSplitProfilesRequest($organization_id, $profile_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceDnsSplitProfilesAsync
     *
     * Fetch the split DNS profiles used in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsSplitProfilesAsync($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfiles'][0])
    {
        return $this->getOrganizationApplianceDnsSplitProfilesAsyncWithHttpInfo($organization_id, $profile_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceDnsSplitProfilesAsyncWithHttpInfo
     *
     * Fetch the split DNS profiles used in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsSplitProfilesAsyncWithHttpInfo($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfiles'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner[]';
        $request = $this->getOrganizationApplianceDnsSplitProfilesRequest($organization_id, $profile_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceDnsSplitProfiles'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceDnsSplitProfilesRequest($organization_id, $profile_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfiles'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceDnsSplitProfiles'
            );
        }



        $resourcePath = '/organizations/{organizationId}/appliance/dns/split/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile_ids,
            'profileIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceDnsSplitProfilesAssignments
     *
     * Fetch the split DNS profile assignments in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsSplitProfilesAssignments200Response
     */
    public function getOrganizationApplianceDnsSplitProfilesAssignments($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'][0])
    {
        list($response) = $this->getOrganizationApplianceDnsSplitProfilesAssignmentsWithHttpInfo($organization_id, $profile_ids, $network_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceDnsSplitProfilesAssignmentsWithHttpInfo
     *
     * Fetch the split DNS profile assignments in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsSplitProfilesAssignments200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceDnsSplitProfilesAssignmentsWithHttpInfo($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'][0])
    {
        $request = $this->getOrganizationApplianceDnsSplitProfilesAssignmentsRequest($organization_id, $profile_ids, $network_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsSplitProfilesAssignments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsSplitProfilesAssignments200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsSplitProfilesAssignments200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsSplitProfilesAssignments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsSplitProfilesAssignments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceDnsSplitProfilesAssignmentsAsync
     *
     * Fetch the split DNS profile assignments in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsSplitProfilesAssignmentsAsync($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'][0])
    {
        return $this->getOrganizationApplianceDnsSplitProfilesAssignmentsAsyncWithHttpInfo($organization_id, $profile_ids, $network_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceDnsSplitProfilesAssignmentsAsyncWithHttpInfo
     *
     * Fetch the split DNS profile assignments in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceDnsSplitProfilesAssignmentsAsyncWithHttpInfo($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsSplitProfilesAssignments200Response';
        $request = $this->getOrganizationApplianceDnsSplitProfilesAssignmentsRequest($organization_id, $profile_ids, $network_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceDnsSplitProfilesAssignments'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $profile_ids Optional parameter to filter the results by profile IDs (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceDnsSplitProfilesAssignmentsRequest($organization_id, $profile_ids = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceDnsSplitProfilesAssignments'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceDnsSplitProfilesAssignments'
            );
        }




        $resourcePath = '/organizations/{organizationId}/appliance/dns/split/profiles/assignments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $profile_ids,
            'profileIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceFirewallMulticastForwardingByNetwork
     *
     * List Static Multicasting forwarding settings for MX networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceFirewallMulticastForwardingByNetwork200Response
     */
    public function getOrganizationApplianceFirewallMulticastForwardingByNetwork($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'][0])
    {
        list($response) = $this->getOrganizationApplianceFirewallMulticastForwardingByNetworkWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceFirewallMulticastForwardingByNetworkWithHttpInfo
     *
     * List Static Multicasting forwarding settings for MX networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceFirewallMulticastForwardingByNetwork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceFirewallMulticastForwardingByNetworkWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'][0])
    {
        $request = $this->getOrganizationApplianceFirewallMulticastForwardingByNetworkRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceFirewallMulticastForwardingByNetwork200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceFirewallMulticastForwardingByNetwork200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceFirewallMulticastForwardingByNetwork200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceFirewallMulticastForwardingByNetwork200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceFirewallMulticastForwardingByNetwork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceFirewallMulticastForwardingByNetworkAsync
     *
     * List Static Multicasting forwarding settings for MX networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceFirewallMulticastForwardingByNetworkAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'][0])
    {
        return $this->getOrganizationApplianceFirewallMulticastForwardingByNetworkAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceFirewallMulticastForwardingByNetworkAsyncWithHttpInfo
     *
     * List Static Multicasting forwarding settings for MX networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceFirewallMulticastForwardingByNetworkAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceFirewallMulticastForwardingByNetwork200Response';
        $request = $this->getOrganizationApplianceFirewallMulticastForwardingByNetworkRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceFirewallMulticastForwardingByNetwork'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceFirewallMulticastForwardingByNetworkRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceFirewallMulticastForwardingByNetwork'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceFirewallMulticastForwardingByNetwork'
            );
        }






        $resourcePath = '/organizations/{organizationId}/appliance/firewall/multicastForwarding/byNetwork';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceSecurityEvents
     *
     * List the security events for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>[]
     */
    public function getOrganizationApplianceSecurityEvents($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getOrganizationApplianceSecurityEvents'][0])
    {
        list($response) = $this->getOrganizationApplianceSecurityEventsWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceSecurityEventsWithHttpInfo
     *
     * List the security events for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceSecurityEventsWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getOrganizationApplianceSecurityEvents'][0])
    {
        $request = $this->getOrganizationApplianceSecurityEventsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'array<string,mixed>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceSecurityEventsAsync
     *
     * List the security events for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceSecurityEventsAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getOrganizationApplianceSecurityEvents'][0])
    {
        return $this->getOrganizationApplianceSecurityEventsAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceSecurityEventsAsyncWithHttpInfo
     *
     * List the security events for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceSecurityEventsAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getOrganizationApplianceSecurityEvents'][0])
    {
        $returnType = 'array<string,mixed>[]';
        $request = $this->getOrganizationApplianceSecurityEventsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceSecurityEvents'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceSecurityEventsRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null, string $contentType = self::contentTypes['getOrganizationApplianceSecurityEvents'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceSecurityEvents'
            );
        }



        if ($timespan !== null && $timespan > 31536000) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ApplianceApi.getOrganizationApplianceSecurityEvents, must be smaller than or equal to 31536000.');
        }
        





        $resourcePath = '/organizations/{organizationId}/appliance/security/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceSecurityIntrusion
     *
     * Returns all supported intrusion settings for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationApplianceSecurityIntrusion($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceSecurityIntrusion'][0])
    {
        list($response) = $this->getOrganizationApplianceSecurityIntrusionWithHttpInfo($organization_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceSecurityIntrusionWithHttpInfo
     *
     * Returns all supported intrusion settings for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceSecurityIntrusionWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceSecurityIntrusion'][0])
    {
        $request = $this->getOrganizationApplianceSecurityIntrusionRequest($organization_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceSecurityIntrusionAsync
     *
     * Returns all supported intrusion settings for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceSecurityIntrusionAsync($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceSecurityIntrusion'][0])
    {
        return $this->getOrganizationApplianceSecurityIntrusionAsyncWithHttpInfo($organization_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceSecurityIntrusionAsyncWithHttpInfo
     *
     * Returns all supported intrusion settings for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceSecurityIntrusionAsyncWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceSecurityIntrusion'][0])
    {
        $returnType = 'object';
        $request = $this->getOrganizationApplianceSecurityIntrusionRequest($organization_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceSecurityIntrusion'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceSecurityIntrusionRequest($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceSecurityIntrusion'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceSecurityIntrusion'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/security/intrusion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork
     *
     * Display VPN exclusion rules for MX networks.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceTrafficShapingVpnExclusionsByNetwork200Response
     */
    public function getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'][0])
    {
        list($response) = $this->getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkWithHttpInfo
     *
     * Display VPN exclusion rules for MX networks.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceTrafficShapingVpnExclusionsByNetwork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'][0])
    {
        $request = $this->getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceTrafficShapingVpnExclusionsByNetwork200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceTrafficShapingVpnExclusionsByNetwork200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceTrafficShapingVpnExclusionsByNetwork200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceTrafficShapingVpnExclusionsByNetwork200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceTrafficShapingVpnExclusionsByNetwork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkAsync
     *
     * Display VPN exclusion rules for MX networks.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'][0])
    {
        return $this->getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkAsyncWithHttpInfo
     *
     * Display VPN exclusion rules for MX networks.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceTrafficShapingVpnExclusionsByNetwork200Response';
        $request = $this->getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceTrafficShapingVpnExclusionsByNetworkRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceTrafficShapingVpnExclusionsByNetwork'
            );
        }






        $resourcePath = '/organizations/{organizationId}/appliance/trafficShaping/vpnExclusions/byNetwork';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceUplinkStatuses
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]
     */
    public function getOrganizationApplianceUplinkStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {
        list($response) = $this->getOrganizationApplianceUplinkStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceUplinkStatusesWithHttpInfo
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceUplinkStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {
        $request = $this->getOrganizationApplianceUplinkStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceUplinkStatusesAsync
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinkStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {
        return $this->getOrganizationApplianceUplinkStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceUplinkStatusesAsyncWithHttpInfo
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinkStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceUplinkStatuses200ResponseInner[]';
        $request = $this->getOrganizationApplianceUplinkStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceUplinkStatuses'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[]|null $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[]|null $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinkStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceUplinkStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinkStatuses'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceUplinkStatuses'
            );
        }








        $resourcePath = '/organizations/{organizationId}/appliance/uplink/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $iccids,
            'iccids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceUplinksStatusesOverview
     *
     * Returns an overview of uplink statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response
     */
    public function getOrganizationApplianceUplinksStatusesOverview($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {
        list($response) = $this->getOrganizationApplianceUplinksStatusesOverviewWithHttpInfo($organization_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceUplinksStatusesOverviewWithHttpInfo
     *
     * Returns an overview of uplink statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceUplinksStatusesOverviewWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {
        $request = $this->getOrganizationApplianceUplinksStatusesOverviewRequest($organization_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceUplinksStatusesOverviewAsync
     *
     * Returns an overview of uplink statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinksStatusesOverviewAsync($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {
        return $this->getOrganizationApplianceUplinksStatusesOverviewAsyncWithHttpInfo($organization_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceUplinksStatusesOverviewAsyncWithHttpInfo
     *
     * Returns an overview of uplink statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinksStatusesOverviewAsyncWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceUplinksStatusesOverview200Response';
        $request = $this->getOrganizationApplianceUplinksStatusesOverviewRequest($organization_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceUplinksStatusesOverview'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceUplinksStatusesOverviewRequest($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceUplinksStatusesOverview'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceUplinksStatusesOverview'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/uplinks/statuses/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceUplinksUsageByNetwork
     *
     * Get the sent and received bytes for each uplink of all MX and Z networks within an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]
     */
    public function getOrganizationApplianceUplinksUsageByNetwork($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {
        list($response) = $this->getOrganizationApplianceUplinksUsageByNetworkWithHttpInfo($organization_id, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceUplinksUsageByNetworkWithHttpInfo
     *
     * Get the sent and received bytes for each uplink of all MX and Z networks within an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceUplinksUsageByNetworkWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {
        $request = $this->getOrganizationApplianceUplinksUsageByNetworkRequest($organization_id, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceUplinksUsageByNetworkAsync
     *
     * Get the sent and received bytes for each uplink of all MX and Z networks within an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinksUsageByNetworkAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {
        return $this->getOrganizationApplianceUplinksUsageByNetworkAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceUplinksUsageByNetworkAsyncWithHttpInfo
     *
     * Get the sent and received bytes for each uplink of all MX and Z networks within an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinksUsageByNetworkAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceUplinksUsageByNetwork200ResponseInner[]';
        $request = $this->getOrganizationApplianceUplinksUsageByNetworkRequest($organization_id, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceUplinksUsageByNetwork'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 14 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceUplinksUsageByNetworkRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceUplinksUsageByNetwork'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceUplinksUsageByNetwork'
            );
        }



        if ($timespan !== null && $timespan > 1209600) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ApplianceApi.getOrganizationApplianceUplinksUsageByNetwork, must be smaller than or equal to 1209600.');
        }
        

        $resourcePath = '/organizations/{organizationId}/appliance/uplinks/usage/byNetwork';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceVpnStats
     *
     * Show VPN history stat for networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceVpnStats200ResponseInner[]
     */
    public function getOrganizationApplianceVpnStats($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStats'][0])
    {
        list($response) = $this->getOrganizationApplianceVpnStatsWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceVpnStatsWithHttpInfo
     *
     * Show VPN history stat for networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceVpnStats200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceVpnStatsWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStats'][0])
    {
        $request = $this->getOrganizationApplianceVpnStatsRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceVpnStats200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceVpnStats200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceVpnStats200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceVpnStats200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceVpnStats200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceVpnStatsAsync
     *
     * Show VPN history stat for networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnStatsAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStats'][0])
    {
        return $this->getOrganizationApplianceVpnStatsAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceVpnStatsAsyncWithHttpInfo
     *
     * Show VPN history stat for networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnStatsAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStats'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceVpnStats200ResponseInner[]';
        $request = $this->getOrganizationApplianceVpnStatsRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceVpnStats'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceVpnStatsRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStats'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceVpnStats'
            );
        }







        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling ApplianceApi.getOrganizationApplianceVpnStats, must be smaller than or equal to 2678400.');
        }
        

        $resourcePath = '/organizations/{organizationId}/appliance/vpn/stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceVpnStatuses
     *
     * Show VPN status for networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceVpnStatuses200Response
     */
    public function getOrganizationApplianceVpnStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStatuses'][0])
    {
        list($response) = $this->getOrganizationApplianceVpnStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceVpnStatusesWithHttpInfo
     *
     * Show VPN status for networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceVpnStatuses200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceVpnStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStatuses'][0])
    {
        $request = $this->getOrganizationApplianceVpnStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceVpnStatuses200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceVpnStatuses200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceVpnStatuses200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceVpnStatuses200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceVpnStatuses200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceVpnStatusesAsync
     *
     * Show VPN status for networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStatuses'][0])
    {
        return $this->getOrganizationApplianceVpnStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceVpnStatusesAsyncWithHttpInfo
     *
     * Show VPN status for networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStatuses'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceVpnStatuses200Response';
        $request = $this->getOrganizationApplianceVpnStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceVpnStatuses'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceVpnStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationApplianceVpnStatuses'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceVpnStatuses'
            );
        }






        $resourcePath = '/organizations/{organizationId}/appliance/vpn/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceVpnThirdPartyVPNPeers
     *
     * Return the third party VPN peers for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response
     */
    public function getOrganizationApplianceVpnThirdPartyVPNPeers($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {
        list($response) = $this->getOrganizationApplianceVpnThirdPartyVPNPeersWithHttpInfo($organization_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceVpnThirdPartyVPNPeersWithHttpInfo
     *
     * Return the third party VPN peers for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceVpnThirdPartyVPNPeersWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {
        $request = $this->getOrganizationApplianceVpnThirdPartyVPNPeersRequest($organization_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceVpnThirdPartyVPNPeersAsync
     *
     * Return the third party VPN peers for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnThirdPartyVPNPeersAsync($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {
        return $this->getOrganizationApplianceVpnThirdPartyVPNPeersAsyncWithHttpInfo($organization_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceVpnThirdPartyVPNPeersAsyncWithHttpInfo
     *
     * Return the third party VPN peers for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnThirdPartyVPNPeersAsyncWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response';
        $request = $this->getOrganizationApplianceVpnThirdPartyVPNPeersRequest($organization_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceVpnThirdPartyVPNPeers'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceVpnThirdPartyVPNPeersRequest($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceVpnThirdPartyVPNPeers'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceVpnVpnFirewallRules
     *
     * Return the firewall rules for an organization&#39;s site-to-site VPN
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response
     */
    public function getOrganizationApplianceVpnVpnFirewallRules($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'][0])
    {
        list($response) = $this->getOrganizationApplianceVpnVpnFirewallRulesWithHttpInfo($organization_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceVpnVpnFirewallRulesWithHttpInfo
     *
     * Return the firewall rules for an organization&#39;s site-to-site VPN
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceVpnVpnFirewallRulesWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'][0])
    {
        $request = $this->getOrganizationApplianceVpnVpnFirewallRulesRequest($organization_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceVpnVpnFirewallRulesAsync
     *
     * Return the firewall rules for an organization&#39;s site-to-site VPN
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnVpnFirewallRulesAsync($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'][0])
    {
        return $this->getOrganizationApplianceVpnVpnFirewallRulesAsyncWithHttpInfo($organization_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceVpnVpnFirewallRulesAsyncWithHttpInfo
     *
     * Return the firewall rules for an organization&#39;s site-to-site VPN
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnVpnFirewallRulesAsyncWithHttpInfo($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response';
        $request = $this->getOrganizationApplianceVpnVpnFirewallRulesRequest($organization_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceVpnVpnFirewallRules'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationApplianceVpnVpnFirewallRulesRequest($organization_id, string $contentType = self::contentTypes['getOrganizationApplianceVpnVpnFirewallRules'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceVpnVpnFirewallRules'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/vpn/vpnFirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation swapNetworkApplianceWarmSpare
     *
     * Swap MX primary and warm spare appliances
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['swapNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceWarmSpare200Response
     */
    public function swapNetworkApplianceWarmSpare($network_id, string $contentType = self::contentTypes['swapNetworkApplianceWarmSpare'][0])
    {
        list($response) = $this->swapNetworkApplianceWarmSpareWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation swapNetworkApplianceWarmSpareWithHttpInfo
     *
     * Swap MX primary and warm spare appliances
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['swapNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceWarmSpare200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function swapNetworkApplianceWarmSpareWithHttpInfo($network_id, string $contentType = self::contentTypes['swapNetworkApplianceWarmSpare'][0])
    {
        $request = $this->swapNetworkApplianceWarmSpareRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceWarmSpare200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceWarmSpare200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceWarmSpare200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceWarmSpare200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceWarmSpare200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation swapNetworkApplianceWarmSpareAsync
     *
     * Swap MX primary and warm spare appliances
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['swapNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swapNetworkApplianceWarmSpareAsync($network_id, string $contentType = self::contentTypes['swapNetworkApplianceWarmSpare'][0])
    {
        return $this->swapNetworkApplianceWarmSpareAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swapNetworkApplianceWarmSpareAsyncWithHttpInfo
     *
     * Swap MX primary and warm spare appliances
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['swapNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swapNetworkApplianceWarmSpareAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['swapNetworkApplianceWarmSpare'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceWarmSpare200Response';
        $request = $this->swapNetworkApplianceWarmSpareRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swapNetworkApplianceWarmSpare'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['swapNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function swapNetworkApplianceWarmSpareRequest($network_id, string $contentType = self::contentTypes['swapNetworkApplianceWarmSpare'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling swapNetworkApplianceWarmSpare'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/warmSpare/swap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDeviceApplianceRadioSettings
     *
     * Update the radio settings of an appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceRadioSettingsRequest|null $update_device_appliance_radio_settings_request update_device_appliance_radio_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceApplianceRadioSettings200Response
     */
    public function updateDeviceApplianceRadioSettings($serial, $update_device_appliance_radio_settings_request = null, string $contentType = self::contentTypes['updateDeviceApplianceRadioSettings'][0])
    {
        list($response) = $this->updateDeviceApplianceRadioSettingsWithHttpInfo($serial, $update_device_appliance_radio_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateDeviceApplianceRadioSettingsWithHttpInfo
     *
     * Update the radio settings of an appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceRadioSettingsRequest|null $update_device_appliance_radio_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceApplianceRadioSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDeviceApplianceRadioSettingsWithHttpInfo($serial, $update_device_appliance_radio_settings_request = null, string $contentType = self::contentTypes['updateDeviceApplianceRadioSettings'][0])
    {
        $request = $this->updateDeviceApplianceRadioSettingsRequest($serial, $update_device_appliance_radio_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceApplianceRadioSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceApplianceRadioSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceApplianceRadioSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceApplianceRadioSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceApplianceRadioSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDeviceApplianceRadioSettingsAsync
     *
     * Update the radio settings of an appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceRadioSettingsRequest|null $update_device_appliance_radio_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceApplianceRadioSettingsAsync($serial, $update_device_appliance_radio_settings_request = null, string $contentType = self::contentTypes['updateDeviceApplianceRadioSettings'][0])
    {
        return $this->updateDeviceApplianceRadioSettingsAsyncWithHttpInfo($serial, $update_device_appliance_radio_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDeviceApplianceRadioSettingsAsyncWithHttpInfo
     *
     * Update the radio settings of an appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceRadioSettingsRequest|null $update_device_appliance_radio_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceApplianceRadioSettingsAsyncWithHttpInfo($serial, $update_device_appliance_radio_settings_request = null, string $contentType = self::contentTypes['updateDeviceApplianceRadioSettings'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceApplianceRadioSettings200Response';
        $request = $this->updateDeviceApplianceRadioSettingsRequest($serial, $update_device_appliance_radio_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDeviceApplianceRadioSettings'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceRadioSettingsRequest|null $update_device_appliance_radio_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceRadioSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDeviceApplianceRadioSettingsRequest($serial, $update_device_appliance_radio_settings_request = null, string $contentType = self::contentTypes['updateDeviceApplianceRadioSettings'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling updateDeviceApplianceRadioSettings'
            );
        }



        $resourcePath = '/devices/{serial}/appliance/radio/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_device_appliance_radio_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_device_appliance_radio_settings_request));
            } else {
                $httpBody = $update_device_appliance_radio_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDeviceApplianceUplinksSettings
     *
     * Update the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceApplianceUplinksSettings200Response
     */
    public function updateDeviceApplianceUplinksSettings($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {
        list($response) = $this->updateDeviceApplianceUplinksSettingsWithHttpInfo($serial, $update_device_appliance_uplinks_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateDeviceApplianceUplinksSettingsWithHttpInfo
     *
     * Update the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceApplianceUplinksSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDeviceApplianceUplinksSettingsWithHttpInfo($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {
        $request = $this->updateDeviceApplianceUplinksSettingsRequest($serial, $update_device_appliance_uplinks_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceApplianceUplinksSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceApplianceUplinksSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDeviceApplianceUplinksSettingsAsync
     *
     * Update the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceApplianceUplinksSettingsAsync($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {
        return $this->updateDeviceApplianceUplinksSettingsAsyncWithHttpInfo($serial, $update_device_appliance_uplinks_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDeviceApplianceUplinksSettingsAsyncWithHttpInfo
     *
     * Update the uplink settings for an MX appliance
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceApplianceUplinksSettingsAsyncWithHttpInfo($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceApplianceUplinksSettings200Response';
        $request = $this->updateDeviceApplianceUplinksSettingsRequest($serial, $update_device_appliance_uplinks_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDeviceApplianceUplinksSettings'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceApplianceUplinksSettingsRequest $update_device_appliance_uplinks_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceApplianceUplinksSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDeviceApplianceUplinksSettingsRequest($serial, $update_device_appliance_uplinks_settings_request, string $contentType = self::contentTypes['updateDeviceApplianceUplinksSettings'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling updateDeviceApplianceUplinksSettings'
            );
        }

        // verify the required parameter 'update_device_appliance_uplinks_settings_request' is set
        if ($update_device_appliance_uplinks_settings_request === null || (is_array($update_device_appliance_uplinks_settings_request) && count($update_device_appliance_uplinks_settings_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_device_appliance_uplinks_settings_request when calling updateDeviceApplianceUplinksSettings'
            );
        }


        $resourcePath = '/devices/{serial}/appliance/uplinks/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_device_appliance_uplinks_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_device_appliance_uplinks_settings_request));
            } else {
                $httpBody = $update_device_appliance_uplinks_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceConnectivityMonitoringDestinations
     *
     * Update the connectivity testing destinations for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceConnectivityMonitoringDestinationsRequest|null $update_network_appliance_connectivity_monitoring_destinations_request update_network_appliance_connectivity_monitoring_destinations_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response
     */
    public function updateNetworkApplianceConnectivityMonitoringDestinations($network_id, $update_network_appliance_connectivity_monitoring_destinations_request = null, string $contentType = self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'][0])
    {
        list($response) = $this->updateNetworkApplianceConnectivityMonitoringDestinationsWithHttpInfo($network_id, $update_network_appliance_connectivity_monitoring_destinations_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceConnectivityMonitoringDestinationsWithHttpInfo
     *
     * Update the connectivity testing destinations for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceConnectivityMonitoringDestinationsRequest|null $update_network_appliance_connectivity_monitoring_destinations_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceConnectivityMonitoringDestinationsWithHttpInfo($network_id, $update_network_appliance_connectivity_monitoring_destinations_request = null, string $contentType = self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'][0])
    {
        $request = $this->updateNetworkApplianceConnectivityMonitoringDestinationsRequest($network_id, $update_network_appliance_connectivity_monitoring_destinations_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceConnectivityMonitoringDestinationsAsync
     *
     * Update the connectivity testing destinations for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceConnectivityMonitoringDestinationsRequest|null $update_network_appliance_connectivity_monitoring_destinations_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceConnectivityMonitoringDestinationsAsync($network_id, $update_network_appliance_connectivity_monitoring_destinations_request = null, string $contentType = self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'][0])
    {
        return $this->updateNetworkApplianceConnectivityMonitoringDestinationsAsyncWithHttpInfo($network_id, $update_network_appliance_connectivity_monitoring_destinations_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceConnectivityMonitoringDestinationsAsyncWithHttpInfo
     *
     * Update the connectivity testing destinations for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceConnectivityMonitoringDestinationsRequest|null $update_network_appliance_connectivity_monitoring_destinations_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceConnectivityMonitoringDestinationsAsyncWithHttpInfo($network_id, $update_network_appliance_connectivity_monitoring_destinations_request = null, string $contentType = self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceConnectivityMonitoringDestinations200Response';
        $request = $this->updateNetworkApplianceConnectivityMonitoringDestinationsRequest($network_id, $update_network_appliance_connectivity_monitoring_destinations_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceConnectivityMonitoringDestinations'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceConnectivityMonitoringDestinationsRequest|null $update_network_appliance_connectivity_monitoring_destinations_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceConnectivityMonitoringDestinationsRequest($network_id, $update_network_appliance_connectivity_monitoring_destinations_request = null, string $contentType = self::contentTypes['updateNetworkApplianceConnectivityMonitoringDestinations'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceConnectivityMonitoringDestinations'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/connectivityMonitoringDestinations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_connectivity_monitoring_destinations_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_connectivity_monitoring_destinations_request));
            } else {
                $httpBody = $update_network_appliance_connectivity_monitoring_destinations_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceContentFiltering
     *
     * Update the content filtering settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceContentFilteringRequest|null $update_network_appliance_content_filtering_request update_network_appliance_content_filtering_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceContentFiltering($network_id, $update_network_appliance_content_filtering_request = null, string $contentType = self::contentTypes['updateNetworkApplianceContentFiltering'][0])
    {
        list($response) = $this->updateNetworkApplianceContentFilteringWithHttpInfo($network_id, $update_network_appliance_content_filtering_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceContentFilteringWithHttpInfo
     *
     * Update the content filtering settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceContentFilteringRequest|null $update_network_appliance_content_filtering_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceContentFilteringWithHttpInfo($network_id, $update_network_appliance_content_filtering_request = null, string $contentType = self::contentTypes['updateNetworkApplianceContentFiltering'][0])
    {
        $request = $this->updateNetworkApplianceContentFilteringRequest($network_id, $update_network_appliance_content_filtering_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceContentFilteringAsync
     *
     * Update the content filtering settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceContentFilteringRequest|null $update_network_appliance_content_filtering_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceContentFilteringAsync($network_id, $update_network_appliance_content_filtering_request = null, string $contentType = self::contentTypes['updateNetworkApplianceContentFiltering'][0])
    {
        return $this->updateNetworkApplianceContentFilteringAsyncWithHttpInfo($network_id, $update_network_appliance_content_filtering_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceContentFilteringAsyncWithHttpInfo
     *
     * Update the content filtering settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceContentFilteringRequest|null $update_network_appliance_content_filtering_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceContentFilteringAsyncWithHttpInfo($network_id, $update_network_appliance_content_filtering_request = null, string $contentType = self::contentTypes['updateNetworkApplianceContentFiltering'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceContentFilteringRequest($network_id, $update_network_appliance_content_filtering_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceContentFiltering'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceContentFilteringRequest|null $update_network_appliance_content_filtering_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceContentFiltering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceContentFilteringRequest($network_id, $update_network_appliance_content_filtering_request = null, string $contentType = self::contentTypes['updateNetworkApplianceContentFiltering'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceContentFiltering'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/contentFiltering';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_content_filtering_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_content_filtering_request));
            } else {
                $httpBody = $update_network_appliance_content_filtering_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallCellularFirewallRules
     *
     * Update the cellular firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallCellularFirewallRulesRequest|null $update_network_appliance_firewall_cellular_firewall_rules_request update_network_appliance_firewall_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceFirewallCellularFirewallRules($network_id, $update_network_appliance_firewall_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallCellularFirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_cellular_firewall_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallCellularFirewallRulesWithHttpInfo
     *
     * Update the cellular firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallCellularFirewallRulesRequest|null $update_network_appliance_firewall_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallCellularFirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'][0])
    {
        $request = $this->updateNetworkApplianceFirewallCellularFirewallRulesRequest($network_id, $update_network_appliance_firewall_cellular_firewall_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallCellularFirewallRulesAsync
     *
     * Update the cellular firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallCellularFirewallRulesRequest|null $update_network_appliance_firewall_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallCellularFirewallRulesAsync($network_id, $update_network_appliance_firewall_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'][0])
    {
        return $this->updateNetworkApplianceFirewallCellularFirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_cellular_firewall_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallCellularFirewallRulesAsyncWithHttpInfo
     *
     * Update the cellular firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallCellularFirewallRulesRequest|null $update_network_appliance_firewall_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallCellularFirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceFirewallCellularFirewallRulesRequest($network_id, $update_network_appliance_firewall_cellular_firewall_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallCellularFirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallCellularFirewallRulesRequest|null $update_network_appliance_firewall_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallCellularFirewallRulesRequest($network_id, $update_network_appliance_firewall_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallCellularFirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallCellularFirewallRules'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/firewall/cellularFirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_cellular_firewall_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_cellular_firewall_rules_request));
            } else {
                $httpBody = $update_network_appliance_firewall_cellular_firewall_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallFirewalledService
     *
     * Updates the accessibility settings for the given service (&#39;ICMP&#39;, &#39;web&#39;, or &#39;SNMP&#39;)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallFirewalledServiceRequest $update_network_appliance_firewall_firewalled_service_request update_network_appliance_firewall_firewalled_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner
     */
    public function updateNetworkApplianceFirewallFirewalledService($network_id, $service, $update_network_appliance_firewall_firewalled_service_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallFirewalledService'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallFirewalledServiceWithHttpInfo($network_id, $service, $update_network_appliance_firewall_firewalled_service_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallFirewalledServiceWithHttpInfo
     *
     * Updates the accessibility settings for the given service (&#39;ICMP&#39;, &#39;web&#39;, or &#39;SNMP&#39;)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallFirewalledServiceRequest $update_network_appliance_firewall_firewalled_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallFirewalledServiceWithHttpInfo($network_id, $service, $update_network_appliance_firewall_firewalled_service_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallFirewalledService'][0])
    {
        $request = $this->updateNetworkApplianceFirewallFirewalledServiceRequest($network_id, $service, $update_network_appliance_firewall_firewalled_service_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallFirewalledServiceAsync
     *
     * Updates the accessibility settings for the given service (&#39;ICMP&#39;, &#39;web&#39;, or &#39;SNMP&#39;)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallFirewalledServiceRequest $update_network_appliance_firewall_firewalled_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallFirewalledServiceAsync($network_id, $service, $update_network_appliance_firewall_firewalled_service_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallFirewalledService'][0])
    {
        return $this->updateNetworkApplianceFirewallFirewalledServiceAsyncWithHttpInfo($network_id, $service, $update_network_appliance_firewall_firewalled_service_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallFirewalledServiceAsyncWithHttpInfo
     *
     * Updates the accessibility settings for the given service (&#39;ICMP&#39;, &#39;web&#39;, or &#39;SNMP&#39;)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallFirewalledServiceRequest $update_network_appliance_firewall_firewalled_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallFirewalledServiceAsyncWithHttpInfo($network_id, $service, $update_network_appliance_firewall_firewalled_service_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallFirewalledService'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallFirewalledServices200ResponseInner';
        $request = $this->updateNetworkApplianceFirewallFirewalledServiceRequest($network_id, $service, $update_network_appliance_firewall_firewalled_service_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallFirewalledService'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $service Service (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallFirewalledServiceRequest $update_network_appliance_firewall_firewalled_service_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallFirewalledService'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallFirewalledServiceRequest($network_id, $service, $update_network_appliance_firewall_firewalled_service_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallFirewalledService'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallFirewalledService'
            );
        }

        // verify the required parameter 'service' is set
        if ($service === null || (is_array($service) && count($service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service when calling updateNetworkApplianceFirewallFirewalledService'
            );
        }

        // verify the required parameter 'update_network_appliance_firewall_firewalled_service_request' is set
        if ($update_network_appliance_firewall_firewalled_service_request === null || (is_array($update_network_appliance_firewall_firewalled_service_request) && count($update_network_appliance_firewall_firewalled_service_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_appliance_firewall_firewalled_service_request when calling updateNetworkApplianceFirewallFirewalledService'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/firewalledServices/{service}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($service !== null) {
            $resourcePath = str_replace(
                '{' . 'service' . '}',
                ObjectSerializer::toPathValue($service),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_firewalled_service_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_firewalled_service_request));
            } else {
                $httpBody = $update_network_appliance_firewall_firewalled_service_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallInboundCellularFirewallRules
     *
     * Update the inbound cellular firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundCellularFirewallRulesRequest|null $update_network_appliance_firewall_inbound_cellular_firewall_rules_request update_network_appliance_firewall_inbound_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response
     */
    public function updateNetworkApplianceFirewallInboundCellularFirewallRules($network_id, $update_network_appliance_firewall_inbound_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallInboundCellularFirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_inbound_cellular_firewall_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallInboundCellularFirewallRulesWithHttpInfo
     *
     * Update the inbound cellular firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundCellularFirewallRulesRequest|null $update_network_appliance_firewall_inbound_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallInboundCellularFirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_inbound_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {
        $request = $this->updateNetworkApplianceFirewallInboundCellularFirewallRulesRequest($network_id, $update_network_appliance_firewall_inbound_cellular_firewall_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallInboundCellularFirewallRulesAsync
     *
     * Update the inbound cellular firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundCellularFirewallRulesRequest|null $update_network_appliance_firewall_inbound_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallInboundCellularFirewallRulesAsync($network_id, $update_network_appliance_firewall_inbound_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {
        return $this->updateNetworkApplianceFirewallInboundCellularFirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_inbound_cellular_firewall_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallInboundCellularFirewallRulesAsyncWithHttpInfo
     *
     * Update the inbound cellular firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundCellularFirewallRulesRequest|null $update_network_appliance_firewall_inbound_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallInboundCellularFirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_inbound_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response';
        $request = $this->updateNetworkApplianceFirewallInboundCellularFirewallRulesRequest($network_id, $update_network_appliance_firewall_inbound_cellular_firewall_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallInboundCellularFirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundCellularFirewallRulesRequest|null $update_network_appliance_firewall_inbound_cellular_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallInboundCellularFirewallRulesRequest($network_id, $update_network_appliance_firewall_inbound_cellular_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundCellularFirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallInboundCellularFirewallRules'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/firewall/inboundCellularFirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_inbound_cellular_firewall_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_inbound_cellular_firewall_rules_request));
            } else {
                $httpBody = $update_network_appliance_firewall_inbound_cellular_firewall_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallInboundFirewallRules
     *
     * Update the inbound firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundFirewallRulesRequest|null $update_network_appliance_firewall_inbound_firewall_rules_request update_network_appliance_firewall_inbound_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response
     */
    public function updateNetworkApplianceFirewallInboundFirewallRules($network_id, $update_network_appliance_firewall_inbound_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallInboundFirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_inbound_firewall_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallInboundFirewallRulesWithHttpInfo
     *
     * Update the inbound firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundFirewallRulesRequest|null $update_network_appliance_firewall_inbound_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallInboundFirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_inbound_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'][0])
    {
        $request = $this->updateNetworkApplianceFirewallInboundFirewallRulesRequest($network_id, $update_network_appliance_firewall_inbound_firewall_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallInboundFirewallRulesAsync
     *
     * Update the inbound firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundFirewallRulesRequest|null $update_network_appliance_firewall_inbound_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallInboundFirewallRulesAsync($network_id, $update_network_appliance_firewall_inbound_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'][0])
    {
        return $this->updateNetworkApplianceFirewallInboundFirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_inbound_firewall_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallInboundFirewallRulesAsyncWithHttpInfo
     *
     * Update the inbound firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundFirewallRulesRequest|null $update_network_appliance_firewall_inbound_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallInboundFirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_inbound_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundFirewallRules200Response';
        $request = $this->updateNetworkApplianceFirewallInboundFirewallRulesRequest($network_id, $update_network_appliance_firewall_inbound_firewall_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallInboundFirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallInboundFirewallRulesRequest|null $update_network_appliance_firewall_inbound_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallInboundFirewallRulesRequest($network_id, $update_network_appliance_firewall_inbound_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallInboundFirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallInboundFirewallRules'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/firewall/inboundFirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_inbound_firewall_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_inbound_firewall_rules_request));
            } else {
                $httpBody = $update_network_appliance_firewall_inbound_firewall_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallL3FirewallRules
     *
     * Update the L3 firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL3FirewallRulesRequest|null $update_network_appliance_firewall_l3_firewall_rules_request update_network_appliance_firewall_l3_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceFirewallL3FirewallRules($network_id, $update_network_appliance_firewall_l3_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallL3FirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_l3_firewall_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallL3FirewallRulesWithHttpInfo
     *
     * Update the L3 firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL3FirewallRulesRequest|null $update_network_appliance_firewall_l3_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallL3FirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_l3_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'][0])
    {
        $request = $this->updateNetworkApplianceFirewallL3FirewallRulesRequest($network_id, $update_network_appliance_firewall_l3_firewall_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallL3FirewallRulesAsync
     *
     * Update the L3 firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL3FirewallRulesRequest|null $update_network_appliance_firewall_l3_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallL3FirewallRulesAsync($network_id, $update_network_appliance_firewall_l3_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'][0])
    {
        return $this->updateNetworkApplianceFirewallL3FirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_l3_firewall_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallL3FirewallRulesAsyncWithHttpInfo
     *
     * Update the L3 firewall rules of an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL3FirewallRulesRequest|null $update_network_appliance_firewall_l3_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallL3FirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_l3_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceFirewallL3FirewallRulesRequest($network_id, $update_network_appliance_firewall_l3_firewall_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallL3FirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL3FirewallRulesRequest|null $update_network_appliance_firewall_l3_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallL3FirewallRulesRequest($network_id, $update_network_appliance_firewall_l3_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL3FirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallL3FirewallRules'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/firewall/l3FirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_l3_firewall_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_l3_firewall_rules_request));
            } else {
                $httpBody = $update_network_appliance_firewall_l3_firewall_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallL7FirewallRules
     *
     * Update the MX L7 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL7FirewallRulesRequest|null $update_network_appliance_firewall_l7_firewall_rules_request update_network_appliance_firewall_l7_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceFirewallL7FirewallRules($network_id, $update_network_appliance_firewall_l7_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallL7FirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_l7_firewall_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallL7FirewallRulesWithHttpInfo
     *
     * Update the MX L7 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL7FirewallRulesRequest|null $update_network_appliance_firewall_l7_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallL7FirewallRulesWithHttpInfo($network_id, $update_network_appliance_firewall_l7_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'][0])
    {
        $request = $this->updateNetworkApplianceFirewallL7FirewallRulesRequest($network_id, $update_network_appliance_firewall_l7_firewall_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallL7FirewallRulesAsync
     *
     * Update the MX L7 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL7FirewallRulesRequest|null $update_network_appliance_firewall_l7_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallL7FirewallRulesAsync($network_id, $update_network_appliance_firewall_l7_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'][0])
    {
        return $this->updateNetworkApplianceFirewallL7FirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_l7_firewall_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallL7FirewallRulesAsyncWithHttpInfo
     *
     * Update the MX L7 firewall rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL7FirewallRulesRequest|null $update_network_appliance_firewall_l7_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallL7FirewallRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_l7_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceFirewallL7FirewallRulesRequest($network_id, $update_network_appliance_firewall_l7_firewall_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallL7FirewallRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallL7FirewallRulesRequest|null $update_network_appliance_firewall_l7_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallL7FirewallRulesRequest($network_id, $update_network_appliance_firewall_l7_firewall_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallL7FirewallRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallL7FirewallRules'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/firewall/l7FirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_l7_firewall_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_l7_firewall_rules_request));
            } else {
                $httpBody = $update_network_appliance_firewall_l7_firewall_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallMulticastForwarding
     *
     * Update static multicast forward rules for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwardingRequest $update_network_appliance_firewall_multicast_forwarding_request update_network_appliance_firewall_multicast_forwarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwarding200Response
     */
    public function updateNetworkApplianceFirewallMulticastForwarding($network_id, $update_network_appliance_firewall_multicast_forwarding_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallMulticastForwardingWithHttpInfo($network_id, $update_network_appliance_firewall_multicast_forwarding_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallMulticastForwardingWithHttpInfo
     *
     * Update static multicast forward rules for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwardingRequest $update_network_appliance_firewall_multicast_forwarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwarding200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallMulticastForwardingWithHttpInfo($network_id, $update_network_appliance_firewall_multicast_forwarding_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'][0])
    {
        $request = $this->updateNetworkApplianceFirewallMulticastForwardingRequest($network_id, $update_network_appliance_firewall_multicast_forwarding_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwarding200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwarding200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwarding200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwarding200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwarding200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallMulticastForwardingAsync
     *
     * Update static multicast forward rules for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwardingRequest $update_network_appliance_firewall_multicast_forwarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallMulticastForwardingAsync($network_id, $update_network_appliance_firewall_multicast_forwarding_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'][0])
    {
        return $this->updateNetworkApplianceFirewallMulticastForwardingAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_multicast_forwarding_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallMulticastForwardingAsyncWithHttpInfo
     *
     * Update static multicast forward rules for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwardingRequest $update_network_appliance_firewall_multicast_forwarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallMulticastForwardingAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_multicast_forwarding_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'][0])
    {
        $returnType = '\Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwarding200Response';
        $request = $this->updateNetworkApplianceFirewallMulticastForwardingRequest($network_id, $update_network_appliance_firewall_multicast_forwarding_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallMulticastForwarding'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallMulticastForwardingRequest $update_network_appliance_firewall_multicast_forwarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallMulticastForwardingRequest($network_id, $update_network_appliance_firewall_multicast_forwarding_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallMulticastForwarding'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallMulticastForwarding'
            );
        }

        // verify the required parameter 'update_network_appliance_firewall_multicast_forwarding_request' is set
        if ($update_network_appliance_firewall_multicast_forwarding_request === null || (is_array($update_network_appliance_firewall_multicast_forwarding_request) && count($update_network_appliance_firewall_multicast_forwarding_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_appliance_firewall_multicast_forwarding_request when calling updateNetworkApplianceFirewallMulticastForwarding'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/multicastForwarding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_multicast_forwarding_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_multicast_forwarding_request));
            } else {
                $httpBody = $update_network_appliance_firewall_multicast_forwarding_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallOneToManyNatRules
     *
     * Set the 1:Many NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToManyNatRulesRequest $update_network_appliance_firewall_one_to_many_nat_rules_request update_network_appliance_firewall_one_to_many_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceFirewallOneToManyNatRules($network_id, $update_network_appliance_firewall_one_to_many_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallOneToManyNatRulesWithHttpInfo($network_id, $update_network_appliance_firewall_one_to_many_nat_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallOneToManyNatRulesWithHttpInfo
     *
     * Set the 1:Many NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToManyNatRulesRequest $update_network_appliance_firewall_one_to_many_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallOneToManyNatRulesWithHttpInfo($network_id, $update_network_appliance_firewall_one_to_many_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'][0])
    {
        $request = $this->updateNetworkApplianceFirewallOneToManyNatRulesRequest($network_id, $update_network_appliance_firewall_one_to_many_nat_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallOneToManyNatRulesAsync
     *
     * Set the 1:Many NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToManyNatRulesRequest $update_network_appliance_firewall_one_to_many_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallOneToManyNatRulesAsync($network_id, $update_network_appliance_firewall_one_to_many_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'][0])
    {
        return $this->updateNetworkApplianceFirewallOneToManyNatRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_one_to_many_nat_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallOneToManyNatRulesAsyncWithHttpInfo
     *
     * Set the 1:Many NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToManyNatRulesRequest $update_network_appliance_firewall_one_to_many_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallOneToManyNatRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_one_to_many_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceFirewallOneToManyNatRulesRequest($network_id, $update_network_appliance_firewall_one_to_many_nat_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallOneToManyNatRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToManyNatRulesRequest $update_network_appliance_firewall_one_to_many_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallOneToManyNatRulesRequest($network_id, $update_network_appliance_firewall_one_to_many_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToManyNatRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallOneToManyNatRules'
            );
        }

        // verify the required parameter 'update_network_appliance_firewall_one_to_many_nat_rules_request' is set
        if ($update_network_appliance_firewall_one_to_many_nat_rules_request === null || (is_array($update_network_appliance_firewall_one_to_many_nat_rules_request) && count($update_network_appliance_firewall_one_to_many_nat_rules_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_appliance_firewall_one_to_many_nat_rules_request when calling updateNetworkApplianceFirewallOneToManyNatRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/oneToManyNatRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_one_to_many_nat_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_one_to_many_nat_rules_request));
            } else {
                $httpBody = $update_network_appliance_firewall_one_to_many_nat_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallOneToOneNatRules
     *
     * Set the 1:1 NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToOneNatRulesRequest $update_network_appliance_firewall_one_to_one_nat_rules_request update_network_appliance_firewall_one_to_one_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceFirewallOneToOneNatRules($network_id, $update_network_appliance_firewall_one_to_one_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallOneToOneNatRulesWithHttpInfo($network_id, $update_network_appliance_firewall_one_to_one_nat_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallOneToOneNatRulesWithHttpInfo
     *
     * Set the 1:1 NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToOneNatRulesRequest $update_network_appliance_firewall_one_to_one_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallOneToOneNatRulesWithHttpInfo($network_id, $update_network_appliance_firewall_one_to_one_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'][0])
    {
        $request = $this->updateNetworkApplianceFirewallOneToOneNatRulesRequest($network_id, $update_network_appliance_firewall_one_to_one_nat_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallOneToOneNatRulesAsync
     *
     * Set the 1:1 NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToOneNatRulesRequest $update_network_appliance_firewall_one_to_one_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallOneToOneNatRulesAsync($network_id, $update_network_appliance_firewall_one_to_one_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'][0])
    {
        return $this->updateNetworkApplianceFirewallOneToOneNatRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_one_to_one_nat_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallOneToOneNatRulesAsyncWithHttpInfo
     *
     * Set the 1:1 NAT mapping rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToOneNatRulesRequest $update_network_appliance_firewall_one_to_one_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallOneToOneNatRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_one_to_one_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceFirewallOneToOneNatRulesRequest($network_id, $update_network_appliance_firewall_one_to_one_nat_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallOneToOneNatRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallOneToOneNatRulesRequest $update_network_appliance_firewall_one_to_one_nat_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallOneToOneNatRulesRequest($network_id, $update_network_appliance_firewall_one_to_one_nat_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallOneToOneNatRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallOneToOneNatRules'
            );
        }

        // verify the required parameter 'update_network_appliance_firewall_one_to_one_nat_rules_request' is set
        if ($update_network_appliance_firewall_one_to_one_nat_rules_request === null || (is_array($update_network_appliance_firewall_one_to_one_nat_rules_request) && count($update_network_appliance_firewall_one_to_one_nat_rules_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_appliance_firewall_one_to_one_nat_rules_request when calling updateNetworkApplianceFirewallOneToOneNatRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/oneToOneNatRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_one_to_one_nat_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_one_to_one_nat_rules_request));
            } else {
                $httpBody = $update_network_appliance_firewall_one_to_one_nat_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallPortForwardingRules
     *
     * Update the port forwarding rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallPortForwardingRulesRequest $update_network_appliance_firewall_port_forwarding_rules_request update_network_appliance_firewall_port_forwarding_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response
     */
    public function updateNetworkApplianceFirewallPortForwardingRules($network_id, $update_network_appliance_firewall_port_forwarding_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallPortForwardingRulesWithHttpInfo($network_id, $update_network_appliance_firewall_port_forwarding_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallPortForwardingRulesWithHttpInfo
     *
     * Update the port forwarding rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallPortForwardingRulesRequest $update_network_appliance_firewall_port_forwarding_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallPortForwardingRulesWithHttpInfo($network_id, $update_network_appliance_firewall_port_forwarding_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'][0])
    {
        $request = $this->updateNetworkApplianceFirewallPortForwardingRulesRequest($network_id, $update_network_appliance_firewall_port_forwarding_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallPortForwardingRulesAsync
     *
     * Update the port forwarding rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallPortForwardingRulesRequest $update_network_appliance_firewall_port_forwarding_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallPortForwardingRulesAsync($network_id, $update_network_appliance_firewall_port_forwarding_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'][0])
    {
        return $this->updateNetworkApplianceFirewallPortForwardingRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_port_forwarding_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallPortForwardingRulesAsyncWithHttpInfo
     *
     * Update the port forwarding rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallPortForwardingRulesRequest $update_network_appliance_firewall_port_forwarding_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallPortForwardingRulesAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_port_forwarding_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallPortForwardingRules200Response';
        $request = $this->updateNetworkApplianceFirewallPortForwardingRulesRequest($network_id, $update_network_appliance_firewall_port_forwarding_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallPortForwardingRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallPortForwardingRulesRequest $update_network_appliance_firewall_port_forwarding_rules_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallPortForwardingRulesRequest($network_id, $update_network_appliance_firewall_port_forwarding_rules_request, string $contentType = self::contentTypes['updateNetworkApplianceFirewallPortForwardingRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallPortForwardingRules'
            );
        }

        // verify the required parameter 'update_network_appliance_firewall_port_forwarding_rules_request' is set
        if ($update_network_appliance_firewall_port_forwarding_rules_request === null || (is_array($update_network_appliance_firewall_port_forwarding_rules_request) && count($update_network_appliance_firewall_port_forwarding_rules_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_appliance_firewall_port_forwarding_rules_request when calling updateNetworkApplianceFirewallPortForwardingRules'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/firewall/portForwardingRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_port_forwarding_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_port_forwarding_rules_request));
            } else {
                $httpBody = $update_network_appliance_firewall_port_forwarding_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceFirewallSettings
     *
     * Update the firewall settings for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallSettingsRequest|null $update_network_appliance_firewall_settings_request update_network_appliance_firewall_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceFirewallSettings($network_id, $update_network_appliance_firewall_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallSettings'][0])
    {
        list($response) = $this->updateNetworkApplianceFirewallSettingsWithHttpInfo($network_id, $update_network_appliance_firewall_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceFirewallSettingsWithHttpInfo
     *
     * Update the firewall settings for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallSettingsRequest|null $update_network_appliance_firewall_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceFirewallSettingsWithHttpInfo($network_id, $update_network_appliance_firewall_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallSettings'][0])
    {
        $request = $this->updateNetworkApplianceFirewallSettingsRequest($network_id, $update_network_appliance_firewall_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceFirewallSettingsAsync
     *
     * Update the firewall settings for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallSettingsRequest|null $update_network_appliance_firewall_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallSettingsAsync($network_id, $update_network_appliance_firewall_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallSettings'][0])
    {
        return $this->updateNetworkApplianceFirewallSettingsAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceFirewallSettingsAsyncWithHttpInfo
     *
     * Update the firewall settings for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallSettingsRequest|null $update_network_appliance_firewall_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceFirewallSettingsAsyncWithHttpInfo($network_id, $update_network_appliance_firewall_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallSettings'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceFirewallSettingsRequest($network_id, $update_network_appliance_firewall_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceFirewallSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceFirewallSettingsRequest|null $update_network_appliance_firewall_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceFirewallSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceFirewallSettingsRequest($network_id, $update_network_appliance_firewall_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceFirewallSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceFirewallSettings'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/firewall/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_firewall_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_firewall_settings_request));
            } else {
                $httpBody = $update_network_appliance_firewall_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkAppliancePort
     *
     * Update the per-port VLAN settings for a single MX port.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePortRequest|null $update_network_appliance_port_request update_network_appliance_port_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAppliancePorts200ResponseInner
     */
    public function updateNetworkAppliancePort($network_id, $port_id, $update_network_appliance_port_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePort'][0])
    {
        list($response) = $this->updateNetworkAppliancePortWithHttpInfo($network_id, $port_id, $update_network_appliance_port_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkAppliancePortWithHttpInfo
     *
     * Update the per-port VLAN settings for a single MX port.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePortRequest|null $update_network_appliance_port_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAppliancePorts200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkAppliancePortWithHttpInfo($network_id, $port_id, $update_network_appliance_port_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePort'][0])
    {
        $request = $this->updateNetworkAppliancePortRequest($network_id, $port_id, $update_network_appliance_port_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAppliancePorts200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAppliancePorts200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkAppliancePortAsync
     *
     * Update the per-port VLAN settings for a single MX port.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePortRequest|null $update_network_appliance_port_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAppliancePortAsync($network_id, $port_id, $update_network_appliance_port_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePort'][0])
    {
        return $this->updateNetworkAppliancePortAsyncWithHttpInfo($network_id, $port_id, $update_network_appliance_port_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkAppliancePortAsyncWithHttpInfo
     *
     * Update the per-port VLAN settings for a single MX port.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePortRequest|null $update_network_appliance_port_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAppliancePortAsyncWithHttpInfo($network_id, $port_id, $update_network_appliance_port_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePort'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAppliancePorts200ResponseInner';
        $request = $this->updateNetworkAppliancePortRequest($network_id, $port_id, $update_network_appliance_port_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkAppliancePort'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $port_id Port ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePortRequest|null $update_network_appliance_port_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePort'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkAppliancePortRequest($network_id, $port_id, $update_network_appliance_port_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePort'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkAppliancePort'
            );
        }

        // verify the required parameter 'port_id' is set
        if ($port_id === null || (is_array($port_id) && count($port_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $port_id when calling updateNetworkAppliancePort'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/ports/{portId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($port_id !== null) {
            $resourcePath = str_replace(
                '{' . 'portId' . '}',
                ObjectSerializer::toPathValue($port_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_port_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_port_request));
            } else {
                $httpBody = $update_network_appliance_port_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkAppliancePrefixesDelegatedStatic
     *
     * Update a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePrefixesDelegatedStaticRequest|null $update_network_appliance_prefixes_delegated_static_request update_network_appliance_prefixes_delegated_static_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkAppliancePrefixesDelegatedStatic($network_id, $static_delegated_prefix_id, $update_network_appliance_prefixes_delegated_static_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        list($response) = $this->updateNetworkAppliancePrefixesDelegatedStaticWithHttpInfo($network_id, $static_delegated_prefix_id, $update_network_appliance_prefixes_delegated_static_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkAppliancePrefixesDelegatedStaticWithHttpInfo
     *
     * Update a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePrefixesDelegatedStaticRequest|null $update_network_appliance_prefixes_delegated_static_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkAppliancePrefixesDelegatedStaticWithHttpInfo($network_id, $static_delegated_prefix_id, $update_network_appliance_prefixes_delegated_static_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        $request = $this->updateNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $static_delegated_prefix_id, $update_network_appliance_prefixes_delegated_static_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkAppliancePrefixesDelegatedStaticAsync
     *
     * Update a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePrefixesDelegatedStaticRequest|null $update_network_appliance_prefixes_delegated_static_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAppliancePrefixesDelegatedStaticAsync($network_id, $static_delegated_prefix_id, $update_network_appliance_prefixes_delegated_static_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        return $this->updateNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo($network_id, $static_delegated_prefix_id, $update_network_appliance_prefixes_delegated_static_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo
     *
     * Update a static delegated prefix from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePrefixesDelegatedStaticRequest|null $update_network_appliance_prefixes_delegated_static_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAppliancePrefixesDelegatedStaticAsyncWithHttpInfo($network_id, $static_delegated_prefix_id, $update_network_appliance_prefixes_delegated_static_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $static_delegated_prefix_id, $update_network_appliance_prefixes_delegated_static_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkAppliancePrefixesDelegatedStatic'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_delegated_prefix_id Static delegated prefix ID (required)
     * @param  \Meraki\Model\UpdateNetworkAppliancePrefixesDelegatedStaticRequest|null $update_network_appliance_prefixes_delegated_static_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkAppliancePrefixesDelegatedStaticRequest($network_id, $static_delegated_prefix_id, $update_network_appliance_prefixes_delegated_static_request = null, string $contentType = self::contentTypes['updateNetworkAppliancePrefixesDelegatedStatic'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkAppliancePrefixesDelegatedStatic'
            );
        }

        // verify the required parameter 'static_delegated_prefix_id' is set
        if ($static_delegated_prefix_id === null || (is_array($static_delegated_prefix_id) && count($static_delegated_prefix_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $static_delegated_prefix_id when calling updateNetworkAppliancePrefixesDelegatedStatic'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($static_delegated_prefix_id !== null) {
            $resourcePath = str_replace(
                '{' . 'staticDelegatedPrefixId' . '}',
                ObjectSerializer::toPathValue($static_delegated_prefix_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_prefixes_delegated_static_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_prefixes_delegated_static_request));
            } else {
                $httpBody = $update_network_appliance_prefixes_delegated_static_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceRfProfile
     *
     * Updates specified RF profile for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceRfProfileRequest|null $update_network_appliance_rf_profile_request update_network_appliance_rf_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner
     */
    public function updateNetworkApplianceRfProfile($network_id, $rf_profile_id, $update_network_appliance_rf_profile_request = null, string $contentType = self::contentTypes['updateNetworkApplianceRfProfile'][0])
    {
        list($response) = $this->updateNetworkApplianceRfProfileWithHttpInfo($network_id, $rf_profile_id, $update_network_appliance_rf_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceRfProfileWithHttpInfo
     *
     * Updates specified RF profile for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceRfProfileRequest|null $update_network_appliance_rf_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceRfProfileWithHttpInfo($network_id, $rf_profile_id, $update_network_appliance_rf_profile_request = null, string $contentType = self::contentTypes['updateNetworkApplianceRfProfile'][0])
    {
        $request = $this->updateNetworkApplianceRfProfileRequest($network_id, $rf_profile_id, $update_network_appliance_rf_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceRfProfileAsync
     *
     * Updates specified RF profile for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceRfProfileRequest|null $update_network_appliance_rf_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceRfProfileAsync($network_id, $rf_profile_id, $update_network_appliance_rf_profile_request = null, string $contentType = self::contentTypes['updateNetworkApplianceRfProfile'][0])
    {
        return $this->updateNetworkApplianceRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id, $update_network_appliance_rf_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceRfProfileAsyncWithHttpInfo
     *
     * Updates specified RF profile for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceRfProfileRequest|null $update_network_appliance_rf_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id, $update_network_appliance_rf_profile_request = null, string $contentType = self::contentTypes['updateNetworkApplianceRfProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceRfProfiles200ResponseAssignedInner';
        $request = $this->updateNetworkApplianceRfProfileRequest($network_id, $rf_profile_id, $update_network_appliance_rf_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceRfProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $rf_profile_id Rf profile ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceRfProfileRequest|null $update_network_appliance_rf_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceRfProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceRfProfileRequest($network_id, $rf_profile_id, $update_network_appliance_rf_profile_request = null, string $contentType = self::contentTypes['updateNetworkApplianceRfProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceRfProfile'
            );
        }

        // verify the required parameter 'rf_profile_id' is set
        if ($rf_profile_id === null || (is_array($rf_profile_id) && count($rf_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rf_profile_id when calling updateNetworkApplianceRfProfile'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/rfProfiles/{rfProfileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($rf_profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rfProfileId' . '}',
                ObjectSerializer::toPathValue($rf_profile_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_rf_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_rf_profile_request));
            } else {
                $httpBody = $update_network_appliance_rf_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceSdwanInternetPolicies
     *
     * Update SDWAN internet traffic preferences for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSdwanInternetPoliciesRequest|null $update_network_appliance_sdwan_internet_policies_request update_network_appliance_sdwan_internet_policies_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\UpdateNetworkApplianceSdwanInternetPolicies200Response
     */
    public function updateNetworkApplianceSdwanInternetPolicies($network_id, $update_network_appliance_sdwan_internet_policies_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'][0])
    {
        list($response) = $this->updateNetworkApplianceSdwanInternetPoliciesWithHttpInfo($network_id, $update_network_appliance_sdwan_internet_policies_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceSdwanInternetPoliciesWithHttpInfo
     *
     * Update SDWAN internet traffic preferences for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSdwanInternetPoliciesRequest|null $update_network_appliance_sdwan_internet_policies_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\UpdateNetworkApplianceSdwanInternetPolicies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceSdwanInternetPoliciesWithHttpInfo($network_id, $update_network_appliance_sdwan_internet_policies_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'][0])
    {
        $request = $this->updateNetworkApplianceSdwanInternetPoliciesRequest($network_id, $update_network_appliance_sdwan_internet_policies_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\UpdateNetworkApplianceSdwanInternetPolicies200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\UpdateNetworkApplianceSdwanInternetPolicies200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\UpdateNetworkApplianceSdwanInternetPolicies200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\UpdateNetworkApplianceSdwanInternetPolicies200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\UpdateNetworkApplianceSdwanInternetPolicies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceSdwanInternetPoliciesAsync
     *
     * Update SDWAN internet traffic preferences for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSdwanInternetPoliciesRequest|null $update_network_appliance_sdwan_internet_policies_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSdwanInternetPoliciesAsync($network_id, $update_network_appliance_sdwan_internet_policies_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'][0])
    {
        return $this->updateNetworkApplianceSdwanInternetPoliciesAsyncWithHttpInfo($network_id, $update_network_appliance_sdwan_internet_policies_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceSdwanInternetPoliciesAsyncWithHttpInfo
     *
     * Update SDWAN internet traffic preferences for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSdwanInternetPoliciesRequest|null $update_network_appliance_sdwan_internet_policies_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSdwanInternetPoliciesAsyncWithHttpInfo($network_id, $update_network_appliance_sdwan_internet_policies_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'][0])
    {
        $returnType = '\Meraki\Model\UpdateNetworkApplianceSdwanInternetPolicies200Response';
        $request = $this->updateNetworkApplianceSdwanInternetPoliciesRequest($network_id, $update_network_appliance_sdwan_internet_policies_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceSdwanInternetPolicies'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSdwanInternetPoliciesRequest|null $update_network_appliance_sdwan_internet_policies_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceSdwanInternetPoliciesRequest($network_id, $update_network_appliance_sdwan_internet_policies_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSdwanInternetPolicies'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceSdwanInternetPolicies'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/sdwan/internetPolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_sdwan_internet_policies_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_sdwan_internet_policies_request));
            } else {
                $httpBody = $update_network_appliance_sdwan_internet_policies_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceSecurityIntrusion
     *
     * Set the supported intrusion settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityIntrusionRequest|null $update_network_appliance_security_intrusion_request update_network_appliance_security_intrusion_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response
     */
    public function updateNetworkApplianceSecurityIntrusion($network_id, $update_network_appliance_security_intrusion_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSecurityIntrusion'][0])
    {
        list($response) = $this->updateNetworkApplianceSecurityIntrusionWithHttpInfo($network_id, $update_network_appliance_security_intrusion_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceSecurityIntrusionWithHttpInfo
     *
     * Set the supported intrusion settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityIntrusionRequest|null $update_network_appliance_security_intrusion_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceSecurityIntrusionWithHttpInfo($network_id, $update_network_appliance_security_intrusion_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSecurityIntrusion'][0])
    {
        $request = $this->updateNetworkApplianceSecurityIntrusionRequest($network_id, $update_network_appliance_security_intrusion_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceSecurityIntrusionAsync
     *
     * Set the supported intrusion settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityIntrusionRequest|null $update_network_appliance_security_intrusion_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSecurityIntrusionAsync($network_id, $update_network_appliance_security_intrusion_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSecurityIntrusion'][0])
    {
        return $this->updateNetworkApplianceSecurityIntrusionAsyncWithHttpInfo($network_id, $update_network_appliance_security_intrusion_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceSecurityIntrusionAsyncWithHttpInfo
     *
     * Set the supported intrusion settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityIntrusionRequest|null $update_network_appliance_security_intrusion_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSecurityIntrusionAsyncWithHttpInfo($network_id, $update_network_appliance_security_intrusion_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSecurityIntrusion'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSecurityIntrusion200Response';
        $request = $this->updateNetworkApplianceSecurityIntrusionRequest($network_id, $update_network_appliance_security_intrusion_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceSecurityIntrusion'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityIntrusionRequest|null $update_network_appliance_security_intrusion_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceSecurityIntrusionRequest($network_id, $update_network_appliance_security_intrusion_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSecurityIntrusion'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceSecurityIntrusion'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/security/intrusion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_security_intrusion_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_security_intrusion_request));
            } else {
                $httpBody = $update_network_appliance_security_intrusion_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceSecurityMalware
     *
     * Set the supported malware settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityMalwareRequest $update_network_appliance_security_malware_request update_network_appliance_security_malware_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSecurityMalware200Response
     */
    public function updateNetworkApplianceSecurityMalware($network_id, $update_network_appliance_security_malware_request, string $contentType = self::contentTypes['updateNetworkApplianceSecurityMalware'][0])
    {
        list($response) = $this->updateNetworkApplianceSecurityMalwareWithHttpInfo($network_id, $update_network_appliance_security_malware_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceSecurityMalwareWithHttpInfo
     *
     * Set the supported malware settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityMalwareRequest $update_network_appliance_security_malware_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSecurityMalware200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceSecurityMalwareWithHttpInfo($network_id, $update_network_appliance_security_malware_request, string $contentType = self::contentTypes['updateNetworkApplianceSecurityMalware'][0])
    {
        $request = $this->updateNetworkApplianceSecurityMalwareRequest($network_id, $update_network_appliance_security_malware_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSecurityMalware200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSecurityMalware200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSecurityMalware200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSecurityMalware200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSecurityMalware200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceSecurityMalwareAsync
     *
     * Set the supported malware settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityMalwareRequest $update_network_appliance_security_malware_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSecurityMalwareAsync($network_id, $update_network_appliance_security_malware_request, string $contentType = self::contentTypes['updateNetworkApplianceSecurityMalware'][0])
    {
        return $this->updateNetworkApplianceSecurityMalwareAsyncWithHttpInfo($network_id, $update_network_appliance_security_malware_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceSecurityMalwareAsyncWithHttpInfo
     *
     * Set the supported malware settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityMalwareRequest $update_network_appliance_security_malware_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSecurityMalwareAsyncWithHttpInfo($network_id, $update_network_appliance_security_malware_request, string $contentType = self::contentTypes['updateNetworkApplianceSecurityMalware'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSecurityMalware200Response';
        $request = $this->updateNetworkApplianceSecurityMalwareRequest($network_id, $update_network_appliance_security_malware_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceSecurityMalware'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSecurityMalwareRequest $update_network_appliance_security_malware_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSecurityMalware'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceSecurityMalwareRequest($network_id, $update_network_appliance_security_malware_request, string $contentType = self::contentTypes['updateNetworkApplianceSecurityMalware'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceSecurityMalware'
            );
        }

        // verify the required parameter 'update_network_appliance_security_malware_request' is set
        if ($update_network_appliance_security_malware_request === null || (is_array($update_network_appliance_security_malware_request) && count($update_network_appliance_security_malware_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_appliance_security_malware_request when calling updateNetworkApplianceSecurityMalware'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/security/malware';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_security_malware_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_security_malware_request));
            } else {
                $httpBody = $update_network_appliance_security_malware_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceSettings
     *
     * Update the appliance settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSettingsRequest|null $update_network_appliance_settings_request update_network_appliance_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSettings200Response
     */
    public function updateNetworkApplianceSettings($network_id, $update_network_appliance_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSettings'][0])
    {
        list($response) = $this->updateNetworkApplianceSettingsWithHttpInfo($network_id, $update_network_appliance_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceSettingsWithHttpInfo
     *
     * Update the appliance settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSettingsRequest|null $update_network_appliance_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceSettingsWithHttpInfo($network_id, $update_network_appliance_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSettings'][0])
    {
        $request = $this->updateNetworkApplianceSettingsRequest($network_id, $update_network_appliance_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceSettingsAsync
     *
     * Update the appliance settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSettingsRequest|null $update_network_appliance_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSettingsAsync($network_id, $update_network_appliance_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSettings'][0])
    {
        return $this->updateNetworkApplianceSettingsAsyncWithHttpInfo($network_id, $update_network_appliance_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceSettingsAsyncWithHttpInfo
     *
     * Update the appliance settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSettingsRequest|null $update_network_appliance_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSettingsAsyncWithHttpInfo($network_id, $update_network_appliance_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSettings200Response';
        $request = $this->updateNetworkApplianceSettingsRequest($network_id, $update_network_appliance_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSettingsRequest|null $update_network_appliance_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceSettingsRequest($network_id, $update_network_appliance_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceSettings'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_settings_request));
            } else {
                $httpBody = $update_network_appliance_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceSingleLan
     *
     * Update single LAN configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSingleLanRequest|null $update_network_appliance_single_lan_request update_network_appliance_single_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSingleLan200Response
     */
    public function updateNetworkApplianceSingleLan($network_id, $update_network_appliance_single_lan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSingleLan'][0])
    {
        list($response) = $this->updateNetworkApplianceSingleLanWithHttpInfo($network_id, $update_network_appliance_single_lan_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceSingleLanWithHttpInfo
     *
     * Update single LAN configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSingleLanRequest|null $update_network_appliance_single_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSingleLan200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceSingleLanWithHttpInfo($network_id, $update_network_appliance_single_lan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSingleLan'][0])
    {
        $request = $this->updateNetworkApplianceSingleLanRequest($network_id, $update_network_appliance_single_lan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSingleLan200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSingleLan200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSingleLan200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSingleLan200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSingleLan200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceSingleLanAsync
     *
     * Update single LAN configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSingleLanRequest|null $update_network_appliance_single_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSingleLanAsync($network_id, $update_network_appliance_single_lan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSingleLan'][0])
    {
        return $this->updateNetworkApplianceSingleLanAsyncWithHttpInfo($network_id, $update_network_appliance_single_lan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceSingleLanAsyncWithHttpInfo
     *
     * Update single LAN configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSingleLanRequest|null $update_network_appliance_single_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSingleLanAsyncWithHttpInfo($network_id, $update_network_appliance_single_lan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSingleLan'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSingleLan200Response';
        $request = $this->updateNetworkApplianceSingleLanRequest($network_id, $update_network_appliance_single_lan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceSingleLan'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSingleLanRequest|null $update_network_appliance_single_lan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSingleLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceSingleLanRequest($network_id, $update_network_appliance_single_lan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSingleLan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceSingleLan'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/singleLan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_single_lan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_single_lan_request));
            } else {
                $httpBody = $update_network_appliance_single_lan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceSsid
     *
     * Update the attributes of an MX SSID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSsidRequest|null $update_network_appliance_ssid_request update_network_appliance_ssid_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceSsids200ResponseInner
     */
    public function updateNetworkApplianceSsid($network_id, $number, $update_network_appliance_ssid_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSsid'][0])
    {
        list($response) = $this->updateNetworkApplianceSsidWithHttpInfo($network_id, $number, $update_network_appliance_ssid_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceSsidWithHttpInfo
     *
     * Update the attributes of an MX SSID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSsidRequest|null $update_network_appliance_ssid_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceSsids200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceSsidWithHttpInfo($network_id, $number, $update_network_appliance_ssid_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSsid'][0])
    {
        $request = $this->updateNetworkApplianceSsidRequest($network_id, $number, $update_network_appliance_ssid_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceSsids200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceSsids200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceSsidAsync
     *
     * Update the attributes of an MX SSID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSsidRequest|null $update_network_appliance_ssid_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSsidAsync($network_id, $number, $update_network_appliance_ssid_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSsid'][0])
    {
        return $this->updateNetworkApplianceSsidAsyncWithHttpInfo($network_id, $number, $update_network_appliance_ssid_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceSsidAsyncWithHttpInfo
     *
     * Update the attributes of an MX SSID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSsidRequest|null $update_network_appliance_ssid_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceSsidAsyncWithHttpInfo($network_id, $number, $update_network_appliance_ssid_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSsid'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceSsids200ResponseInner';
        $request = $this->updateNetworkApplianceSsidRequest($network_id, $number, $update_network_appliance_ssid_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceSsid'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $number Number (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceSsidRequest|null $update_network_appliance_ssid_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceSsid'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceSsidRequest($network_id, $number, $update_network_appliance_ssid_request = null, string $contentType = self::contentTypes['updateNetworkApplianceSsid'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceSsid'
            );
        }

        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkApplianceSsid'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/ssids/{number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_ssid_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_ssid_request));
            } else {
                $httpBody = $update_network_appliance_ssid_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceStaticRoute
     *
     * Update a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceStaticRouteRequest|null $update_network_appliance_static_route_request update_network_appliance_static_route_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner
     */
    public function updateNetworkApplianceStaticRoute($network_id, $static_route_id, $update_network_appliance_static_route_request = null, string $contentType = self::contentTypes['updateNetworkApplianceStaticRoute'][0])
    {
        list($response) = $this->updateNetworkApplianceStaticRouteWithHttpInfo($network_id, $static_route_id, $update_network_appliance_static_route_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceStaticRouteWithHttpInfo
     *
     * Update a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceStaticRouteRequest|null $update_network_appliance_static_route_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceStaticRouteWithHttpInfo($network_id, $static_route_id, $update_network_appliance_static_route_request = null, string $contentType = self::contentTypes['updateNetworkApplianceStaticRoute'][0])
    {
        $request = $this->updateNetworkApplianceStaticRouteRequest($network_id, $static_route_id, $update_network_appliance_static_route_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceStaticRouteAsync
     *
     * Update a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceStaticRouteRequest|null $update_network_appliance_static_route_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceStaticRouteAsync($network_id, $static_route_id, $update_network_appliance_static_route_request = null, string $contentType = self::contentTypes['updateNetworkApplianceStaticRoute'][0])
    {
        return $this->updateNetworkApplianceStaticRouteAsyncWithHttpInfo($network_id, $static_route_id, $update_network_appliance_static_route_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceStaticRouteAsyncWithHttpInfo
     *
     * Update a static route for an MX or teleworker network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceStaticRouteRequest|null $update_network_appliance_static_route_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceStaticRouteAsyncWithHttpInfo($network_id, $static_route_id, $update_network_appliance_static_route_request = null, string $contentType = self::contentTypes['updateNetworkApplianceStaticRoute'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceStaticRoutes200ResponseInner';
        $request = $this->updateNetworkApplianceStaticRouteRequest($network_id, $static_route_id, $update_network_appliance_static_route_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceStaticRoute'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $static_route_id Static route ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceStaticRouteRequest|null $update_network_appliance_static_route_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceStaticRoute'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceStaticRouteRequest($network_id, $static_route_id, $update_network_appliance_static_route_request = null, string $contentType = self::contentTypes['updateNetworkApplianceStaticRoute'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceStaticRoute'
            );
        }

        // verify the required parameter 'static_route_id' is set
        if ($static_route_id === null || (is_array($static_route_id) && count($static_route_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $static_route_id when calling updateNetworkApplianceStaticRoute'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/staticRoutes/{staticRouteId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($static_route_id !== null) {
            $resourcePath = str_replace(
                '{' . 'staticRouteId' . '}',
                ObjectSerializer::toPathValue($static_route_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_static_route_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_static_route_request));
            } else {
                $httpBody = $update_network_appliance_static_route_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceTrafficShaping
     *
     * Update the traffic shaping settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRequest|null $update_network_appliance_traffic_shaping_request update_network_appliance_traffic_shaping_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceTrafficShaping($network_id, $update_network_appliance_traffic_shaping_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShaping'][0])
    {
        list($response) = $this->updateNetworkApplianceTrafficShapingWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingWithHttpInfo
     *
     * Update the traffic shaping settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRequest|null $update_network_appliance_traffic_shaping_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceTrafficShapingWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShaping'][0])
    {
        $request = $this->updateNetworkApplianceTrafficShapingRequest($network_id, $update_network_appliance_traffic_shaping_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingAsync
     *
     * Update the traffic shaping settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRequest|null $update_network_appliance_traffic_shaping_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingAsync($network_id, $update_network_appliance_traffic_shaping_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShaping'][0])
    {
        return $this->updateNetworkApplianceTrafficShapingAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingAsyncWithHttpInfo
     *
     * Update the traffic shaping settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRequest|null $update_network_appliance_traffic_shaping_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShaping'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceTrafficShapingRequest($network_id, $update_network_appliance_traffic_shaping_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceTrafficShaping'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRequest|null $update_network_appliance_traffic_shaping_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShaping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceTrafficShapingRequest($network_id, $update_network_appliance_traffic_shaping_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShaping'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceTrafficShaping'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/trafficShaping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_traffic_shaping_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_traffic_shaping_request));
            } else {
                $httpBody = $update_network_appliance_traffic_shaping_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingCustomPerformanceClass
     *
     * Update a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingCustomPerformanceClassRequest|null $update_network_appliance_traffic_shaping_custom_performance_class_request update_network_appliance_traffic_shaping_custom_performance_class_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner
     */
    public function updateNetworkApplianceTrafficShapingCustomPerformanceClass($network_id, $custom_performance_class_id, $update_network_appliance_traffic_shaping_custom_performance_class_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        list($response) = $this->updateNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo($network_id, $custom_performance_class_id, $update_network_appliance_traffic_shaping_custom_performance_class_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo
     *
     * Update a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingCustomPerformanceClassRequest|null $update_network_appliance_traffic_shaping_custom_performance_class_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceTrafficShapingCustomPerformanceClassWithHttpInfo($network_id, $custom_performance_class_id, $update_network_appliance_traffic_shaping_custom_performance_class_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        $request = $this->updateNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $custom_performance_class_id, $update_network_appliance_traffic_shaping_custom_performance_class_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingCustomPerformanceClassAsync
     *
     * Update a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingCustomPerformanceClassRequest|null $update_network_appliance_traffic_shaping_custom_performance_class_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingCustomPerformanceClassAsync($network_id, $custom_performance_class_id, $update_network_appliance_traffic_shaping_custom_performance_class_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        return $this->updateNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo($network_id, $custom_performance_class_id, $update_network_appliance_traffic_shaping_custom_performance_class_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo
     *
     * Update a custom performance class for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingCustomPerformanceClassRequest|null $update_network_appliance_traffic_shaping_custom_performance_class_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingCustomPerformanceClassAsyncWithHttpInfo($network_id, $custom_performance_class_id, $update_network_appliance_traffic_shaping_custom_performance_class_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingCustomPerformanceClasses200ResponseInner';
        $request = $this->updateNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $custom_performance_class_id, $update_network_appliance_traffic_shaping_custom_performance_class_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceTrafficShapingCustomPerformanceClass'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $custom_performance_class_id Custom performance class ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingCustomPerformanceClassRequest|null $update_network_appliance_traffic_shaping_custom_performance_class_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceTrafficShapingCustomPerformanceClassRequest($network_id, $custom_performance_class_id, $update_network_appliance_traffic_shaping_custom_performance_class_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingCustomPerformanceClass'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceTrafficShapingCustomPerformanceClass'
            );
        }

        // verify the required parameter 'custom_performance_class_id' is set
        if ($custom_performance_class_id === null || (is_array($custom_performance_class_id) && count($custom_performance_class_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_performance_class_id when calling updateNetworkApplianceTrafficShapingCustomPerformanceClass'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($custom_performance_class_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customPerformanceClassId' . '}',
                ObjectSerializer::toPathValue($custom_performance_class_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_traffic_shaping_custom_performance_class_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_traffic_shaping_custom_performance_class_request));
            } else {
                $httpBody = $update_network_appliance_traffic_shaping_custom_performance_class_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingRules
     *
     * Update the traffic shaping settings rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRulesRequest|null $update_network_appliance_traffic_shaping_rules_request update_network_appliance_traffic_shaping_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceTrafficShapingRules($network_id, $update_network_appliance_traffic_shaping_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingRules'][0])
    {
        list($response) = $this->updateNetworkApplianceTrafficShapingRulesWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingRulesWithHttpInfo
     *
     * Update the traffic shaping settings rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRulesRequest|null $update_network_appliance_traffic_shaping_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceTrafficShapingRulesWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingRules'][0])
    {
        $request = $this->updateNetworkApplianceTrafficShapingRulesRequest($network_id, $update_network_appliance_traffic_shaping_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingRulesAsync
     *
     * Update the traffic shaping settings rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRulesRequest|null $update_network_appliance_traffic_shaping_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingRulesAsync($network_id, $update_network_appliance_traffic_shaping_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingRules'][0])
    {
        return $this->updateNetworkApplianceTrafficShapingRulesAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingRulesAsyncWithHttpInfo
     *
     * Update the traffic shaping settings rules for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRulesRequest|null $update_network_appliance_traffic_shaping_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingRulesAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingRules'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceTrafficShapingRulesRequest($network_id, $update_network_appliance_traffic_shaping_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceTrafficShapingRules'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingRulesRequest|null $update_network_appliance_traffic_shaping_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceTrafficShapingRulesRequest($network_id, $update_network_appliance_traffic_shaping_rules_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingRules'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceTrafficShapingRules'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_traffic_shaping_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_traffic_shaping_rules_request));
            } else {
                $httpBody = $update_network_appliance_traffic_shaping_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingUplinkBandwidth
     *
     * Updates the uplink bandwidth settings for your MX network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkBandwidthRequest|null $update_network_appliance_traffic_shaping_uplink_bandwidth_request update_network_appliance_traffic_shaping_uplink_bandwidth_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkApplianceTrafficShapingUplinkBandwidth($network_id, $update_network_appliance_traffic_shaping_uplink_bandwidth_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {
        list($response) = $this->updateNetworkApplianceTrafficShapingUplinkBandwidthWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_uplink_bandwidth_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingUplinkBandwidthWithHttpInfo
     *
     * Updates the uplink bandwidth settings for your MX network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkBandwidthRequest|null $update_network_appliance_traffic_shaping_uplink_bandwidth_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceTrafficShapingUplinkBandwidthWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_uplink_bandwidth_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {
        $request = $this->updateNetworkApplianceTrafficShapingUplinkBandwidthRequest($network_id, $update_network_appliance_traffic_shaping_uplink_bandwidth_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingUplinkBandwidthAsync
     *
     * Updates the uplink bandwidth settings for your MX network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkBandwidthRequest|null $update_network_appliance_traffic_shaping_uplink_bandwidth_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingUplinkBandwidthAsync($network_id, $update_network_appliance_traffic_shaping_uplink_bandwidth_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {
        return $this->updateNetworkApplianceTrafficShapingUplinkBandwidthAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_uplink_bandwidth_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingUplinkBandwidthAsyncWithHttpInfo
     *
     * Updates the uplink bandwidth settings for your MX network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkBandwidthRequest|null $update_network_appliance_traffic_shaping_uplink_bandwidth_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingUplinkBandwidthAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_uplink_bandwidth_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkApplianceTrafficShapingUplinkBandwidthRequest($network_id, $update_network_appliance_traffic_shaping_uplink_bandwidth_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceTrafficShapingUplinkBandwidth'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkBandwidthRequest|null $update_network_appliance_traffic_shaping_uplink_bandwidth_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceTrafficShapingUplinkBandwidthRequest($network_id, $update_network_appliance_traffic_shaping_uplink_bandwidth_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkBandwidth'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceTrafficShapingUplinkBandwidth'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_traffic_shaping_uplink_bandwidth_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_traffic_shaping_uplink_bandwidth_request));
            } else {
                $httpBody = $update_network_appliance_traffic_shaping_uplink_bandwidth_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingUplinkSelection
     *
     * Update uplink selection settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkSelectionRequest|null $update_network_appliance_traffic_shaping_uplink_selection_request update_network_appliance_traffic_shaping_uplink_selection_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response
     */
    public function updateNetworkApplianceTrafficShapingUplinkSelection($network_id, $update_network_appliance_traffic_shaping_uplink_selection_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'][0])
    {
        list($response) = $this->updateNetworkApplianceTrafficShapingUplinkSelectionWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_uplink_selection_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingUplinkSelectionWithHttpInfo
     *
     * Update uplink selection settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkSelectionRequest|null $update_network_appliance_traffic_shaping_uplink_selection_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceTrafficShapingUplinkSelectionWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_uplink_selection_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'][0])
    {
        $request = $this->updateNetworkApplianceTrafficShapingUplinkSelectionRequest($network_id, $update_network_appliance_traffic_shaping_uplink_selection_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingUplinkSelectionAsync
     *
     * Update uplink selection settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkSelectionRequest|null $update_network_appliance_traffic_shaping_uplink_selection_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingUplinkSelectionAsync($network_id, $update_network_appliance_traffic_shaping_uplink_selection_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'][0])
    {
        return $this->updateNetworkApplianceTrafficShapingUplinkSelectionAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_uplink_selection_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingUplinkSelectionAsyncWithHttpInfo
     *
     * Update uplink selection settings for an MX network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkSelectionRequest|null $update_network_appliance_traffic_shaping_uplink_selection_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingUplinkSelectionAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_uplink_selection_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceTrafficShapingUplinkSelection200Response';
        $request = $this->updateNetworkApplianceTrafficShapingUplinkSelectionRequest($network_id, $update_network_appliance_traffic_shaping_uplink_selection_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceTrafficShapingUplinkSelection'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingUplinkSelectionRequest|null $update_network_appliance_traffic_shaping_uplink_selection_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceTrafficShapingUplinkSelectionRequest($network_id, $update_network_appliance_traffic_shaping_uplink_selection_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingUplinkSelection'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceTrafficShapingUplinkSelection'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/uplinkSelection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_traffic_shaping_uplink_selection_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_traffic_shaping_uplink_selection_request));
            } else {
                $httpBody = $update_network_appliance_traffic_shaping_uplink_selection_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingVpnExclusions
     *
     * Update VPN exclusion rules for an MX network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusionsRequest|null $update_network_appliance_traffic_shaping_vpn_exclusions_request update_network_appliance_traffic_shaping_vpn_exclusions_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusions200Response
     */
    public function updateNetworkApplianceTrafficShapingVpnExclusions($network_id, $update_network_appliance_traffic_shaping_vpn_exclusions_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'][0])
    {
        list($response) = $this->updateNetworkApplianceTrafficShapingVpnExclusionsWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_vpn_exclusions_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingVpnExclusionsWithHttpInfo
     *
     * Update VPN exclusion rules for an MX network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusionsRequest|null $update_network_appliance_traffic_shaping_vpn_exclusions_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusions200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceTrafficShapingVpnExclusionsWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_vpn_exclusions_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'][0])
    {
        $request = $this->updateNetworkApplianceTrafficShapingVpnExclusionsRequest($network_id, $update_network_appliance_traffic_shaping_vpn_exclusions_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusions200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusions200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusions200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusions200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingVpnExclusionsAsync
     *
     * Update VPN exclusion rules for an MX network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusionsRequest|null $update_network_appliance_traffic_shaping_vpn_exclusions_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingVpnExclusionsAsync($network_id, $update_network_appliance_traffic_shaping_vpn_exclusions_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'][0])
    {
        return $this->updateNetworkApplianceTrafficShapingVpnExclusionsAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_vpn_exclusions_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceTrafficShapingVpnExclusionsAsyncWithHttpInfo
     *
     * Update VPN exclusion rules for an MX network.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusionsRequest|null $update_network_appliance_traffic_shaping_vpn_exclusions_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceTrafficShapingVpnExclusionsAsyncWithHttpInfo($network_id, $update_network_appliance_traffic_shaping_vpn_exclusions_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'][0])
    {
        $returnType = '\Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusions200Response';
        $request = $this->updateNetworkApplianceTrafficShapingVpnExclusionsRequest($network_id, $update_network_appliance_traffic_shaping_vpn_exclusions_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceTrafficShapingVpnExclusions'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceTrafficShapingVpnExclusionsRequest|null $update_network_appliance_traffic_shaping_vpn_exclusions_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceTrafficShapingVpnExclusionsRequest($network_id, $update_network_appliance_traffic_shaping_vpn_exclusions_request = null, string $contentType = self::contentTypes['updateNetworkApplianceTrafficShapingVpnExclusions'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceTrafficShapingVpnExclusions'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/trafficShaping/vpnExclusions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_traffic_shaping_vpn_exclusions_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_traffic_shaping_vpn_exclusions_request));
            } else {
                $httpBody = $update_network_appliance_traffic_shaping_vpn_exclusions_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceVlan
     *
     * Update a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlanRequest|null $update_network_appliance_vlan_request update_network_appliance_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceVlans200ResponseInner
     */
    public function updateNetworkApplianceVlan($network_id, $vlan_id, $update_network_appliance_vlan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlan'][0])
    {
        list($response) = $this->updateNetworkApplianceVlanWithHttpInfo($network_id, $vlan_id, $update_network_appliance_vlan_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceVlanWithHttpInfo
     *
     * Update a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlanRequest|null $update_network_appliance_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceVlans200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceVlanWithHttpInfo($network_id, $vlan_id, $update_network_appliance_vlan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlan'][0])
    {
        $request = $this->updateNetworkApplianceVlanRequest($network_id, $vlan_id, $update_network_appliance_vlan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceVlans200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceVlans200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceVlanAsync
     *
     * Update a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlanRequest|null $update_network_appliance_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceVlanAsync($network_id, $vlan_id, $update_network_appliance_vlan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlan'][0])
    {
        return $this->updateNetworkApplianceVlanAsyncWithHttpInfo($network_id, $vlan_id, $update_network_appliance_vlan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceVlanAsyncWithHttpInfo
     *
     * Update a VLAN
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlanRequest|null $update_network_appliance_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceVlanAsyncWithHttpInfo($network_id, $vlan_id, $update_network_appliance_vlan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlan'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceVlans200ResponseInner';
        $request = $this->updateNetworkApplianceVlanRequest($network_id, $vlan_id, $update_network_appliance_vlan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceVlan'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $vlan_id Vlan ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlanRequest|null $update_network_appliance_vlan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceVlanRequest($network_id, $vlan_id, $update_network_appliance_vlan_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceVlan'
            );
        }

        // verify the required parameter 'vlan_id' is set
        if ($vlan_id === null || (is_array($vlan_id) && count($vlan_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vlan_id when calling updateNetworkApplianceVlan'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/vlans/{vlanId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($vlan_id !== null) {
            $resourcePath = str_replace(
                '{' . 'vlanId' . '}',
                ObjectSerializer::toPathValue($vlan_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_vlan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_vlan_request));
            } else {
                $httpBody = $update_network_appliance_vlan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceVlansSettings
     *
     * Enable/Disable VLANs for the given network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlansSettingsRequest|null $update_network_appliance_vlans_settings_request update_network_appliance_vlans_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceVlansSettings200Response
     */
    public function updateNetworkApplianceVlansSettings($network_id, $update_network_appliance_vlans_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlansSettings'][0])
    {
        list($response) = $this->updateNetworkApplianceVlansSettingsWithHttpInfo($network_id, $update_network_appliance_vlans_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceVlansSettingsWithHttpInfo
     *
     * Enable/Disable VLANs for the given network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlansSettingsRequest|null $update_network_appliance_vlans_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceVlansSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceVlansSettingsWithHttpInfo($network_id, $update_network_appliance_vlans_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlansSettings'][0])
    {
        $request = $this->updateNetworkApplianceVlansSettingsRequest($network_id, $update_network_appliance_vlans_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceVlansSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceVlansSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceVlansSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceVlansSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceVlansSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceVlansSettingsAsync
     *
     * Enable/Disable VLANs for the given network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlansSettingsRequest|null $update_network_appliance_vlans_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceVlansSettingsAsync($network_id, $update_network_appliance_vlans_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlansSettings'][0])
    {
        return $this->updateNetworkApplianceVlansSettingsAsyncWithHttpInfo($network_id, $update_network_appliance_vlans_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceVlansSettingsAsyncWithHttpInfo
     *
     * Enable/Disable VLANs for the given network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlansSettingsRequest|null $update_network_appliance_vlans_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceVlansSettingsAsyncWithHttpInfo($network_id, $update_network_appliance_vlans_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlansSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceVlansSettings200Response';
        $request = $this->updateNetworkApplianceVlansSettingsRequest($network_id, $update_network_appliance_vlans_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceVlansSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVlansSettingsRequest|null $update_network_appliance_vlans_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVlansSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceVlansSettingsRequest($network_id, $update_network_appliance_vlans_settings_request = null, string $contentType = self::contentTypes['updateNetworkApplianceVlansSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceVlansSettings'
            );
        }



        $resourcePath = '/networks/{networkId}/appliance/vlans/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_vlans_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_vlans_settings_request));
            } else {
                $httpBody = $update_network_appliance_vlans_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceVpnBgp
     *
     * Update a Hub BGP Configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnBgpRequest $update_network_appliance_vpn_bgp_request update_network_appliance_vpn_bgp_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceVpnBgp200Response
     */
    public function updateNetworkApplianceVpnBgp($network_id, $update_network_appliance_vpn_bgp_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnBgp'][0])
    {
        list($response) = $this->updateNetworkApplianceVpnBgpWithHttpInfo($network_id, $update_network_appliance_vpn_bgp_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceVpnBgpWithHttpInfo
     *
     * Update a Hub BGP Configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnBgpRequest $update_network_appliance_vpn_bgp_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceVpnBgp200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceVpnBgpWithHttpInfo($network_id, $update_network_appliance_vpn_bgp_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnBgp'][0])
    {
        $request = $this->updateNetworkApplianceVpnBgpRequest($network_id, $update_network_appliance_vpn_bgp_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceVpnBgp200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceVpnBgp200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceVpnBgp200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceVpnBgp200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceVpnBgp200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceVpnBgpAsync
     *
     * Update a Hub BGP Configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnBgpRequest $update_network_appliance_vpn_bgp_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceVpnBgpAsync($network_id, $update_network_appliance_vpn_bgp_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnBgp'][0])
    {
        return $this->updateNetworkApplianceVpnBgpAsyncWithHttpInfo($network_id, $update_network_appliance_vpn_bgp_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceVpnBgpAsyncWithHttpInfo
     *
     * Update a Hub BGP Configuration
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnBgpRequest $update_network_appliance_vpn_bgp_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceVpnBgpAsyncWithHttpInfo($network_id, $update_network_appliance_vpn_bgp_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnBgp'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceVpnBgp200Response';
        $request = $this->updateNetworkApplianceVpnBgpRequest($network_id, $update_network_appliance_vpn_bgp_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceVpnBgp'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnBgpRequest $update_network_appliance_vpn_bgp_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnBgp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceVpnBgpRequest($network_id, $update_network_appliance_vpn_bgp_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnBgp'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceVpnBgp'
            );
        }

        // verify the required parameter 'update_network_appliance_vpn_bgp_request' is set
        if ($update_network_appliance_vpn_bgp_request === null || (is_array($update_network_appliance_vpn_bgp_request) && count($update_network_appliance_vpn_bgp_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_appliance_vpn_bgp_request when calling updateNetworkApplianceVpnBgp'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/vpn/bgp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_vpn_bgp_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_vpn_bgp_request));
            } else {
                $httpBody = $update_network_appliance_vpn_bgp_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceVpnSiteToSiteVpn
     *
     * Update the site-to-site VPN settings of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnSiteToSiteVpnRequest $update_network_appliance_vpn_site_to_site_vpn_request update_network_appliance_vpn_site_to_site_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response
     */
    public function updateNetworkApplianceVpnSiteToSiteVpn($network_id, $update_network_appliance_vpn_site_to_site_vpn_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'][0])
    {
        list($response) = $this->updateNetworkApplianceVpnSiteToSiteVpnWithHttpInfo($network_id, $update_network_appliance_vpn_site_to_site_vpn_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceVpnSiteToSiteVpnWithHttpInfo
     *
     * Update the site-to-site VPN settings of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnSiteToSiteVpnRequest $update_network_appliance_vpn_site_to_site_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceVpnSiteToSiteVpnWithHttpInfo($network_id, $update_network_appliance_vpn_site_to_site_vpn_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'][0])
    {
        $request = $this->updateNetworkApplianceVpnSiteToSiteVpnRequest($network_id, $update_network_appliance_vpn_site_to_site_vpn_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceVpnSiteToSiteVpnAsync
     *
     * Update the site-to-site VPN settings of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnSiteToSiteVpnRequest $update_network_appliance_vpn_site_to_site_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceVpnSiteToSiteVpnAsync($network_id, $update_network_appliance_vpn_site_to_site_vpn_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'][0])
    {
        return $this->updateNetworkApplianceVpnSiteToSiteVpnAsyncWithHttpInfo($network_id, $update_network_appliance_vpn_site_to_site_vpn_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceVpnSiteToSiteVpnAsyncWithHttpInfo
     *
     * Update the site-to-site VPN settings of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnSiteToSiteVpnRequest $update_network_appliance_vpn_site_to_site_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceVpnSiteToSiteVpnAsyncWithHttpInfo($network_id, $update_network_appliance_vpn_site_to_site_vpn_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceVpnSiteToSiteVpn200Response';
        $request = $this->updateNetworkApplianceVpnSiteToSiteVpnRequest($network_id, $update_network_appliance_vpn_site_to_site_vpn_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceVpnSiteToSiteVpn'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceVpnSiteToSiteVpnRequest $update_network_appliance_vpn_site_to_site_vpn_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceVpnSiteToSiteVpnRequest($network_id, $update_network_appliance_vpn_site_to_site_vpn_request, string $contentType = self::contentTypes['updateNetworkApplianceVpnSiteToSiteVpn'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceVpnSiteToSiteVpn'
            );
        }

        // verify the required parameter 'update_network_appliance_vpn_site_to_site_vpn_request' is set
        if ($update_network_appliance_vpn_site_to_site_vpn_request === null || (is_array($update_network_appliance_vpn_site_to_site_vpn_request) && count($update_network_appliance_vpn_site_to_site_vpn_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_appliance_vpn_site_to_site_vpn_request when calling updateNetworkApplianceVpnSiteToSiteVpn'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/vpn/siteToSiteVpn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_vpn_site_to_site_vpn_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_vpn_site_to_site_vpn_request));
            } else {
                $httpBody = $update_network_appliance_vpn_site_to_site_vpn_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkApplianceWarmSpare
     *
     * Update MX warm spare settings
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceWarmSpareRequest $update_network_appliance_warm_spare_request update_network_appliance_warm_spare_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceWarmSpare200Response
     */
    public function updateNetworkApplianceWarmSpare($network_id, $update_network_appliance_warm_spare_request, string $contentType = self::contentTypes['updateNetworkApplianceWarmSpare'][0])
    {
        list($response) = $this->updateNetworkApplianceWarmSpareWithHttpInfo($network_id, $update_network_appliance_warm_spare_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkApplianceWarmSpareWithHttpInfo
     *
     * Update MX warm spare settings
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceWarmSpareRequest $update_network_appliance_warm_spare_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceWarmSpare200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkApplianceWarmSpareWithHttpInfo($network_id, $update_network_appliance_warm_spare_request, string $contentType = self::contentTypes['updateNetworkApplianceWarmSpare'][0])
    {
        $request = $this->updateNetworkApplianceWarmSpareRequest($network_id, $update_network_appliance_warm_spare_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceWarmSpare200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceWarmSpare200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceWarmSpare200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceWarmSpare200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceWarmSpare200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkApplianceWarmSpareAsync
     *
     * Update MX warm spare settings
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceWarmSpareRequest $update_network_appliance_warm_spare_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceWarmSpareAsync($network_id, $update_network_appliance_warm_spare_request, string $contentType = self::contentTypes['updateNetworkApplianceWarmSpare'][0])
    {
        return $this->updateNetworkApplianceWarmSpareAsyncWithHttpInfo($network_id, $update_network_appliance_warm_spare_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkApplianceWarmSpareAsyncWithHttpInfo
     *
     * Update MX warm spare settings
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceWarmSpareRequest $update_network_appliance_warm_spare_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkApplianceWarmSpareAsyncWithHttpInfo($network_id, $update_network_appliance_warm_spare_request, string $contentType = self::contentTypes['updateNetworkApplianceWarmSpare'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceWarmSpare200Response';
        $request = $this->updateNetworkApplianceWarmSpareRequest($network_id, $update_network_appliance_warm_spare_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkApplianceWarmSpare'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkApplianceWarmSpareRequest $update_network_appliance_warm_spare_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkApplianceWarmSpare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkApplianceWarmSpareRequest($network_id, $update_network_appliance_warm_spare_request, string $contentType = self::contentTypes['updateNetworkApplianceWarmSpare'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkApplianceWarmSpare'
            );
        }

        // verify the required parameter 'update_network_appliance_warm_spare_request' is set
        if ($update_network_appliance_warm_spare_request === null || (is_array($update_network_appliance_warm_spare_request) && count($update_network_appliance_warm_spare_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_appliance_warm_spare_request when calling updateNetworkApplianceWarmSpare'
            );
        }


        $resourcePath = '/networks/{networkId}/appliance/warmSpare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_appliance_warm_spare_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_appliance_warm_spare_request));
            } else {
                $httpBody = $update_network_appliance_warm_spare_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrganizationApplianceDnsLocalProfile
     *
     * Update a local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner
     */
    public function updateOrganizationApplianceDnsLocalProfile($organization_id, $profile_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalProfile'][0])
    {
        list($response) = $this->updateOrganizationApplianceDnsLocalProfileWithHttpInfo($organization_id, $profile_id, $create_organization_appliance_dns_local_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation updateOrganizationApplianceDnsLocalProfileWithHttpInfo
     *
     * Update a local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrganizationApplianceDnsLocalProfileWithHttpInfo($organization_id, $profile_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalProfile'][0])
    {
        $request = $this->updateOrganizationApplianceDnsLocalProfileRequest($organization_id, $profile_id, $create_organization_appliance_dns_local_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrganizationApplianceDnsLocalProfileAsync
     *
     * Update a local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceDnsLocalProfileAsync($organization_id, $profile_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalProfile'][0])
    {
        return $this->updateOrganizationApplianceDnsLocalProfileAsyncWithHttpInfo($organization_id, $profile_id, $create_organization_appliance_dns_local_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrganizationApplianceDnsLocalProfileAsyncWithHttpInfo
     *
     * Update a local DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceDnsLocalProfileAsyncWithHttpInfo($organization_id, $profile_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalProfile'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalProfiles200ResponseInner';
        $request = $this->updateOrganizationApplianceDnsLocalProfileRequest($organization_id, $profile_id, $create_organization_appliance_dns_local_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrganizationApplianceDnsLocalProfile'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\CreateOrganizationApplianceDnsLocalProfileRequest $create_organization_appliance_dns_local_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateOrganizationApplianceDnsLocalProfileRequest($organization_id, $profile_id, $create_organization_appliance_dns_local_profile_request, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalProfile'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateOrganizationApplianceDnsLocalProfile'
            );
        }

        // verify the required parameter 'profile_id' is set
        if ($profile_id === null || (is_array($profile_id) && count($profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $profile_id when calling updateOrganizationApplianceDnsLocalProfile'
            );
        }

        // verify the required parameter 'create_organization_appliance_dns_local_profile_request' is set
        if ($create_organization_appliance_dns_local_profile_request === null || (is_array($create_organization_appliance_dns_local_profile_request) && count($create_organization_appliance_dns_local_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_appliance_dns_local_profile_request when calling updateOrganizationApplianceDnsLocalProfile'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/profiles/{profileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'profileId' . '}',
                ObjectSerializer::toPathValue($profile_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_appliance_dns_local_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_appliance_dns_local_profile_request));
            } else {
                $httpBody = $create_organization_appliance_dns_local_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrganizationApplianceDnsLocalRecord
     *
     * Updates a local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsLocalRecordRequest|null $update_organization_appliance_dns_local_record_request update_organization_appliance_dns_local_record_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner
     */
    public function updateOrganizationApplianceDnsLocalRecord($organization_id, $record_id, $update_organization_appliance_dns_local_record_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalRecord'][0])
    {
        list($response) = $this->updateOrganizationApplianceDnsLocalRecordWithHttpInfo($organization_id, $record_id, $update_organization_appliance_dns_local_record_request, $contentType);
        return $response;
    }

    /**
     * Operation updateOrganizationApplianceDnsLocalRecordWithHttpInfo
     *
     * Updates a local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsLocalRecordRequest|null $update_organization_appliance_dns_local_record_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrganizationApplianceDnsLocalRecordWithHttpInfo($organization_id, $record_id, $update_organization_appliance_dns_local_record_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalRecord'][0])
    {
        $request = $this->updateOrganizationApplianceDnsLocalRecordRequest($organization_id, $record_id, $update_organization_appliance_dns_local_record_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrganizationApplianceDnsLocalRecordAsync
     *
     * Updates a local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsLocalRecordRequest|null $update_organization_appliance_dns_local_record_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceDnsLocalRecordAsync($organization_id, $record_id, $update_organization_appliance_dns_local_record_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalRecord'][0])
    {
        return $this->updateOrganizationApplianceDnsLocalRecordAsyncWithHttpInfo($organization_id, $record_id, $update_organization_appliance_dns_local_record_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrganizationApplianceDnsLocalRecordAsyncWithHttpInfo
     *
     * Updates a local DNS record
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsLocalRecordRequest|null $update_organization_appliance_dns_local_record_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceDnsLocalRecordAsyncWithHttpInfo($organization_id, $record_id, $update_organization_appliance_dns_local_record_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalRecord'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsLocalRecords200ResponseInner';
        $request = $this->updateOrganizationApplianceDnsLocalRecordRequest($organization_id, $record_id, $update_organization_appliance_dns_local_record_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrganizationApplianceDnsLocalRecord'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $record_id Record ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsLocalRecordRequest|null $update_organization_appliance_dns_local_record_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsLocalRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateOrganizationApplianceDnsLocalRecordRequest($organization_id, $record_id, $update_organization_appliance_dns_local_record_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsLocalRecord'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateOrganizationApplianceDnsLocalRecord'
            );
        }

        // verify the required parameter 'record_id' is set
        if ($record_id === null || (is_array($record_id) && count($record_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $record_id when calling updateOrganizationApplianceDnsLocalRecord'
            );
        }



        $resourcePath = '/organizations/{organizationId}/appliance/dns/local/records/{recordId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($record_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recordId' . '}',
                ObjectSerializer::toPathValue($record_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_organization_appliance_dns_local_record_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_organization_appliance_dns_local_record_request));
            } else {
                $httpBody = $update_organization_appliance_dns_local_record_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrganizationApplianceDnsSplitProfile
     *
     * Update a split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsSplitProfileRequest|null $update_organization_appliance_dns_split_profile_request update_organization_appliance_dns_split_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner
     */
    public function updateOrganizationApplianceDnsSplitProfile($organization_id, $profile_id, $update_organization_appliance_dns_split_profile_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsSplitProfile'][0])
    {
        list($response) = $this->updateOrganizationApplianceDnsSplitProfileWithHttpInfo($organization_id, $profile_id, $update_organization_appliance_dns_split_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation updateOrganizationApplianceDnsSplitProfileWithHttpInfo
     *
     * Update a split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsSplitProfileRequest|null $update_organization_appliance_dns_split_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrganizationApplianceDnsSplitProfileWithHttpInfo($organization_id, $profile_id, $update_organization_appliance_dns_split_profile_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsSplitProfile'][0])
    {
        $request = $this->updateOrganizationApplianceDnsSplitProfileRequest($organization_id, $profile_id, $update_organization_appliance_dns_split_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrganizationApplianceDnsSplitProfileAsync
     *
     * Update a split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsSplitProfileRequest|null $update_organization_appliance_dns_split_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceDnsSplitProfileAsync($organization_id, $profile_id, $update_organization_appliance_dns_split_profile_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsSplitProfile'][0])
    {
        return $this->updateOrganizationApplianceDnsSplitProfileAsyncWithHttpInfo($organization_id, $profile_id, $update_organization_appliance_dns_split_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrganizationApplianceDnsSplitProfileAsyncWithHttpInfo
     *
     * Update a split DNS profile
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsSplitProfileRequest|null $update_organization_appliance_dns_split_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceDnsSplitProfileAsyncWithHttpInfo($organization_id, $profile_id, $update_organization_appliance_dns_split_profile_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsSplitProfile'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceDnsSplitProfiles200ResponseInner';
        $request = $this->updateOrganizationApplianceDnsSplitProfileRequest($organization_id, $profile_id, $update_organization_appliance_dns_split_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrganizationApplianceDnsSplitProfile'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $profile_id Profile ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceDnsSplitProfileRequest|null $update_organization_appliance_dns_split_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceDnsSplitProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateOrganizationApplianceDnsSplitProfileRequest($organization_id, $profile_id, $update_organization_appliance_dns_split_profile_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceDnsSplitProfile'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateOrganizationApplianceDnsSplitProfile'
            );
        }

        // verify the required parameter 'profile_id' is set
        if ($profile_id === null || (is_array($profile_id) && count($profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $profile_id when calling updateOrganizationApplianceDnsSplitProfile'
            );
        }



        $resourcePath = '/organizations/{organizationId}/appliance/dns/split/profiles/{profileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'profileId' . '}',
                ObjectSerializer::toPathValue($profile_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_organization_appliance_dns_split_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_organization_appliance_dns_split_profile_request));
            } else {
                $httpBody = $update_organization_appliance_dns_split_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrganizationApplianceSecurityIntrusion
     *
     * Sets supported intrusion settings for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceSecurityIntrusionRequest $update_organization_appliance_security_intrusion_request update_organization_appliance_security_intrusion_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateOrganizationApplianceSecurityIntrusion($organization_id, $update_organization_appliance_security_intrusion_request, string $contentType = self::contentTypes['updateOrganizationApplianceSecurityIntrusion'][0])
    {
        list($response) = $this->updateOrganizationApplianceSecurityIntrusionWithHttpInfo($organization_id, $update_organization_appliance_security_intrusion_request, $contentType);
        return $response;
    }

    /**
     * Operation updateOrganizationApplianceSecurityIntrusionWithHttpInfo
     *
     * Sets supported intrusion settings for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceSecurityIntrusionRequest $update_organization_appliance_security_intrusion_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrganizationApplianceSecurityIntrusionWithHttpInfo($organization_id, $update_organization_appliance_security_intrusion_request, string $contentType = self::contentTypes['updateOrganizationApplianceSecurityIntrusion'][0])
    {
        $request = $this->updateOrganizationApplianceSecurityIntrusionRequest($organization_id, $update_organization_appliance_security_intrusion_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrganizationApplianceSecurityIntrusionAsync
     *
     * Sets supported intrusion settings for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceSecurityIntrusionRequest $update_organization_appliance_security_intrusion_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceSecurityIntrusionAsync($organization_id, $update_organization_appliance_security_intrusion_request, string $contentType = self::contentTypes['updateOrganizationApplianceSecurityIntrusion'][0])
    {
        return $this->updateOrganizationApplianceSecurityIntrusionAsyncWithHttpInfo($organization_id, $update_organization_appliance_security_intrusion_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrganizationApplianceSecurityIntrusionAsyncWithHttpInfo
     *
     * Sets supported intrusion settings for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceSecurityIntrusionRequest $update_organization_appliance_security_intrusion_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceSecurityIntrusionAsyncWithHttpInfo($organization_id, $update_organization_appliance_security_intrusion_request, string $contentType = self::contentTypes['updateOrganizationApplianceSecurityIntrusion'][0])
    {
        $returnType = 'object';
        $request = $this->updateOrganizationApplianceSecurityIntrusionRequest($organization_id, $update_organization_appliance_security_intrusion_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrganizationApplianceSecurityIntrusion'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceSecurityIntrusionRequest $update_organization_appliance_security_intrusion_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceSecurityIntrusion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateOrganizationApplianceSecurityIntrusionRequest($organization_id, $update_organization_appliance_security_intrusion_request, string $contentType = self::contentTypes['updateOrganizationApplianceSecurityIntrusion'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateOrganizationApplianceSecurityIntrusion'
            );
        }

        // verify the required parameter 'update_organization_appliance_security_intrusion_request' is set
        if ($update_organization_appliance_security_intrusion_request === null || (is_array($update_organization_appliance_security_intrusion_request) && count($update_organization_appliance_security_intrusion_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_organization_appliance_security_intrusion_request when calling updateOrganizationApplianceSecurityIntrusion'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/security/intrusion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_organization_appliance_security_intrusion_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_organization_appliance_security_intrusion_request));
            } else {
                $httpBody = $update_organization_appliance_security_intrusion_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrganizationApplianceVpnThirdPartyVPNPeers
     *
     * Update the third party VPN peers for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnThirdPartyVPNPeersRequest $update_organization_appliance_vpn_third_party_vpn_peers_request update_organization_appliance_vpn_third_party_vpn_peers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response
     */
    public function updateOrganizationApplianceVpnThirdPartyVPNPeers($organization_id, $update_organization_appliance_vpn_third_party_vpn_peers_request, string $contentType = self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {
        list($response) = $this->updateOrganizationApplianceVpnThirdPartyVPNPeersWithHttpInfo($organization_id, $update_organization_appliance_vpn_third_party_vpn_peers_request, $contentType);
        return $response;
    }

    /**
     * Operation updateOrganizationApplianceVpnThirdPartyVPNPeersWithHttpInfo
     *
     * Update the third party VPN peers for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnThirdPartyVPNPeersRequest $update_organization_appliance_vpn_third_party_vpn_peers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrganizationApplianceVpnThirdPartyVPNPeersWithHttpInfo($organization_id, $update_organization_appliance_vpn_third_party_vpn_peers_request, string $contentType = self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {
        $request = $this->updateOrganizationApplianceVpnThirdPartyVPNPeersRequest($organization_id, $update_organization_appliance_vpn_third_party_vpn_peers_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrganizationApplianceVpnThirdPartyVPNPeersAsync
     *
     * Update the third party VPN peers for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnThirdPartyVPNPeersRequest $update_organization_appliance_vpn_third_party_vpn_peers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceVpnThirdPartyVPNPeersAsync($organization_id, $update_organization_appliance_vpn_third_party_vpn_peers_request, string $contentType = self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {
        return $this->updateOrganizationApplianceVpnThirdPartyVPNPeersAsyncWithHttpInfo($organization_id, $update_organization_appliance_vpn_third_party_vpn_peers_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrganizationApplianceVpnThirdPartyVPNPeersAsyncWithHttpInfo
     *
     * Update the third party VPN peers for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnThirdPartyVPNPeersRequest $update_organization_appliance_vpn_third_party_vpn_peers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceVpnThirdPartyVPNPeersAsyncWithHttpInfo($organization_id, $update_organization_appliance_vpn_third_party_vpn_peers_request, string $contentType = self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationApplianceVpnThirdPartyVPNPeers200Response';
        $request = $this->updateOrganizationApplianceVpnThirdPartyVPNPeersRequest($organization_id, $update_organization_appliance_vpn_third_party_vpn_peers_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrganizationApplianceVpnThirdPartyVPNPeers'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnThirdPartyVPNPeersRequest $update_organization_appliance_vpn_third_party_vpn_peers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateOrganizationApplianceVpnThirdPartyVPNPeersRequest($organization_id, $update_organization_appliance_vpn_third_party_vpn_peers_request, string $contentType = self::contentTypes['updateOrganizationApplianceVpnThirdPartyVPNPeers'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateOrganizationApplianceVpnThirdPartyVPNPeers'
            );
        }

        // verify the required parameter 'update_organization_appliance_vpn_third_party_vpn_peers_request' is set
        if ($update_organization_appliance_vpn_third_party_vpn_peers_request === null || (is_array($update_organization_appliance_vpn_third_party_vpn_peers_request) && count($update_organization_appliance_vpn_third_party_vpn_peers_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_organization_appliance_vpn_third_party_vpn_peers_request when calling updateOrganizationApplianceVpnThirdPartyVPNPeers'
            );
        }


        $resourcePath = '/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_organization_appliance_vpn_third_party_vpn_peers_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_organization_appliance_vpn_third_party_vpn_peers_request));
            } else {
                $httpBody = $update_organization_appliance_vpn_third_party_vpn_peers_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrganizationApplianceVpnVpnFirewallRules
     *
     * Update the firewall rules of an organization&#39;s site-to-site VPN
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnVpnFirewallRulesRequest|null $update_organization_appliance_vpn_vpn_firewall_rules_request update_organization_appliance_vpn_vpn_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response
     */
    public function updateOrganizationApplianceVpnVpnFirewallRules($organization_id, $update_organization_appliance_vpn_vpn_firewall_rules_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'][0])
    {
        list($response) = $this->updateOrganizationApplianceVpnVpnFirewallRulesWithHttpInfo($organization_id, $update_organization_appliance_vpn_vpn_firewall_rules_request, $contentType);
        return $response;
    }

    /**
     * Operation updateOrganizationApplianceVpnVpnFirewallRulesWithHttpInfo
     *
     * Update the firewall rules of an organization&#39;s site-to-site VPN
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnVpnFirewallRulesRequest|null $update_organization_appliance_vpn_vpn_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrganizationApplianceVpnVpnFirewallRulesWithHttpInfo($organization_id, $update_organization_appliance_vpn_vpn_firewall_rules_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'][0])
    {
        $request = $this->updateOrganizationApplianceVpnVpnFirewallRulesRequest($organization_id, $update_organization_appliance_vpn_vpn_firewall_rules_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrganizationApplianceVpnVpnFirewallRulesAsync
     *
     * Update the firewall rules of an organization&#39;s site-to-site VPN
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnVpnFirewallRulesRequest|null $update_organization_appliance_vpn_vpn_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceVpnVpnFirewallRulesAsync($organization_id, $update_organization_appliance_vpn_vpn_firewall_rules_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'][0])
    {
        return $this->updateOrganizationApplianceVpnVpnFirewallRulesAsyncWithHttpInfo($organization_id, $update_organization_appliance_vpn_vpn_firewall_rules_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrganizationApplianceVpnVpnFirewallRulesAsyncWithHttpInfo
     *
     * Update the firewall rules of an organization&#39;s site-to-site VPN
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnVpnFirewallRulesRequest|null $update_organization_appliance_vpn_vpn_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrganizationApplianceVpnVpnFirewallRulesAsyncWithHttpInfo($organization_id, $update_organization_appliance_vpn_vpn_firewall_rules_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkApplianceFirewallInboundCellularFirewallRules200Response';
        $request = $this->updateOrganizationApplianceVpnVpnFirewallRulesRequest($organization_id, $update_organization_appliance_vpn_vpn_firewall_rules_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrganizationApplianceVpnVpnFirewallRules'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\UpdateOrganizationApplianceVpnVpnFirewallRulesRequest|null $update_organization_appliance_vpn_vpn_firewall_rules_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateOrganizationApplianceVpnVpnFirewallRulesRequest($organization_id, $update_organization_appliance_vpn_vpn_firewall_rules_request = null, string $contentType = self::contentTypes['updateOrganizationApplianceVpnVpnFirewallRules'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateOrganizationApplianceVpnVpnFirewallRules'
            );
        }



        $resourcePath = '/organizations/{organizationId}/appliance/vpn/vpnFirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_organization_appliance_vpn_vpn_firewall_rules_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_organization_appliance_vpn_vpn_firewall_rules_request));
            } else {
                $httpBody = $update_organization_appliance_vpn_vpn_firewall_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
