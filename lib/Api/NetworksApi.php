<?php
/**
 * NetworksApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Meraki\ApiException;
use Meraki\Configuration;
use Meraki\HeaderSelector;
use Meraki\ObjectSerializer;

/**
 * NetworksApi Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class NetworksApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'batchNetworkFloorPlansAutoLocateJobs' => [
            'application/json',
        ],
        'batchNetworkFloorPlansDevicesUpdate' => [
            'application/json',
        ],
        'bindNetwork' => [
            'application/json',
        ],
        'cancelNetworkFloorPlansAutoLocateJob' => [
            'application/json',
        ],
        'claimNetworkDevices' => [
            'application/json',
        ],
        'combineOrganizationNetworks' => [
            'application/json',
        ],
        'createNetworkFirmwareUpgradesRollback' => [
            'application/json',
        ],
        'createNetworkFirmwareUpgradesStagedEvent' => [
            'application/json',
        ],
        'createNetworkFirmwareUpgradesStagedGroup' => [
            'application/json',
        ],
        'createNetworkFloorPlan' => [
            'application/json',
        ],
        'createNetworkGroupPolicy' => [
            'application/json',
        ],
        'createNetworkMerakiAuthUser' => [
            'application/json',
        ],
        'createNetworkMqttBroker' => [
            'application/json',
        ],
        'createNetworkPiiRequest' => [
            'application/json',
        ],
        'createNetworkVlanProfile' => [
            'application/json',
        ],
        'createNetworkWebhooksHttpServer' => [
            'application/json',
        ],
        'createNetworkWebhooksPayloadTemplate' => [
            'application/json',
        ],
        'createNetworkWebhooksWebhookTest' => [
            'application/json',
        ],
        'createOrganizationNetwork' => [
            'application/json',
        ],
        'deferNetworkFirmwareUpgradesStagedEvents' => [
            'application/json',
        ],
        'deleteNetwork' => [
            'application/json',
        ],
        'deleteNetworkFirmwareUpgradesStagedGroup' => [
            'application/json',
        ],
        'deleteNetworkFloorPlan' => [
            'application/json',
        ],
        'deleteNetworkGroupPolicy' => [
            'application/json',
        ],
        'deleteNetworkMerakiAuthUser' => [
            'application/json',
        ],
        'deleteNetworkMqttBroker' => [
            'application/json',
        ],
        'deleteNetworkPiiRequest' => [
            'application/json',
        ],
        'deleteNetworkVlanProfile' => [
            'application/json',
        ],
        'deleteNetworkWebhooksHttpServer' => [
            'application/json',
        ],
        'deleteNetworkWebhooksPayloadTemplate' => [
            'application/json',
        ],
        'disableOrganizationIntegrationsXdrNetworks' => [
            'application/json',
        ],
        'enableOrganizationIntegrationsXdrNetworks' => [
            'application/json',
        ],
        'getNetwork' => [
            'application/json',
        ],
        'getNetworkAlertsHistory' => [
            'application/json',
        ],
        'getNetworkAlertsSettings' => [
            'application/json',
        ],
        'getNetworkBluetoothClient' => [
            'application/json',
        ],
        'getNetworkBluetoothClients' => [
            'application/json',
        ],
        'getNetworkClient' => [
            'application/json',
        ],
        'getNetworkClientPolicy' => [
            'application/json',
        ],
        'getNetworkClientSplashAuthorizationStatus' => [
            'application/json',
        ],
        'getNetworkClientTrafficHistory' => [
            'application/json',
        ],
        'getNetworkClientUsageHistory' => [
            'application/json',
        ],
        'getNetworkClients' => [
            'application/json',
        ],
        'getNetworkClientsApplicationUsage' => [
            'application/json',
        ],
        'getNetworkClientsBandwidthUsageHistory' => [
            'application/json',
        ],
        'getNetworkClientsOverview' => [
            'application/json',
        ],
        'getNetworkClientsUsageHistories' => [
            'application/json',
        ],
        'getNetworkDevices' => [
            'application/json',
        ],
        'getNetworkEvents' => [
            'application/json',
        ],
        'getNetworkEventsEventTypes' => [
            'application/json',
        ],
        'getNetworkFirmwareUpgrades' => [
            'application/json',
        ],
        'getNetworkFirmwareUpgradesStagedEvents' => [
            'application/json',
        ],
        'getNetworkFirmwareUpgradesStagedGroup' => [
            'application/json',
        ],
        'getNetworkFirmwareUpgradesStagedGroups' => [
            'application/json',
        ],
        'getNetworkFirmwareUpgradesStagedStages' => [
            'application/json',
        ],
        'getNetworkFloorPlan' => [
            'application/json',
        ],
        'getNetworkFloorPlans' => [
            'application/json',
        ],
        'getNetworkGroupPolicies' => [
            'application/json',
        ],
        'getNetworkGroupPolicy' => [
            'application/json',
        ],
        'getNetworkHealthAlerts' => [
            'application/json',
        ],
        'getNetworkMerakiAuthUser' => [
            'application/json',
        ],
        'getNetworkMerakiAuthUsers' => [
            'application/json',
        ],
        'getNetworkMqttBroker' => [
            'application/json',
        ],
        'getNetworkMqttBrokers' => [
            'application/json',
        ],
        'getNetworkNetflow' => [
            'application/json',
        ],
        'getNetworkNetworkHealthChannelUtilization' => [
            'application/json',
        ],
        'getNetworkPiiPiiKeys' => [
            'application/json',
        ],
        'getNetworkPiiRequest' => [
            'application/json',
        ],
        'getNetworkPiiRequests' => [
            'application/json',
        ],
        'getNetworkPiiSmDevicesForKey' => [
            'application/json',
        ],
        'getNetworkPiiSmOwnersForKey' => [
            'application/json',
        ],
        'getNetworkPoliciesByClient' => [
            'application/json',
        ],
        'getNetworkSettings' => [
            'application/json',
        ],
        'getNetworkSnmp' => [
            'application/json',
        ],
        'getNetworkSplashLoginAttempts' => [
            'application/json',
        ],
        'getNetworkSyslogServers' => [
            'application/json',
        ],
        'getNetworkTopologyLinkLayer' => [
            'application/json',
        ],
        'getNetworkTraffic' => [
            'application/json',
        ],
        'getNetworkTrafficAnalysis' => [
            'application/json',
        ],
        'getNetworkTrafficShapingApplicationCategories' => [
            'application/json',
        ],
        'getNetworkTrafficShapingDscpTaggingOptions' => [
            'application/json',
        ],
        'getNetworkVlanProfile' => [
            'application/json',
        ],
        'getNetworkVlanProfiles' => [
            'application/json',
        ],
        'getNetworkVlanProfilesAssignmentsByDevice' => [
            'application/json',
        ],
        'getNetworkWebhooksHttpServer' => [
            'application/json',
        ],
        'getNetworkWebhooksHttpServers' => [
            'application/json',
        ],
        'getNetworkWebhooksPayloadTemplate' => [
            'application/json',
        ],
        'getNetworkWebhooksPayloadTemplates' => [
            'application/json',
        ],
        'getNetworkWebhooksWebhookTest' => [
            'application/json',
        ],
        'getOrganizationIntegrationsXdrNetworks' => [
            'application/json',
        ],
        'getOrganizationInventoryOnboardingCloudMonitoringNetworks' => [
            'application/json',
        ],
        'getOrganizationNetworks' => [
            'application/json',
        ],
        'getOrganizationSummaryTopNetworksByStatus' => [
            'application/json',
        ],
        'provisionNetworkClients' => [
            'application/json',
        ],
        'publishNetworkFloorPlansAutoLocateJob' => [
            'application/json',
        ],
        'reassignNetworkVlanProfilesAssignments' => [
            'application/json',
        ],
        'recalculateNetworkFloorPlansAutoLocateJob' => [
            'application/json',
        ],
        'removeNetworkDevices' => [
            'application/json',
        ],
        'rollbacksNetworkFirmwareUpgradesStagedEvents' => [
            'application/json',
        ],
        'splitNetwork' => [
            'application/json',
        ],
        'unbindNetwork' => [
            'application/json',
        ],
        'updateNetwork' => [
            'application/json',
        ],
        'updateNetworkAlertsSettings' => [
            'application/json',
        ],
        'updateNetworkClientPolicy' => [
            'application/json',
        ],
        'updateNetworkClientSplashAuthorizationStatus' => [
            'application/json',
        ],
        'updateNetworkFirmwareUpgrades' => [
            'application/json',
        ],
        'updateNetworkFirmwareUpgradesStagedEvents' => [
            'application/json',
        ],
        'updateNetworkFirmwareUpgradesStagedGroup' => [
            'application/json',
        ],
        'updateNetworkFirmwareUpgradesStagedStages' => [
            'application/json',
        ],
        'updateNetworkFloorPlan' => [
            'application/json',
        ],
        'updateNetworkGroupPolicy' => [
            'application/json',
        ],
        'updateNetworkMerakiAuthUser' => [
            'application/json',
        ],
        'updateNetworkMqttBroker' => [
            'application/json',
        ],
        'updateNetworkNetflow' => [
            'application/json',
        ],
        'updateNetworkSettings' => [
            'application/json',
        ],
        'updateNetworkSnmp' => [
            'application/json',
        ],
        'updateNetworkSyslogServers' => [
            'application/json',
        ],
        'updateNetworkTrafficAnalysis' => [
            'application/json',
        ],
        'updateNetworkVlanProfile' => [
            'application/json',
        ],
        'updateNetworkWebhooksHttpServer' => [
            'application/json',
        ],
        'updateNetworkWebhooksPayloadTemplate' => [
            'application/json',
        ],
        'vmxNetworkDevicesClaim' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation batchNetworkFloorPlansAutoLocateJobs
     *
     * Schedule auto locate jobs for one or more floor plans in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansAutoLocateJobsRequest $batch_network_floor_plans_auto_locate_jobs_request batch_network_floor_plans_auto_locate_jobs_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\BatchNetworkFloorPlansAutoLocateJobs200Response
     */
    public function batchNetworkFloorPlansAutoLocateJobs($network_id, $batch_network_floor_plans_auto_locate_jobs_request, string $contentType = self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'][0])
    {
        list($response) = $this->batchNetworkFloorPlansAutoLocateJobsWithHttpInfo($network_id, $batch_network_floor_plans_auto_locate_jobs_request, $contentType);
        return $response;
    }

    /**
     * Operation batchNetworkFloorPlansAutoLocateJobsWithHttpInfo
     *
     * Schedule auto locate jobs for one or more floor plans in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansAutoLocateJobsRequest $batch_network_floor_plans_auto_locate_jobs_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\BatchNetworkFloorPlansAutoLocateJobs200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function batchNetworkFloorPlansAutoLocateJobsWithHttpInfo($network_id, $batch_network_floor_plans_auto_locate_jobs_request, string $contentType = self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'][0])
    {
        $request = $this->batchNetworkFloorPlansAutoLocateJobsRequest($network_id, $batch_network_floor_plans_auto_locate_jobs_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\BatchNetworkFloorPlansAutoLocateJobs200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\BatchNetworkFloorPlansAutoLocateJobs200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\BatchNetworkFloorPlansAutoLocateJobs200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\BatchNetworkFloorPlansAutoLocateJobs200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\BatchNetworkFloorPlansAutoLocateJobs200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation batchNetworkFloorPlansAutoLocateJobsAsync
     *
     * Schedule auto locate jobs for one or more floor plans in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansAutoLocateJobsRequest $batch_network_floor_plans_auto_locate_jobs_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchNetworkFloorPlansAutoLocateJobsAsync($network_id, $batch_network_floor_plans_auto_locate_jobs_request, string $contentType = self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'][0])
    {
        return $this->batchNetworkFloorPlansAutoLocateJobsAsyncWithHttpInfo($network_id, $batch_network_floor_plans_auto_locate_jobs_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchNetworkFloorPlansAutoLocateJobsAsyncWithHttpInfo
     *
     * Schedule auto locate jobs for one or more floor plans in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansAutoLocateJobsRequest $batch_network_floor_plans_auto_locate_jobs_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchNetworkFloorPlansAutoLocateJobsAsyncWithHttpInfo($network_id, $batch_network_floor_plans_auto_locate_jobs_request, string $contentType = self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'][0])
    {
        $returnType = '\Meraki\Model\BatchNetworkFloorPlansAutoLocateJobs200Response';
        $request = $this->batchNetworkFloorPlansAutoLocateJobsRequest($network_id, $batch_network_floor_plans_auto_locate_jobs_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batchNetworkFloorPlansAutoLocateJobs'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansAutoLocateJobsRequest $batch_network_floor_plans_auto_locate_jobs_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function batchNetworkFloorPlansAutoLocateJobsRequest($network_id, $batch_network_floor_plans_auto_locate_jobs_request, string $contentType = self::contentTypes['batchNetworkFloorPlansAutoLocateJobs'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling batchNetworkFloorPlansAutoLocateJobs'
            );
        }

        // verify the required parameter 'batch_network_floor_plans_auto_locate_jobs_request' is set
        if ($batch_network_floor_plans_auto_locate_jobs_request === null || (is_array($batch_network_floor_plans_auto_locate_jobs_request) && count($batch_network_floor_plans_auto_locate_jobs_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch_network_floor_plans_auto_locate_jobs_request when calling batchNetworkFloorPlansAutoLocateJobs'
            );
        }


        $resourcePath = '/networks/{networkId}/floorPlans/autoLocate/jobs/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_network_floor_plans_auto_locate_jobs_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_network_floor_plans_auto_locate_jobs_request));
            } else {
                $httpBody = $batch_network_floor_plans_auto_locate_jobs_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation batchNetworkFloorPlansDevicesUpdate
     *
     * Update floorplan assignments for a batch of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response
     */
    public function batchNetworkFloorPlansDevicesUpdate($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {
        list($response) = $this->batchNetworkFloorPlansDevicesUpdateWithHttpInfo($network_id, $batch_network_floor_plans_devices_update_request, $contentType);
        return $response;
    }

    /**
     * Operation batchNetworkFloorPlansDevicesUpdateWithHttpInfo
     *
     * Update floorplan assignments for a batch of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function batchNetworkFloorPlansDevicesUpdateWithHttpInfo($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {
        $request = $this->batchNetworkFloorPlansDevicesUpdateRequest($network_id, $batch_network_floor_plans_devices_update_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation batchNetworkFloorPlansDevicesUpdateAsync
     *
     * Update floorplan assignments for a batch of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchNetworkFloorPlansDevicesUpdateAsync($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {
        return $this->batchNetworkFloorPlansDevicesUpdateAsyncWithHttpInfo($network_id, $batch_network_floor_plans_devices_update_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchNetworkFloorPlansDevicesUpdateAsyncWithHttpInfo
     *
     * Update floorplan assignments for a batch of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchNetworkFloorPlansDevicesUpdateAsyncWithHttpInfo($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {
        $returnType = '\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response';
        $request = $this->batchNetworkFloorPlansDevicesUpdateRequest($network_id, $batch_network_floor_plans_devices_update_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batchNetworkFloorPlansDevicesUpdate'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function batchNetworkFloorPlansDevicesUpdateRequest($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling batchNetworkFloorPlansDevicesUpdate'
            );
        }

        // verify the required parameter 'batch_network_floor_plans_devices_update_request' is set
        if ($batch_network_floor_plans_devices_update_request === null || (is_array($batch_network_floor_plans_devices_update_request) && count($batch_network_floor_plans_devices_update_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch_network_floor_plans_devices_update_request when calling batchNetworkFloorPlansDevicesUpdate'
            );
        }


        $resourcePath = '/networks/{networkId}/floorPlans/devices/batchUpdate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_network_floor_plans_devices_update_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_network_floor_plans_devices_update_request));
            } else {
                $httpBody = $batch_network_floor_plans_devices_update_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bindNetwork
     *
     * Bind a network to a template.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BindNetworkRequest $bind_network_request bind_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bindNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\BindNetwork200Response
     */
    public function bindNetwork($network_id, $bind_network_request, string $contentType = self::contentTypes['bindNetwork'][0])
    {
        list($response) = $this->bindNetworkWithHttpInfo($network_id, $bind_network_request, $contentType);
        return $response;
    }

    /**
     * Operation bindNetworkWithHttpInfo
     *
     * Bind a network to a template.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BindNetworkRequest $bind_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bindNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\BindNetwork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function bindNetworkWithHttpInfo($network_id, $bind_network_request, string $contentType = self::contentTypes['bindNetwork'][0])
    {
        $request = $this->bindNetworkRequest($network_id, $bind_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\BindNetwork200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\BindNetwork200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\BindNetwork200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\BindNetwork200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\BindNetwork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bindNetworkAsync
     *
     * Bind a network to a template.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BindNetworkRequest $bind_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bindNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bindNetworkAsync($network_id, $bind_network_request, string $contentType = self::contentTypes['bindNetwork'][0])
    {
        return $this->bindNetworkAsyncWithHttpInfo($network_id, $bind_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bindNetworkAsyncWithHttpInfo
     *
     * Bind a network to a template.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BindNetworkRequest $bind_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bindNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bindNetworkAsyncWithHttpInfo($network_id, $bind_network_request, string $contentType = self::contentTypes['bindNetwork'][0])
    {
        $returnType = '\Meraki\Model\BindNetwork200Response';
        $request = $this->bindNetworkRequest($network_id, $bind_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bindNetwork'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BindNetworkRequest $bind_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bindNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bindNetworkRequest($network_id, $bind_network_request, string $contentType = self::contentTypes['bindNetwork'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling bindNetwork'
            );
        }

        // verify the required parameter 'bind_network_request' is set
        if ($bind_network_request === null || (is_array($bind_network_request) && count($bind_network_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bind_network_request when calling bindNetwork'
            );
        }


        $resourcePath = '/networks/{networkId}/bind';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bind_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bind_network_request));
            } else {
                $httpBody = $bind_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelNetworkFloorPlansAutoLocateJob
     *
     * Cancel a scheduled or running auto locate job
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelNetworkFloorPlansAutoLocateJob($network_id, $job_id, string $contentType = self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'][0])
    {
        $this->cancelNetworkFloorPlansAutoLocateJobWithHttpInfo($network_id, $job_id, $contentType);
    }

    /**
     * Operation cancelNetworkFloorPlansAutoLocateJobWithHttpInfo
     *
     * Cancel a scheduled or running auto locate job
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelNetworkFloorPlansAutoLocateJobWithHttpInfo($network_id, $job_id, string $contentType = self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'][0])
    {
        $request = $this->cancelNetworkFloorPlansAutoLocateJobRequest($network_id, $job_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cancelNetworkFloorPlansAutoLocateJobAsync
     *
     * Cancel a scheduled or running auto locate job
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelNetworkFloorPlansAutoLocateJobAsync($network_id, $job_id, string $contentType = self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'][0])
    {
        return $this->cancelNetworkFloorPlansAutoLocateJobAsyncWithHttpInfo($network_id, $job_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelNetworkFloorPlansAutoLocateJobAsyncWithHttpInfo
     *
     * Cancel a scheduled or running auto locate job
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelNetworkFloorPlansAutoLocateJobAsyncWithHttpInfo($network_id, $job_id, string $contentType = self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'][0])
    {
        $returnType = '';
        $request = $this->cancelNetworkFloorPlansAutoLocateJobRequest($network_id, $job_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelNetworkFloorPlansAutoLocateJob'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelNetworkFloorPlansAutoLocateJobRequest($network_id, $job_id, string $contentType = self::contentTypes['cancelNetworkFloorPlansAutoLocateJob'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling cancelNetworkFloorPlansAutoLocateJob'
            );
        }

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling cancelNetworkFloorPlansAutoLocateJob'
            );
        }


        $resourcePath = '/networks/{networkId}/floorPlans/autoLocate/jobs/{jobId}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation claimNetworkDevices
     *
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\ClaimNetworkDevices200Response
     */
    public function claimNetworkDevices($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {
        list($response) = $this->claimNetworkDevicesWithHttpInfo($network_id, $claim_network_devices_request, $add_atomically, $contentType);
        return $response;
    }

    /**
     * Operation claimNetworkDevicesWithHttpInfo
     *
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\ClaimNetworkDevices200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function claimNetworkDevicesWithHttpInfo($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {
        $request = $this->claimNetworkDevicesRequest($network_id, $claim_network_devices_request, $add_atomically, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\ClaimNetworkDevices200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\ClaimNetworkDevices200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\ClaimNetworkDevices200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\ClaimNetworkDevices200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\ClaimNetworkDevices200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation claimNetworkDevicesAsync
     *
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function claimNetworkDevicesAsync($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {
        return $this->claimNetworkDevicesAsyncWithHttpInfo($network_id, $claim_network_devices_request, $add_atomically, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation claimNetworkDevicesAsyncWithHttpInfo
     *
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function claimNetworkDevicesAsyncWithHttpInfo($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {
        $returnType = '\Meraki\Model\ClaimNetworkDevices200Response';
        $request = $this->claimNetworkDevicesRequest($network_id, $claim_network_devices_request, $add_atomically, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'claimNetworkDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function claimNetworkDevicesRequest($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling claimNetworkDevices'
            );
        }

        // verify the required parameter 'claim_network_devices_request' is set
        if ($claim_network_devices_request === null || (is_array($claim_network_devices_request) && count($claim_network_devices_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $claim_network_devices_request when calling claimNetworkDevices'
            );
        }



        $resourcePath = '/networks/{networkId}/devices/claim';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_atomically,
            'addAtomically', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($claim_network_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($claim_network_devices_request));
            } else {
                $httpBody = $claim_network_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation combineOrganizationNetworks
     *
     * Combine multiple networks into a single network
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CombineOrganizationNetworksRequest $combine_organization_networks_request combine_organization_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combineOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CombineOrganizationNetworks200Response
     */
    public function combineOrganizationNetworks($organization_id, $combine_organization_networks_request, string $contentType = self::contentTypes['combineOrganizationNetworks'][0])
    {
        list($response) = $this->combineOrganizationNetworksWithHttpInfo($organization_id, $combine_organization_networks_request, $contentType);
        return $response;
    }

    /**
     * Operation combineOrganizationNetworksWithHttpInfo
     *
     * Combine multiple networks into a single network
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CombineOrganizationNetworksRequest $combine_organization_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combineOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CombineOrganizationNetworks200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function combineOrganizationNetworksWithHttpInfo($organization_id, $combine_organization_networks_request, string $contentType = self::contentTypes['combineOrganizationNetworks'][0])
    {
        $request = $this->combineOrganizationNetworksRequest($organization_id, $combine_organization_networks_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CombineOrganizationNetworks200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CombineOrganizationNetworks200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CombineOrganizationNetworks200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CombineOrganizationNetworks200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CombineOrganizationNetworks200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation combineOrganizationNetworksAsync
     *
     * Combine multiple networks into a single network
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CombineOrganizationNetworksRequest $combine_organization_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combineOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function combineOrganizationNetworksAsync($organization_id, $combine_organization_networks_request, string $contentType = self::contentTypes['combineOrganizationNetworks'][0])
    {
        return $this->combineOrganizationNetworksAsyncWithHttpInfo($organization_id, $combine_organization_networks_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation combineOrganizationNetworksAsyncWithHttpInfo
     *
     * Combine multiple networks into a single network
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CombineOrganizationNetworksRequest $combine_organization_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combineOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function combineOrganizationNetworksAsyncWithHttpInfo($organization_id, $combine_organization_networks_request, string $contentType = self::contentTypes['combineOrganizationNetworks'][0])
    {
        $returnType = '\Meraki\Model\CombineOrganizationNetworks200Response';
        $request = $this->combineOrganizationNetworksRequest($organization_id, $combine_organization_networks_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'combineOrganizationNetworks'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CombineOrganizationNetworksRequest $combine_organization_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['combineOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function combineOrganizationNetworksRequest($organization_id, $combine_organization_networks_request, string $contentType = self::contentTypes['combineOrganizationNetworks'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling combineOrganizationNetworks'
            );
        }

        // verify the required parameter 'combine_organization_networks_request' is set
        if ($combine_organization_networks_request === null || (is_array($combine_organization_networks_request) && count($combine_organization_networks_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $combine_organization_networks_request when calling combineOrganizationNetworks'
            );
        }


        $resourcePath = '/organizations/{organizationId}/networks/combine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($combine_organization_networks_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($combine_organization_networks_request));
            } else {
                $httpBody = $combine_organization_networks_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkFirmwareUpgradesRollback
     *
     * Rollback a Firmware Upgrade For A Network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesRollbackRequest $create_network_firmware_upgrades_rollback_request create_network_firmware_upgrades_rollback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesRollback'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateNetworkFirmwareUpgradesRollback200Response
     */
    public function createNetworkFirmwareUpgradesRollback($network_id, $create_network_firmware_upgrades_rollback_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesRollback'][0])
    {
        list($response) = $this->createNetworkFirmwareUpgradesRollbackWithHttpInfo($network_id, $create_network_firmware_upgrades_rollback_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkFirmwareUpgradesRollbackWithHttpInfo
     *
     * Rollback a Firmware Upgrade For A Network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesRollbackRequest $create_network_firmware_upgrades_rollback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesRollback'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateNetworkFirmwareUpgradesRollback200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkFirmwareUpgradesRollbackWithHttpInfo($network_id, $create_network_firmware_upgrades_rollback_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesRollback'][0])
    {
        $request = $this->createNetworkFirmwareUpgradesRollbackRequest($network_id, $create_network_firmware_upgrades_rollback_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CreateNetworkFirmwareUpgradesRollback200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateNetworkFirmwareUpgradesRollback200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateNetworkFirmwareUpgradesRollback200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateNetworkFirmwareUpgradesRollback200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateNetworkFirmwareUpgradesRollback200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkFirmwareUpgradesRollbackAsync
     *
     * Rollback a Firmware Upgrade For A Network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesRollbackRequest $create_network_firmware_upgrades_rollback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesRollback'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkFirmwareUpgradesRollbackAsync($network_id, $create_network_firmware_upgrades_rollback_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesRollback'][0])
    {
        return $this->createNetworkFirmwareUpgradesRollbackAsyncWithHttpInfo($network_id, $create_network_firmware_upgrades_rollback_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkFirmwareUpgradesRollbackAsyncWithHttpInfo
     *
     * Rollback a Firmware Upgrade For A Network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesRollbackRequest $create_network_firmware_upgrades_rollback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesRollback'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkFirmwareUpgradesRollbackAsyncWithHttpInfo($network_id, $create_network_firmware_upgrades_rollback_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesRollback'][0])
    {
        $returnType = '\Meraki\Model\CreateNetworkFirmwareUpgradesRollback200Response';
        $request = $this->createNetworkFirmwareUpgradesRollbackRequest($network_id, $create_network_firmware_upgrades_rollback_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkFirmwareUpgradesRollback'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesRollbackRequest $create_network_firmware_upgrades_rollback_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesRollback'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkFirmwareUpgradesRollbackRequest($network_id, $create_network_firmware_upgrades_rollback_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesRollback'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkFirmwareUpgradesRollback'
            );
        }

        // verify the required parameter 'create_network_firmware_upgrades_rollback_request' is set
        if ($create_network_firmware_upgrades_rollback_request === null || (is_array($create_network_firmware_upgrades_rollback_request) && count($create_network_firmware_upgrades_rollback_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_firmware_upgrades_rollback_request when calling createNetworkFirmwareUpgradesRollback'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/rollbacks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_firmware_upgrades_rollback_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_firmware_upgrades_rollback_request));
            } else {
                $httpBody = $create_network_firmware_upgrades_rollback_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkFirmwareUpgradesStagedEvent
     *
     * Create a Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedEventRequest $create_network_firmware_upgrades_staged_event_request create_network_firmware_upgrades_staged_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response
     */
    public function createNetworkFirmwareUpgradesStagedEvent($network_id, $create_network_firmware_upgrades_staged_event_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'][0])
    {
        list($response) = $this->createNetworkFirmwareUpgradesStagedEventWithHttpInfo($network_id, $create_network_firmware_upgrades_staged_event_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkFirmwareUpgradesStagedEventWithHttpInfo
     *
     * Create a Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedEventRequest $create_network_firmware_upgrades_staged_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkFirmwareUpgradesStagedEventWithHttpInfo($network_id, $create_network_firmware_upgrades_staged_event_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'][0])
    {
        $request = $this->createNetworkFirmwareUpgradesStagedEventRequest($network_id, $create_network_firmware_upgrades_staged_event_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkFirmwareUpgradesStagedEventAsync
     *
     * Create a Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedEventRequest $create_network_firmware_upgrades_staged_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkFirmwareUpgradesStagedEventAsync($network_id, $create_network_firmware_upgrades_staged_event_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'][0])
    {
        return $this->createNetworkFirmwareUpgradesStagedEventAsyncWithHttpInfo($network_id, $create_network_firmware_upgrades_staged_event_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkFirmwareUpgradesStagedEventAsyncWithHttpInfo
     *
     * Create a Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedEventRequest $create_network_firmware_upgrades_staged_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkFirmwareUpgradesStagedEventAsyncWithHttpInfo($network_id, $create_network_firmware_upgrades_staged_event_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
        $request = $this->createNetworkFirmwareUpgradesStagedEventRequest($network_id, $create_network_firmware_upgrades_staged_event_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkFirmwareUpgradesStagedEvent'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedEventRequest $create_network_firmware_upgrades_staged_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkFirmwareUpgradesStagedEventRequest($network_id, $create_network_firmware_upgrades_staged_event_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedEvent'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkFirmwareUpgradesStagedEvent'
            );
        }

        // verify the required parameter 'create_network_firmware_upgrades_staged_event_request' is set
        if ($create_network_firmware_upgrades_staged_event_request === null || (is_array($create_network_firmware_upgrades_staged_event_request) && count($create_network_firmware_upgrades_staged_event_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_firmware_upgrades_staged_event_request when calling createNetworkFirmwareUpgradesStagedEvent'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_firmware_upgrades_staged_event_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_firmware_upgrades_staged_event_request));
            } else {
                $httpBody = $create_network_firmware_upgrades_staged_event_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkFirmwareUpgradesStagedGroup
     *
     * Create a Staged Upgrade Group for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner
     */
    public function createNetworkFirmwareUpgradesStagedGroup($network_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'][0])
    {
        list($response) = $this->createNetworkFirmwareUpgradesStagedGroupWithHttpInfo($network_id, $create_network_firmware_upgrades_staged_group_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkFirmwareUpgradesStagedGroupWithHttpInfo
     *
     * Create a Staged Upgrade Group for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkFirmwareUpgradesStagedGroupWithHttpInfo($network_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'][0])
    {
        $request = $this->createNetworkFirmwareUpgradesStagedGroupRequest($network_id, $create_network_firmware_upgrades_staged_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkFirmwareUpgradesStagedGroupAsync
     *
     * Create a Staged Upgrade Group for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkFirmwareUpgradesStagedGroupAsync($network_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'][0])
    {
        return $this->createNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo($network_id, $create_network_firmware_upgrades_staged_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo
     *
     * Create a Staged Upgrade Group for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo($network_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner';
        $request = $this->createNetworkFirmwareUpgradesStagedGroupRequest($network_id, $create_network_firmware_upgrades_staged_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkFirmwareUpgradesStagedGroup'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkFirmwareUpgradesStagedGroupRequest($network_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['createNetworkFirmwareUpgradesStagedGroup'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkFirmwareUpgradesStagedGroup'
            );
        }

        // verify the required parameter 'create_network_firmware_upgrades_staged_group_request' is set
        if ($create_network_firmware_upgrades_staged_group_request === null || (is_array($create_network_firmware_upgrades_staged_group_request) && count($create_network_firmware_upgrades_staged_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_firmware_upgrades_staged_group_request when calling createNetworkFirmwareUpgradesStagedGroup'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_firmware_upgrades_staged_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_firmware_upgrades_staged_group_request));
            } else {
                $httpBody = $create_network_firmware_upgrades_staged_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkFloorPlan
     *
     * Upload a floor plan
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFloorPlanRequest $create_network_floor_plan_request create_network_floor_plan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFloorPlans200ResponseInner
     */
    public function createNetworkFloorPlan($network_id, $create_network_floor_plan_request, string $contentType = self::contentTypes['createNetworkFloorPlan'][0])
    {
        list($response) = $this->createNetworkFloorPlanWithHttpInfo($network_id, $create_network_floor_plan_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkFloorPlanWithHttpInfo
     *
     * Upload a floor plan
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFloorPlanRequest $create_network_floor_plan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFloorPlans200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkFloorPlanWithHttpInfo($network_id, $create_network_floor_plan_request, string $contentType = self::contentTypes['createNetworkFloorPlan'][0])
    {
        $request = $this->createNetworkFloorPlanRequest($network_id, $create_network_floor_plan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFloorPlans200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFloorPlans200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkFloorPlanAsync
     *
     * Upload a floor plan
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFloorPlanRequest $create_network_floor_plan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkFloorPlanAsync($network_id, $create_network_floor_plan_request, string $contentType = self::contentTypes['createNetworkFloorPlan'][0])
    {
        return $this->createNetworkFloorPlanAsyncWithHttpInfo($network_id, $create_network_floor_plan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkFloorPlanAsyncWithHttpInfo
     *
     * Upload a floor plan
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFloorPlanRequest $create_network_floor_plan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkFloorPlanAsyncWithHttpInfo($network_id, $create_network_floor_plan_request, string $contentType = self::contentTypes['createNetworkFloorPlan'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner';
        $request = $this->createNetworkFloorPlanRequest($network_id, $create_network_floor_plan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkFloorPlan'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkFloorPlanRequest $create_network_floor_plan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkFloorPlanRequest($network_id, $create_network_floor_plan_request, string $contentType = self::contentTypes['createNetworkFloorPlan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkFloorPlan'
            );
        }

        // verify the required parameter 'create_network_floor_plan_request' is set
        if ($create_network_floor_plan_request === null || (is_array($create_network_floor_plan_request) && count($create_network_floor_plan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_floor_plan_request when calling createNetworkFloorPlan'
            );
        }


        $resourcePath = '/networks/{networkId}/floorPlans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_floor_plan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_floor_plan_request));
            } else {
                $httpBody = $create_network_floor_plan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkGroupPolicy
     *
     * Create a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkGroupPolicyRequest $create_network_group_policy_request create_network_group_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkGroupPolicies200ResponseInner
     */
    public function createNetworkGroupPolicy($network_id, $create_network_group_policy_request, string $contentType = self::contentTypes['createNetworkGroupPolicy'][0])
    {
        list($response) = $this->createNetworkGroupPolicyWithHttpInfo($network_id, $create_network_group_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkGroupPolicyWithHttpInfo
     *
     * Create a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkGroupPolicyRequest $create_network_group_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkGroupPolicies200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkGroupPolicyWithHttpInfo($network_id, $create_network_group_policy_request, string $contentType = self::contentTypes['createNetworkGroupPolicy'][0])
    {
        $request = $this->createNetworkGroupPolicyRequest($network_id, $create_network_group_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkGroupPolicies200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkGroupPolicies200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkGroupPolicyAsync
     *
     * Create a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkGroupPolicyRequest $create_network_group_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkGroupPolicyAsync($network_id, $create_network_group_policy_request, string $contentType = self::contentTypes['createNetworkGroupPolicy'][0])
    {
        return $this->createNetworkGroupPolicyAsyncWithHttpInfo($network_id, $create_network_group_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkGroupPolicyAsyncWithHttpInfo
     *
     * Create a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkGroupPolicyRequest $create_network_group_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkGroupPolicyAsyncWithHttpInfo($network_id, $create_network_group_policy_request, string $contentType = self::contentTypes['createNetworkGroupPolicy'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner';
        $request = $this->createNetworkGroupPolicyRequest($network_id, $create_network_group_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkGroupPolicy'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkGroupPolicyRequest $create_network_group_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkGroupPolicyRequest($network_id, $create_network_group_policy_request, string $contentType = self::contentTypes['createNetworkGroupPolicy'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkGroupPolicy'
            );
        }

        // verify the required parameter 'create_network_group_policy_request' is set
        if ($create_network_group_policy_request === null || (is_array($create_network_group_policy_request) && count($create_network_group_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_group_policy_request when calling createNetworkGroupPolicy'
            );
        }


        $resourcePath = '/networks/{networkId}/groupPolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_group_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_group_policy_request));
            } else {
                $httpBody = $create_network_group_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkMerakiAuthUser
     *
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner
     */
    public function createNetworkMerakiAuthUser($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {
        list($response) = $this->createNetworkMerakiAuthUserWithHttpInfo($network_id, $create_network_meraki_auth_user_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkMerakiAuthUserWithHttpInfo
     *
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkMerakiAuthUserWithHttpInfo($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {
        $request = $this->createNetworkMerakiAuthUserRequest($network_id, $create_network_meraki_auth_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkMerakiAuthUserAsync
     *
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkMerakiAuthUserAsync($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {
        return $this->createNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $create_network_meraki_auth_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkMerakiAuthUserAsyncWithHttpInfo
     *
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
        $request = $this->createNetworkMerakiAuthUserRequest($network_id, $create_network_meraki_auth_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkMerakiAuthUser'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMerakiAuthUserRequest $create_network_meraki_auth_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkMerakiAuthUserRequest($network_id, $create_network_meraki_auth_user_request, string $contentType = self::contentTypes['createNetworkMerakiAuthUser'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkMerakiAuthUser'
            );
        }

        // verify the required parameter 'create_network_meraki_auth_user_request' is set
        if ($create_network_meraki_auth_user_request === null || (is_array($create_network_meraki_auth_user_request) && count($create_network_meraki_auth_user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_meraki_auth_user_request when calling createNetworkMerakiAuthUser'
            );
        }


        $resourcePath = '/networks/{networkId}/merakiAuthUsers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_meraki_auth_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_meraki_auth_user_request));
            } else {
                $httpBody = $create_network_meraki_auth_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkMqttBroker
     *
     * Add an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMqttBrokerRequest $create_network_mqtt_broker_request create_network_mqtt_broker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMqttBrokers200ResponseInner
     */
    public function createNetworkMqttBroker($network_id, $create_network_mqtt_broker_request, string $contentType = self::contentTypes['createNetworkMqttBroker'][0])
    {
        list($response) = $this->createNetworkMqttBrokerWithHttpInfo($network_id, $create_network_mqtt_broker_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkMqttBrokerWithHttpInfo
     *
     * Add an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMqttBrokerRequest $create_network_mqtt_broker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMqttBrokers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkMqttBrokerWithHttpInfo($network_id, $create_network_mqtt_broker_request, string $contentType = self::contentTypes['createNetworkMqttBroker'][0])
    {
        $request = $this->createNetworkMqttBrokerRequest($network_id, $create_network_mqtt_broker_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkMqttBrokers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMqttBrokers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkMqttBrokerAsync
     *
     * Add an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMqttBrokerRequest $create_network_mqtt_broker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkMqttBrokerAsync($network_id, $create_network_mqtt_broker_request, string $contentType = self::contentTypes['createNetworkMqttBroker'][0])
    {
        return $this->createNetworkMqttBrokerAsyncWithHttpInfo($network_id, $create_network_mqtt_broker_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkMqttBrokerAsyncWithHttpInfo
     *
     * Add an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMqttBrokerRequest $create_network_mqtt_broker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkMqttBrokerAsyncWithHttpInfo($network_id, $create_network_mqtt_broker_request, string $contentType = self::contentTypes['createNetworkMqttBroker'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner';
        $request = $this->createNetworkMqttBrokerRequest($network_id, $create_network_mqtt_broker_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkMqttBroker'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkMqttBrokerRequest $create_network_mqtt_broker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkMqttBrokerRequest($network_id, $create_network_mqtt_broker_request, string $contentType = self::contentTypes['createNetworkMqttBroker'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkMqttBroker'
            );
        }

        // verify the required parameter 'create_network_mqtt_broker_request' is set
        if ($create_network_mqtt_broker_request === null || (is_array($create_network_mqtt_broker_request) && count($create_network_mqtt_broker_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_mqtt_broker_request when calling createNetworkMqttBroker'
            );
        }


        $resourcePath = '/networks/{networkId}/mqttBrokers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_mqtt_broker_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_mqtt_broker_request));
            } else {
                $httpBody = $create_network_mqtt_broker_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkPiiRequest
     *
     * Submit a new delete or restrict processing PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkPiiRequestRequest|null $create_network_pii_request_request create_network_pii_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkPiiRequests200ResponseInner
     */
    public function createNetworkPiiRequest($network_id, $create_network_pii_request_request = null, string $contentType = self::contentTypes['createNetworkPiiRequest'][0])
    {
        list($response) = $this->createNetworkPiiRequestWithHttpInfo($network_id, $create_network_pii_request_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkPiiRequestWithHttpInfo
     *
     * Submit a new delete or restrict processing PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkPiiRequestRequest|null $create_network_pii_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkPiiRequests200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkPiiRequestWithHttpInfo($network_id, $create_network_pii_request_request = null, string $contentType = self::contentTypes['createNetworkPiiRequest'][0])
    {
        $request = $this->createNetworkPiiRequestRequest($network_id, $create_network_pii_request_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkPiiRequests200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkPiiRequests200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkPiiRequests200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkPiiRequests200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkPiiRequests200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkPiiRequestAsync
     *
     * Submit a new delete or restrict processing PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkPiiRequestRequest|null $create_network_pii_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkPiiRequestAsync($network_id, $create_network_pii_request_request = null, string $contentType = self::contentTypes['createNetworkPiiRequest'][0])
    {
        return $this->createNetworkPiiRequestAsyncWithHttpInfo($network_id, $create_network_pii_request_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkPiiRequestAsyncWithHttpInfo
     *
     * Submit a new delete or restrict processing PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkPiiRequestRequest|null $create_network_pii_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkPiiRequestAsyncWithHttpInfo($network_id, $create_network_pii_request_request = null, string $contentType = self::contentTypes['createNetworkPiiRequest'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkPiiRequests200ResponseInner';
        $request = $this->createNetworkPiiRequestRequest($network_id, $create_network_pii_request_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkPiiRequest'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkPiiRequestRequest|null $create_network_pii_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkPiiRequestRequest($network_id, $create_network_pii_request_request = null, string $contentType = self::contentTypes['createNetworkPiiRequest'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkPiiRequest'
            );
        }



        $resourcePath = '/networks/{networkId}/pii/requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_pii_request_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_pii_request_request));
            } else {
                $httpBody = $create_network_pii_request_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkVlanProfile
     *
     * Create a VLAN profile for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfiles200ResponseInner
     */
    public function createNetworkVlanProfile($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {
        list($response) = $this->createNetworkVlanProfileWithHttpInfo($network_id, $create_network_vlan_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkVlanProfileWithHttpInfo
     *
     * Create a VLAN profile for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkVlanProfileWithHttpInfo($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {
        $request = $this->createNetworkVlanProfileRequest($network_id, $create_network_vlan_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkVlanProfileAsync
     *
     * Create a VLAN profile for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkVlanProfileAsync($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {
        return $this->createNetworkVlanProfileAsyncWithHttpInfo($network_id, $create_network_vlan_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkVlanProfileAsyncWithHttpInfo
     *
     * Create a VLAN profile for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkVlanProfileAsyncWithHttpInfo($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
        $request = $this->createNetworkVlanProfileRequest($network_id, $create_network_vlan_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkVlanProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkVlanProfileRequest $create_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkVlanProfileRequest($network_id, $create_network_vlan_profile_request, string $contentType = self::contentTypes['createNetworkVlanProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkVlanProfile'
            );
        }

        // verify the required parameter 'create_network_vlan_profile_request' is set
        if ($create_network_vlan_profile_request === null || (is_array($create_network_vlan_profile_request) && count($create_network_vlan_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_vlan_profile_request when calling createNetworkVlanProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_vlan_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_vlan_profile_request));
            } else {
                $httpBody = $create_network_vlan_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkWebhooksHttpServer
     *
     * Add an HTTP server to a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner
     */
    public function createNetworkWebhooksHttpServer($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {
        list($response) = $this->createNetworkWebhooksHttpServerWithHttpInfo($network_id, $create_network_webhooks_http_server_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkWebhooksHttpServerWithHttpInfo
     *
     * Add an HTTP server to a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkWebhooksHttpServerWithHttpInfo($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {
        $request = $this->createNetworkWebhooksHttpServerRequest($network_id, $create_network_webhooks_http_server_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkWebhooksHttpServerAsync
     *
     * Add an HTTP server to a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksHttpServerAsync($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {
        return $this->createNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $create_network_webhooks_http_server_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkWebhooksHttpServerAsyncWithHttpInfo
     *
     * Add an HTTP server to a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
        $request = $this->createNetworkWebhooksHttpServerRequest($network_id, $create_network_webhooks_http_server_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkWebhooksHttpServer'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkWebhooksHttpServerRequest($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkWebhooksHttpServer'
            );
        }

        // verify the required parameter 'create_network_webhooks_http_server_request' is set
        if ($create_network_webhooks_http_server_request === null || (is_array($create_network_webhooks_http_server_request) && count($create_network_webhooks_http_server_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_webhooks_http_server_request when calling createNetworkWebhooksHttpServer'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/httpServers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_webhooks_http_server_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_webhooks_http_server_request));
            } else {
                $httpBody = $create_network_webhooks_http_server_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkWebhooksPayloadTemplate
     *
     * Create a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner
     */
    public function createNetworkWebhooksPayloadTemplate($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {
        list($response) = $this->createNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $create_network_webhooks_payload_template_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkWebhooksPayloadTemplateWithHttpInfo
     *
     * Create a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {
        $request = $this->createNetworkWebhooksPayloadTemplateRequest($network_id, $create_network_webhooks_payload_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkWebhooksPayloadTemplateAsync
     *
     * Create a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksPayloadTemplateAsync($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {
        return $this->createNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $create_network_webhooks_payload_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkWebhooksPayloadTemplateAsyncWithHttpInfo
     *
     * Create a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
        $request = $this->createNetworkWebhooksPayloadTemplateRequest($network_id, $create_network_webhooks_payload_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkWebhooksPayloadTemplate'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkWebhooksPayloadTemplateRequest($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkWebhooksPayloadTemplate'
            );
        }

        // verify the required parameter 'create_network_webhooks_payload_template_request' is set
        if ($create_network_webhooks_payload_template_request === null || (is_array($create_network_webhooks_payload_template_request) && count($create_network_webhooks_payload_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_webhooks_payload_template_request when calling createNetworkWebhooksPayloadTemplate'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_webhooks_payload_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_webhooks_payload_template_request));
            } else {
                $httpBody = $create_network_webhooks_payload_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkWebhooksWebhookTest
     *
     * Send a test webhook for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateNetworkWebhooksWebhookTest201Response
     */
    public function createNetworkWebhooksWebhookTest($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {
        list($response) = $this->createNetworkWebhooksWebhookTestWithHttpInfo($network_id, $create_network_webhooks_webhook_test_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkWebhooksWebhookTestWithHttpInfo
     *
     * Send a test webhook for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateNetworkWebhooksWebhookTest201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkWebhooksWebhookTestWithHttpInfo($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {
        $request = $this->createNetworkWebhooksWebhookTestRequest($network_id, $create_network_webhooks_webhook_test_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkWebhooksWebhookTestAsync
     *
     * Send a test webhook for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksWebhookTestAsync($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {
        return $this->createNetworkWebhooksWebhookTestAsyncWithHttpInfo($network_id, $create_network_webhooks_webhook_test_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkWebhooksWebhookTestAsyncWithHttpInfo
     *
     * Send a test webhook for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksWebhookTestAsyncWithHttpInfo($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {
        $returnType = '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response';
        $request = $this->createNetworkWebhooksWebhookTestRequest($network_id, $create_network_webhooks_webhook_test_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkWebhooksWebhookTest'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkWebhooksWebhookTestRequest($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkWebhooksWebhookTest'
            );
        }

        // verify the required parameter 'create_network_webhooks_webhook_test_request' is set
        if ($create_network_webhooks_webhook_test_request === null || (is_array($create_network_webhooks_webhook_test_request) && count($create_network_webhooks_webhook_test_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_webhooks_webhook_test_request when calling createNetworkWebhooksWebhookTest'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/webhookTests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_webhooks_webhook_test_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_webhooks_webhook_test_request));
            } else {
                $httpBody = $create_network_webhooks_webhook_test_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationNetwork
     *
     * Create a network
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationNetworkRequest $create_organization_network_request create_organization_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetwork200Response
     */
    public function createOrganizationNetwork($organization_id, $create_organization_network_request, string $contentType = self::contentTypes['createOrganizationNetwork'][0])
    {
        list($response) = $this->createOrganizationNetworkWithHttpInfo($organization_id, $create_organization_network_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationNetworkWithHttpInfo
     *
     * Create a network
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationNetworkRequest $create_organization_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetwork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationNetworkWithHttpInfo($organization_id, $create_organization_network_request, string $contentType = self::contentTypes['createOrganizationNetwork'][0])
    {
        $request = $this->createOrganizationNetworkRequest($organization_id, $create_organization_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetwork200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetwork200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetwork200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetwork200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetwork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationNetworkAsync
     *
     * Create a network
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationNetworkRequest $create_organization_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationNetworkAsync($organization_id, $create_organization_network_request, string $contentType = self::contentTypes['createOrganizationNetwork'][0])
    {
        return $this->createOrganizationNetworkAsyncWithHttpInfo($organization_id, $create_organization_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationNetworkAsyncWithHttpInfo
     *
     * Create a network
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationNetworkRequest $create_organization_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationNetworkAsyncWithHttpInfo($organization_id, $create_organization_network_request, string $contentType = self::contentTypes['createOrganizationNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetNetwork200Response';
        $request = $this->createOrganizationNetworkRequest($organization_id, $create_organization_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationNetwork'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationNetworkRequest $create_organization_network_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationNetworkRequest($organization_id, $create_organization_network_request, string $contentType = self::contentTypes['createOrganizationNetwork'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationNetwork'
            );
        }

        // verify the required parameter 'create_organization_network_request' is set
        if ($create_organization_network_request === null || (is_array($create_organization_network_request) && count($create_organization_network_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_network_request when calling createOrganizationNetwork'
            );
        }


        $resourcePath = '/organizations/{organizationId}/networks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_network_request));
            } else {
                $httpBody = $create_organization_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deferNetworkFirmwareUpgradesStagedEvents
     *
     * Postpone by 1 week all pending staged upgrade stages for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response
     */
    public function deferNetworkFirmwareUpgradesStagedEvents($network_id, string $contentType = self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'][0])
    {
        list($response) = $this->deferNetworkFirmwareUpgradesStagedEventsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation deferNetworkFirmwareUpgradesStagedEventsWithHttpInfo
     *
     * Postpone by 1 week all pending staged upgrade stages for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deferNetworkFirmwareUpgradesStagedEventsWithHttpInfo($network_id, string $contentType = self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'][0])
    {
        $request = $this->deferNetworkFirmwareUpgradesStagedEventsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deferNetworkFirmwareUpgradesStagedEventsAsync
     *
     * Postpone by 1 week all pending staged upgrade stages for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deferNetworkFirmwareUpgradesStagedEventsAsync($network_id, string $contentType = self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'][0])
    {
        return $this->deferNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deferNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo
     *
     * Postpone by 1 week all pending staged upgrade stages for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deferNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
        $request = $this->deferNetworkFirmwareUpgradesStagedEventsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deferNetworkFirmwareUpgradesStagedEvents'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deferNetworkFirmwareUpgradesStagedEventsRequest($network_id, string $contentType = self::contentTypes['deferNetworkFirmwareUpgradesStagedEvents'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deferNetworkFirmwareUpgradesStagedEvents'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/events/defer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetwork
     *
     * Delete a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetwork($network_id, string $contentType = self::contentTypes['deleteNetwork'][0])
    {
        $this->deleteNetworkWithHttpInfo($network_id, $contentType);
    }

    /**
     * Operation deleteNetworkWithHttpInfo
     *
     * Delete a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkWithHttpInfo($network_id, string $contentType = self::contentTypes['deleteNetwork'][0])
    {
        $request = $this->deleteNetworkRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkAsync
     *
     * Delete a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkAsync($network_id, string $contentType = self::contentTypes['deleteNetwork'][0])
    {
        return $this->deleteNetworkAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkAsyncWithHttpInfo
     *
     * Delete a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['deleteNetwork'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetwork'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkRequest($network_id, string $contentType = self::contentTypes['deleteNetwork'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetwork'
            );
        }


        $resourcePath = '/networks/{networkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkFirmwareUpgradesStagedGroup
     *
     * Delete a Staged Upgrade Group
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkFirmwareUpgradesStagedGroup($network_id, $group_id, string $contentType = self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'][0])
    {
        $this->deleteNetworkFirmwareUpgradesStagedGroupWithHttpInfo($network_id, $group_id, $contentType);
    }

    /**
     * Operation deleteNetworkFirmwareUpgradesStagedGroupWithHttpInfo
     *
     * Delete a Staged Upgrade Group
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkFirmwareUpgradesStagedGroupWithHttpInfo($network_id, $group_id, string $contentType = self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'][0])
    {
        $request = $this->deleteNetworkFirmwareUpgradesStagedGroupRequest($network_id, $group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkFirmwareUpgradesStagedGroupAsync
     *
     * Delete a Staged Upgrade Group
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkFirmwareUpgradesStagedGroupAsync($network_id, $group_id, string $contentType = self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'][0])
    {
        return $this->deleteNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo($network_id, $group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo
     *
     * Delete a Staged Upgrade Group
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo($network_id, $group_id, string $contentType = self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkFirmwareUpgradesStagedGroupRequest($network_id, $group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkFirmwareUpgradesStagedGroup'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkFirmwareUpgradesStagedGroupRequest($network_id, $group_id, string $contentType = self::contentTypes['deleteNetworkFirmwareUpgradesStagedGroup'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkFirmwareUpgradesStagedGroup'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling deleteNetworkFirmwareUpgradesStagedGroup'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkFloorPlan
     *
     * Destroy a floor plan
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFloorPlans200ResponseInner
     */
    public function deleteNetworkFloorPlan($network_id, $floor_plan_id, string $contentType = self::contentTypes['deleteNetworkFloorPlan'][0])
    {
        list($response) = $this->deleteNetworkFloorPlanWithHttpInfo($network_id, $floor_plan_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteNetworkFloorPlanWithHttpInfo
     *
     * Destroy a floor plan
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFloorPlans200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkFloorPlanWithHttpInfo($network_id, $floor_plan_id, string $contentType = self::contentTypes['deleteNetworkFloorPlan'][0])
    {
        $request = $this->deleteNetworkFloorPlanRequest($network_id, $floor_plan_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFloorPlans200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFloorPlans200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkFloorPlanAsync
     *
     * Destroy a floor plan
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkFloorPlanAsync($network_id, $floor_plan_id, string $contentType = self::contentTypes['deleteNetworkFloorPlan'][0])
    {
        return $this->deleteNetworkFloorPlanAsyncWithHttpInfo($network_id, $floor_plan_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkFloorPlanAsyncWithHttpInfo
     *
     * Destroy a floor plan
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkFloorPlanAsyncWithHttpInfo($network_id, $floor_plan_id, string $contentType = self::contentTypes['deleteNetworkFloorPlan'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner';
        $request = $this->deleteNetworkFloorPlanRequest($network_id, $floor_plan_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkFloorPlan'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkFloorPlanRequest($network_id, $floor_plan_id, string $contentType = self::contentTypes['deleteNetworkFloorPlan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkFloorPlan'
            );
        }

        // verify the required parameter 'floor_plan_id' is set
        if ($floor_plan_id === null || (is_array($floor_plan_id) && count($floor_plan_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $floor_plan_id when calling deleteNetworkFloorPlan'
            );
        }


        $resourcePath = '/networks/{networkId}/floorPlans/{floorPlanId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($floor_plan_id !== null) {
            $resourcePath = str_replace(
                '{' . 'floorPlanId' . '}',
                ObjectSerializer::toPathValue($floor_plan_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkGroupPolicy
     *
     * Delete a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  bool|null $force If true, the system deletes the GP even if there are active clients using the GP. After deletion, active clients that were assigned to that Group Policy will be left without any policy applied. Default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkGroupPolicy($network_id, $group_policy_id, $force = null, string $contentType = self::contentTypes['deleteNetworkGroupPolicy'][0])
    {
        $this->deleteNetworkGroupPolicyWithHttpInfo($network_id, $group_policy_id, $force, $contentType);
    }

    /**
     * Operation deleteNetworkGroupPolicyWithHttpInfo
     *
     * Delete a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  bool|null $force If true, the system deletes the GP even if there are active clients using the GP. After deletion, active clients that were assigned to that Group Policy will be left without any policy applied. Default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkGroupPolicyWithHttpInfo($network_id, $group_policy_id, $force = null, string $contentType = self::contentTypes['deleteNetworkGroupPolicy'][0])
    {
        $request = $this->deleteNetworkGroupPolicyRequest($network_id, $group_policy_id, $force, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkGroupPolicyAsync
     *
     * Delete a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  bool|null $force If true, the system deletes the GP even if there are active clients using the GP. After deletion, active clients that were assigned to that Group Policy will be left without any policy applied. Default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkGroupPolicyAsync($network_id, $group_policy_id, $force = null, string $contentType = self::contentTypes['deleteNetworkGroupPolicy'][0])
    {
        return $this->deleteNetworkGroupPolicyAsyncWithHttpInfo($network_id, $group_policy_id, $force, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkGroupPolicyAsyncWithHttpInfo
     *
     * Delete a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  bool|null $force If true, the system deletes the GP even if there are active clients using the GP. After deletion, active clients that were assigned to that Group Policy will be left without any policy applied. Default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkGroupPolicyAsyncWithHttpInfo($network_id, $group_policy_id, $force = null, string $contentType = self::contentTypes['deleteNetworkGroupPolicy'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkGroupPolicyRequest($network_id, $group_policy_id, $force, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkGroupPolicy'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  bool|null $force If true, the system deletes the GP even if there are active clients using the GP. After deletion, active clients that were assigned to that Group Policy will be left without any policy applied. Default is false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkGroupPolicyRequest($network_id, $group_policy_id, $force = null, string $contentType = self::contentTypes['deleteNetworkGroupPolicy'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkGroupPolicy'
            );
        }

        // verify the required parameter 'group_policy_id' is set
        if ($group_policy_id === null || (is_array($group_policy_id) && count($group_policy_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_policy_id when calling deleteNetworkGroupPolicy'
            );
        }



        $resourcePath = '/networks/{networkId}/groupPolicies/{groupPolicyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force,
            'force', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($group_policy_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupPolicyId' . '}',
                ObjectSerializer::toPathValue($group_policy_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkMerakiAuthUser
     *
     * Delete an 802.1X RADIUS user, or deauthorize and optionally delete a splash guest or client VPN user.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkMerakiAuthUser($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {
        $this->deleteNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $delete, $contentType);
    }

    /**
     * Operation deleteNetworkMerakiAuthUserWithHttpInfo
     *
     * Delete an 802.1X RADIUS user, or deauthorize and optionally delete a splash guest or client VPN user.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {
        $request = $this->deleteNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $delete, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkMerakiAuthUserAsync
     *
     * Delete an 802.1X RADIUS user, or deauthorize and optionally delete a splash guest or client VPN user.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkMerakiAuthUserAsync($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {
        return $this->deleteNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $delete, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkMerakiAuthUserAsyncWithHttpInfo
     *
     * Delete an 802.1X RADIUS user, or deauthorize and optionally delete a splash guest or client VPN user.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $delete, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkMerakiAuthUser'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  bool|null $delete If the ID supplied is for a splash guest or client VPN user, and that user is not authorized for any other networks in the organization, then also delete the user. 802.1X RADIUS users are always deleted regardless of this optional attribute. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $delete = null, string $contentType = self::contentTypes['deleteNetworkMerakiAuthUser'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkMerakiAuthUser'
            );
        }

        // verify the required parameter 'meraki_auth_user_id' is set
        if ($meraki_auth_user_id === null || (is_array($meraki_auth_user_id) && count($meraki_auth_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meraki_auth_user_id when calling deleteNetworkMerakiAuthUser'
            );
        }



        $resourcePath = '/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delete,
            'delete', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($meraki_auth_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merakiAuthUserId' . '}',
                ObjectSerializer::toPathValue($meraki_auth_user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkMqttBroker
     *
     * Delete an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkMqttBroker($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['deleteNetworkMqttBroker'][0])
    {
        $this->deleteNetworkMqttBrokerWithHttpInfo($network_id, $mqtt_broker_id, $contentType);
    }

    /**
     * Operation deleteNetworkMqttBrokerWithHttpInfo
     *
     * Delete an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkMqttBrokerWithHttpInfo($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['deleteNetworkMqttBroker'][0])
    {
        $request = $this->deleteNetworkMqttBrokerRequest($network_id, $mqtt_broker_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkMqttBrokerAsync
     *
     * Delete an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkMqttBrokerAsync($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['deleteNetworkMqttBroker'][0])
    {
        return $this->deleteNetworkMqttBrokerAsyncWithHttpInfo($network_id, $mqtt_broker_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkMqttBrokerAsyncWithHttpInfo
     *
     * Delete an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkMqttBrokerAsyncWithHttpInfo($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['deleteNetworkMqttBroker'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkMqttBrokerRequest($network_id, $mqtt_broker_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkMqttBroker'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkMqttBrokerRequest($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['deleteNetworkMqttBroker'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkMqttBroker'
            );
        }

        // verify the required parameter 'mqtt_broker_id' is set
        if ($mqtt_broker_id === null || (is_array($mqtt_broker_id) && count($mqtt_broker_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mqtt_broker_id when calling deleteNetworkMqttBroker'
            );
        }


        $resourcePath = '/networks/{networkId}/mqttBrokers/{mqttBrokerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($mqtt_broker_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mqttBrokerId' . '}',
                ObjectSerializer::toPathValue($mqtt_broker_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkPiiRequest
     *
     * Delete a restrict processing PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkPiiRequest($network_id, $request_id, string $contentType = self::contentTypes['deleteNetworkPiiRequest'][0])
    {
        $this->deleteNetworkPiiRequestWithHttpInfo($network_id, $request_id, $contentType);
    }

    /**
     * Operation deleteNetworkPiiRequestWithHttpInfo
     *
     * Delete a restrict processing PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkPiiRequestWithHttpInfo($network_id, $request_id, string $contentType = self::contentTypes['deleteNetworkPiiRequest'][0])
    {
        $request = $this->deleteNetworkPiiRequestRequest($network_id, $request_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkPiiRequestAsync
     *
     * Delete a restrict processing PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkPiiRequestAsync($network_id, $request_id, string $contentType = self::contentTypes['deleteNetworkPiiRequest'][0])
    {
        return $this->deleteNetworkPiiRequestAsyncWithHttpInfo($network_id, $request_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkPiiRequestAsyncWithHttpInfo
     *
     * Delete a restrict processing PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkPiiRequestAsyncWithHttpInfo($network_id, $request_id, string $contentType = self::contentTypes['deleteNetworkPiiRequest'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkPiiRequestRequest($network_id, $request_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkPiiRequest'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkPiiRequestRequest($network_id, $request_id, string $contentType = self::contentTypes['deleteNetworkPiiRequest'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkPiiRequest'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling deleteNetworkPiiRequest'
            );
        }


        $resourcePath = '/networks/{networkId}/pii/requests/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkVlanProfile
     *
     * Delete a VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkVlanProfile($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {
        $this->deleteNetworkVlanProfileWithHttpInfo($network_id, $iname, $contentType);
    }

    /**
     * Operation deleteNetworkVlanProfileWithHttpInfo
     *
     * Delete a VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkVlanProfileWithHttpInfo($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {
        $request = $this->deleteNetworkVlanProfileRequest($network_id, $iname, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkVlanProfileAsync
     *
     * Delete a VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkVlanProfileAsync($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {
        return $this->deleteNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkVlanProfileAsyncWithHttpInfo
     *
     * Delete a VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkVlanProfileRequest($network_id, $iname, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkVlanProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkVlanProfileRequest($network_id, $iname, string $contentType = self::contentTypes['deleteNetworkVlanProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkVlanProfile'
            );
        }

        // verify the required parameter 'iname' is set
        if ($iname === null || (is_array($iname) && count($iname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iname when calling deleteNetworkVlanProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles/{iname}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($iname !== null) {
            $resourcePath = str_replace(
                '{' . 'iname' . '}',
                ObjectSerializer::toPathValue($iname),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkWebhooksHttpServer
     *
     * Delete an HTTP server from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkWebhooksHttpServer($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {
        $this->deleteNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, $contentType);
    }

    /**
     * Operation deleteNetworkWebhooksHttpServerWithHttpInfo
     *
     * Delete an HTTP server from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {
        $request = $this->deleteNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkWebhooksHttpServerAsync
     *
     * Delete an HTTP server from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWebhooksHttpServerAsync($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {
        return $this->deleteNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkWebhooksHttpServerAsyncWithHttpInfo
     *
     * Delete an HTTP server from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkWebhooksHttpServer'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkWebhooksHttpServerRequest($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkWebhooksHttpServer'
            );
        }

        // verify the required parameter 'http_server_id' is set
        if ($http_server_id === null || (is_array($http_server_id) && count($http_server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_server_id when calling deleteNetworkWebhooksHttpServer'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/httpServers/{httpServerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($http_server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'httpServerId' . '}',
                ObjectSerializer::toPathValue($http_server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkWebhooksPayloadTemplate
     *
     * Destroy a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkWebhooksPayloadTemplate($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {
        $this->deleteNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, $contentType);
    }

    /**
     * Operation deleteNetworkWebhooksPayloadTemplateWithHttpInfo
     *
     * Destroy a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {
        $request = $this->deleteNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkWebhooksPayloadTemplateAsync
     *
     * Destroy a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWebhooksPayloadTemplateAsync($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {
        return $this->deleteNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkWebhooksPayloadTemplateAsyncWithHttpInfo
     *
     * Destroy a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkWebhooksPayloadTemplate'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkWebhooksPayloadTemplate'
            );
        }

        // verify the required parameter 'payload_template_id' is set
        if ($payload_template_id === null || (is_array($payload_template_id) && count($payload_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payload_template_id when calling deleteNetworkWebhooksPayloadTemplate'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($payload_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'payloadTemplateId' . '}',
                ObjectSerializer::toPathValue($payload_template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disableOrganizationIntegrationsXdrNetworks
     *
     * Disable XDR on networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DisableOrganizationIntegrationsXdrNetworksRequest $disable_organization_integrations_xdr_networks_request disable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\DisableOrganizationIntegrationsXdrNetworks200Response
     */
    public function disableOrganizationIntegrationsXdrNetworks($organization_id, $disable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['disableOrganizationIntegrationsXdrNetworks'][0])
    {
        list($response) = $this->disableOrganizationIntegrationsXdrNetworksWithHttpInfo($organization_id, $disable_organization_integrations_xdr_networks_request, $contentType);
        return $response;
    }

    /**
     * Operation disableOrganizationIntegrationsXdrNetworksWithHttpInfo
     *
     * Disable XDR on networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DisableOrganizationIntegrationsXdrNetworksRequest $disable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\DisableOrganizationIntegrationsXdrNetworks200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function disableOrganizationIntegrationsXdrNetworksWithHttpInfo($organization_id, $disable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['disableOrganizationIntegrationsXdrNetworks'][0])
    {
        $request = $this->disableOrganizationIntegrationsXdrNetworksRequest($organization_id, $disable_organization_integrations_xdr_networks_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\DisableOrganizationIntegrationsXdrNetworks200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\DisableOrganizationIntegrationsXdrNetworks200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\DisableOrganizationIntegrationsXdrNetworks200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\DisableOrganizationIntegrationsXdrNetworks200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\DisableOrganizationIntegrationsXdrNetworks200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation disableOrganizationIntegrationsXdrNetworksAsync
     *
     * Disable XDR on networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DisableOrganizationIntegrationsXdrNetworksRequest $disable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableOrganizationIntegrationsXdrNetworksAsync($organization_id, $disable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['disableOrganizationIntegrationsXdrNetworks'][0])
    {
        return $this->disableOrganizationIntegrationsXdrNetworksAsyncWithHttpInfo($organization_id, $disable_organization_integrations_xdr_networks_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disableOrganizationIntegrationsXdrNetworksAsyncWithHttpInfo
     *
     * Disable XDR on networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DisableOrganizationIntegrationsXdrNetworksRequest $disable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableOrganizationIntegrationsXdrNetworksAsyncWithHttpInfo($organization_id, $disable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['disableOrganizationIntegrationsXdrNetworks'][0])
    {
        $returnType = '\Meraki\Model\DisableOrganizationIntegrationsXdrNetworks200Response';
        $request = $this->disableOrganizationIntegrationsXdrNetworksRequest($organization_id, $disable_organization_integrations_xdr_networks_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'disableOrganizationIntegrationsXdrNetworks'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\DisableOrganizationIntegrationsXdrNetworksRequest $disable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function disableOrganizationIntegrationsXdrNetworksRequest($organization_id, $disable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['disableOrganizationIntegrationsXdrNetworks'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling disableOrganizationIntegrationsXdrNetworks'
            );
        }

        // verify the required parameter 'disable_organization_integrations_xdr_networks_request' is set
        if ($disable_organization_integrations_xdr_networks_request === null || (is_array($disable_organization_integrations_xdr_networks_request) && count($disable_organization_integrations_xdr_networks_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $disable_organization_integrations_xdr_networks_request when calling disableOrganizationIntegrationsXdrNetworks'
            );
        }


        $resourcePath = '/organizations/{organizationId}/integrations/xdr/networks/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($disable_organization_integrations_xdr_networks_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($disable_organization_integrations_xdr_networks_request));
            } else {
                $httpBody = $disable_organization_integrations_xdr_networks_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableOrganizationIntegrationsXdrNetworks
     *
     * Enable XDR on networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\EnableOrganizationIntegrationsXdrNetworksRequest $enable_organization_integrations_xdr_networks_request enable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\EnableOrganizationIntegrationsXdrNetworks200Response
     */
    public function enableOrganizationIntegrationsXdrNetworks($organization_id, $enable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['enableOrganizationIntegrationsXdrNetworks'][0])
    {
        list($response) = $this->enableOrganizationIntegrationsXdrNetworksWithHttpInfo($organization_id, $enable_organization_integrations_xdr_networks_request, $contentType);
        return $response;
    }

    /**
     * Operation enableOrganizationIntegrationsXdrNetworksWithHttpInfo
     *
     * Enable XDR on networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\EnableOrganizationIntegrationsXdrNetworksRequest $enable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\EnableOrganizationIntegrationsXdrNetworks200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enableOrganizationIntegrationsXdrNetworksWithHttpInfo($organization_id, $enable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['enableOrganizationIntegrationsXdrNetworks'][0])
    {
        $request = $this->enableOrganizationIntegrationsXdrNetworksRequest($organization_id, $enable_organization_integrations_xdr_networks_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\EnableOrganizationIntegrationsXdrNetworks200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\EnableOrganizationIntegrationsXdrNetworks200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\EnableOrganizationIntegrationsXdrNetworks200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\EnableOrganizationIntegrationsXdrNetworks200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\EnableOrganizationIntegrationsXdrNetworks200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enableOrganizationIntegrationsXdrNetworksAsync
     *
     * Enable XDR on networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\EnableOrganizationIntegrationsXdrNetworksRequest $enable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableOrganizationIntegrationsXdrNetworksAsync($organization_id, $enable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['enableOrganizationIntegrationsXdrNetworks'][0])
    {
        return $this->enableOrganizationIntegrationsXdrNetworksAsyncWithHttpInfo($organization_id, $enable_organization_integrations_xdr_networks_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableOrganizationIntegrationsXdrNetworksAsyncWithHttpInfo
     *
     * Enable XDR on networks
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\EnableOrganizationIntegrationsXdrNetworksRequest $enable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableOrganizationIntegrationsXdrNetworksAsyncWithHttpInfo($organization_id, $enable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['enableOrganizationIntegrationsXdrNetworks'][0])
    {
        $returnType = '\Meraki\Model\EnableOrganizationIntegrationsXdrNetworks200Response';
        $request = $this->enableOrganizationIntegrationsXdrNetworksRequest($organization_id, $enable_organization_integrations_xdr_networks_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enableOrganizationIntegrationsXdrNetworks'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\EnableOrganizationIntegrationsXdrNetworksRequest $enable_organization_integrations_xdr_networks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enableOrganizationIntegrationsXdrNetworksRequest($organization_id, $enable_organization_integrations_xdr_networks_request, string $contentType = self::contentTypes['enableOrganizationIntegrationsXdrNetworks'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling enableOrganizationIntegrationsXdrNetworks'
            );
        }

        // verify the required parameter 'enable_organization_integrations_xdr_networks_request' is set
        if ($enable_organization_integrations_xdr_networks_request === null || (is_array($enable_organization_integrations_xdr_networks_request) && count($enable_organization_integrations_xdr_networks_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enable_organization_integrations_xdr_networks_request when calling enableOrganizationIntegrationsXdrNetworks'
            );
        }


        $resourcePath = '/organizations/{organizationId}/integrations/xdr/networks/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enable_organization_integrations_xdr_networks_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enable_organization_integrations_xdr_networks_request));
            } else {
                $httpBody = $enable_organization_integrations_xdr_networks_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetwork
     *
     * Return a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetwork200Response
     */
    public function getNetwork($network_id, string $contentType = self::contentTypes['getNetwork'][0])
    {
        list($response) = $this->getNetworkWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWithHttpInfo
     *
     * Return a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetwork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetwork'][0])
    {
        $request = $this->getNetworkRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetwork200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetwork200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetwork200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetwork200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetwork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkAsync
     *
     * Return a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAsync($network_id, string $contentType = self::contentTypes['getNetwork'][0])
    {
        return $this->getNetworkAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkAsyncWithHttpInfo
     *
     * Return a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetNetwork200Response';
        $request = $this->getNetworkRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetwork'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkRequest($network_id, string $contentType = self::contentTypes['getNetwork'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetwork'
            );
        }


        $resourcePath = '/networks/{networkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkAlertsHistory
     *
     * Return the alert history for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]
     */
    public function getNetworkAlertsHistory($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {
        list($response) = $this->getNetworkAlertsHistoryWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkAlertsHistoryWithHttpInfo
     *
     * Return the alert history for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAlertsHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkAlertsHistoryWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {
        $request = $this->getNetworkAlertsHistoryRequest($network_id, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkAlertsHistoryAsync
     *
     * Return the alert history for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAlertsHistoryAsync($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {
        return $this->getNetworkAlertsHistoryAsyncWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkAlertsHistoryAsyncWithHttpInfo
     *
     * Return the alert history for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAlertsHistoryAsyncWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAlertsHistory200ResponseInner[]';
        $request = $this->getNetworkAlertsHistoryRequest($network_id, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkAlertsHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkAlertsHistoryRequest($network_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkAlertsHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkAlertsHistory'
            );
        }





        $resourcePath = '/networks/{networkId}/alerts/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkAlertsSettings
     *
     * Return the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAlertsSettings200Response
     */
    public function getNetworkAlertsSettings($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {
        list($response) = $this->getNetworkAlertsSettingsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkAlertsSettingsWithHttpInfo
     *
     * Return the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAlertsSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkAlertsSettingsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {
        $request = $this->getNetworkAlertsSettingsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAlertsSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAlertsSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAlertsSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAlertsSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAlertsSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkAlertsSettingsAsync
     *
     * Return the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAlertsSettingsAsync($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {
        return $this->getNetworkAlertsSettingsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkAlertsSettingsAsyncWithHttpInfo
     *
     * Return the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkAlertsSettingsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAlertsSettings200Response';
        $request = $this->getNetworkAlertsSettingsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkAlertsSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkAlertsSettingsRequest($network_id, string $contentType = self::contentTypes['getNetworkAlertsSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkAlertsSettings'
            );
        }


        $resourcePath = '/networks/{networkId}/alerts/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkBluetoothClient
     *
     * Return a Bluetooth client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $bluetooth_client_id Bluetooth client ID (required)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int|null $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkBluetoothClients200ResponseInner
     */
    public function getNetworkBluetoothClient($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null, string $contentType = self::contentTypes['getNetworkBluetoothClient'][0])
    {
        list($response) = $this->getNetworkBluetoothClientWithHttpInfo($network_id, $bluetooth_client_id, $include_connectivity_history, $connectivity_history_timespan, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkBluetoothClientWithHttpInfo
     *
     * Return a Bluetooth client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $bluetooth_client_id Bluetooth client ID (required)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int|null $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkBluetoothClients200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkBluetoothClientWithHttpInfo($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null, string $contentType = self::contentTypes['getNetworkBluetoothClient'][0])
    {
        $request = $this->getNetworkBluetoothClientRequest($network_id, $bluetooth_client_id, $include_connectivity_history, $connectivity_history_timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkBluetoothClients200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkBluetoothClients200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkBluetoothClients200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkBluetoothClients200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkBluetoothClients200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkBluetoothClientAsync
     *
     * Return a Bluetooth client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $bluetooth_client_id Bluetooth client ID (required)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int|null $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkBluetoothClientAsync($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null, string $contentType = self::contentTypes['getNetworkBluetoothClient'][0])
    {
        return $this->getNetworkBluetoothClientAsyncWithHttpInfo($network_id, $bluetooth_client_id, $include_connectivity_history, $connectivity_history_timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkBluetoothClientAsyncWithHttpInfo
     *
     * Return a Bluetooth client
     *
     * @param  string $network_id Network ID (required)
     * @param  string $bluetooth_client_id Bluetooth client ID (required)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int|null $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkBluetoothClientAsyncWithHttpInfo($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null, string $contentType = self::contentTypes['getNetworkBluetoothClient'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkBluetoothClients200ResponseInner';
        $request = $this->getNetworkBluetoothClientRequest($network_id, $bluetooth_client_id, $include_connectivity_history, $connectivity_history_timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkBluetoothClient'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $bluetooth_client_id Bluetooth client ID (required)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int|null $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkBluetoothClientRequest($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null, string $contentType = self::contentTypes['getNetworkBluetoothClient'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkBluetoothClient'
            );
        }

        // verify the required parameter 'bluetooth_client_id' is set
        if ($bluetooth_client_id === null || (is_array($bluetooth_client_id) && count($bluetooth_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bluetooth_client_id when calling getNetworkBluetoothClient'
            );
        }




        $resourcePath = '/networks/{networkId}/bluetoothClients/{bluetoothClientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_connectivity_history,
            'includeConnectivityHistory', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $connectivity_history_timespan,
            'connectivityHistoryTimespan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($bluetooth_client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bluetoothClientId' . '}',
                ObjectSerializer::toPathValue($bluetooth_client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkBluetoothClients
     *
     * List the Bluetooth clients seen by APs in this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkBluetoothClients200ResponseInner[]
     */
    public function getNetworkBluetoothClients($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null, string $contentType = self::contentTypes['getNetworkBluetoothClients'][0])
    {
        list($response) = $this->getNetworkBluetoothClientsWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $include_connectivity_history, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkBluetoothClientsWithHttpInfo
     *
     * List the Bluetooth clients seen by APs in this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkBluetoothClients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkBluetoothClientsWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null, string $contentType = self::contentTypes['getNetworkBluetoothClients'][0])
    {
        $request = $this->getNetworkBluetoothClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $include_connectivity_history, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkBluetoothClients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkBluetoothClients200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkBluetoothClients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkBluetoothClients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkBluetoothClients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkBluetoothClientsAsync
     *
     * List the Bluetooth clients seen by APs in this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkBluetoothClientsAsync($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null, string $contentType = self::contentTypes['getNetworkBluetoothClients'][0])
    {
        return $this->getNetworkBluetoothClientsAsyncWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $include_connectivity_history, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkBluetoothClientsAsyncWithHttpInfo
     *
     * List the Bluetooth clients seen by APs in this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkBluetoothClientsAsyncWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null, string $contentType = self::contentTypes['getNetworkBluetoothClients'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkBluetoothClients200ResponseInner[]';
        $request = $this->getNetworkBluetoothClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $include_connectivity_history, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkBluetoothClients'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool|null $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkBluetoothClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkBluetoothClientsRequest($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null, string $contentType = self::contentTypes['getNetworkBluetoothClients'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkBluetoothClients'
            );
        }


        if ($timespan !== null && $timespan > 604800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling NetworksApi.getNetworkBluetoothClients, must be smaller than or equal to 604800.');
        }
        





        $resourcePath = '/networks/{networkId}/bluetoothClients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_connectivity_history,
            'includeConnectivityHistory', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClient
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClient200Response
     */
    public function getNetworkClient($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {
        list($response) = $this->getNetworkClientWithHttpInfo($network_id, $client_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientWithHttpInfo
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClient200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {
        $request = $this->getNetworkClientRequest($network_id, $client_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClient200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClient200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClient200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClient200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClient200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientAsync
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientAsync($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {
        return $this->getNetworkClientAsyncWithHttpInfo($network_id, $client_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientAsyncWithHttpInfo
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientAsyncWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClient200Response';
        $request = $this->getNetworkClientRequest($network_id, $client_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClient'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientRequest($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClient'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClient'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClient'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientPolicy
     *
     * Return the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientPolicy200Response
     */
    public function getNetworkClientPolicy($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {
        list($response) = $this->getNetworkClientPolicyWithHttpInfo($network_id, $client_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientPolicyWithHttpInfo
     *
     * Return the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientPolicy200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientPolicyWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {
        $request = $this->getNetworkClientPolicyRequest($network_id, $client_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientPolicy200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientPolicy200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientPolicy200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientPolicy200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientPolicy200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientPolicyAsync
     *
     * Return the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientPolicyAsync($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {
        return $this->getNetworkClientPolicyAsyncWithHttpInfo($network_id, $client_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientPolicyAsyncWithHttpInfo
     *
     * Return the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientPolicyAsyncWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientPolicy200Response';
        $request = $this->getNetworkClientPolicyRequest($network_id, $client_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientPolicy'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientPolicyRequest($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientPolicy'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientPolicy'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientPolicy'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientSplashAuthorizationStatus
     *
     * Return the splash authorization for a client, for each SSID they&#39;ve associated with through splash
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkClientSplashAuthorizationStatus($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {
        list($response) = $this->getNetworkClientSplashAuthorizationStatusWithHttpInfo($network_id, $client_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientSplashAuthorizationStatusWithHttpInfo
     *
     * Return the splash authorization for a client, for each SSID they&#39;ve associated with through splash
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientSplashAuthorizationStatusWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {
        $request = $this->getNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientSplashAuthorizationStatusAsync
     *
     * Return the splash authorization for a client, for each SSID they&#39;ve associated with through splash
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientSplashAuthorizationStatusAsync($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {
        return $this->getNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo($network_id, $client_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo
     *
     * Return the splash authorization for a client, for each SSID they&#39;ve associated with through splash
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientSplashAuthorizationStatus'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientSplashAuthorizationStatus'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientSplashAuthorizationStatus'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientSplashAuthorizationStatus'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientTrafficHistory
     *
     * Return the client&#39;s network traffic data over time
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]
     */
    public function getNetworkClientTrafficHistory($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {
        list($response) = $this->getNetworkClientTrafficHistoryWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientTrafficHistoryWithHttpInfo
     *
     * Return the client&#39;s network traffic data over time
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientTrafficHistoryWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {
        $request = $this->getNetworkClientTrafficHistoryRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientTrafficHistoryAsync
     *
     * Return the client&#39;s network traffic data over time
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientTrafficHistoryAsync($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {
        return $this->getNetworkClientTrafficHistoryAsyncWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientTrafficHistoryAsyncWithHttpInfo
     *
     * Return the client&#39;s network traffic data over time
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientTrafficHistoryAsyncWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientTrafficHistory200ResponseInner[]';
        $request = $this->getNetworkClientTrafficHistoryRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientTrafficHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientTrafficHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientTrafficHistoryRequest($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientTrafficHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientTrafficHistory'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientTrafficHistory'
            );
        }





        $resourcePath = '/networks/{networkId}/clients/{clientId}/trafficHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientUsageHistory
     *
     * Return the client&#39;s daily usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]
     */
    public function getNetworkClientUsageHistory($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {
        list($response) = $this->getNetworkClientUsageHistoryWithHttpInfo($network_id, $client_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientUsageHistoryWithHttpInfo
     *
     * Return the client&#39;s daily usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientUsageHistoryWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {
        $request = $this->getNetworkClientUsageHistoryRequest($network_id, $client_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientUsageHistoryAsync
     *
     * Return the client&#39;s daily usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientUsageHistoryAsync($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {
        return $this->getNetworkClientUsageHistoryAsyncWithHttpInfo($network_id, $client_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientUsageHistoryAsyncWithHttpInfo
     *
     * Return the client&#39;s daily usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientUsageHistoryAsyncWithHttpInfo($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientUsageHistory200ResponseInner[]';
        $request = $this->getNetworkClientUsageHistoryRequest($network_id, $client_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientUsageHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientUsageHistoryRequest($network_id, $client_id, string $contentType = self::contentTypes['getNetworkClientUsageHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientUsageHistory'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientUsageHistory'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/usageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClients
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClients200ResponseInner[]
     */
    public function getNetworkClients($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {
        list($response) = $this->getNetworkClientsWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $psk_group, $description, $vlan, $named_vlan, $recent_device_connections, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsWithHttpInfo
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {
        $request = $this->getNetworkClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $psk_group, $description, $vlan, $named_vlan, $recent_device_connections, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClients200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsAsync
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsAsync($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {
        return $this->getNetworkClientsAsyncWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $psk_group, $description, $vlan, $named_vlan, $recent_device_connections, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsAsyncWithHttpInfo
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsAsyncWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClients200ResponseInner[]';
        $request = $this->getNetworkClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $psk_group, $description, $vlan, $named_vlan, $recent_device_connections, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClients'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string|null $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string|null $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string|null $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string|null $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string|null $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string|null $psk_group Filters clients based on partial or full match for the iPSK name field. (optional)
     * @param  string|null $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string|null $vlan Filters clients based on the full match for the VLAN field. (optional)
     * @param  string|null $named_vlan Filters clients based on the partial or full match for the named VLAN field. (optional)
     * @param  string[]|null $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsRequest($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $psk_group = null, $description = null, $vlan = null, $named_vlan = null, $recent_device_connections = null, string $contentType = self::contentTypes['getNetworkClients'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClients'
            );
        }


        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling NetworksApi.getNetworkClients, must be smaller than or equal to 2678400.');
        }
        















        $resourcePath = '/networks/{networkId}/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $statuses,
            'statuses', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip,
            'ip', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip6,
            'ip6', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip6_local,
            'ip6Local', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mac,
            'mac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $os,
            'os', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $psk_group,
            'pskGroup', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan,
            'vlan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $named_vlan,
            'namedVlan', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recent_device_connections,
            'recentDeviceConnections', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsApplicationUsage
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getNetworkClientsApplicationUsage($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {
        list($response) = $this->getNetworkClientsApplicationUsageWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsApplicationUsageWithHttpInfo
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsApplicationUsageWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {
        $request = $this->getNetworkClientsApplicationUsageRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsApplicationUsageAsync
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsApplicationUsageAsync($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {
        return $this->getNetworkClientsApplicationUsageAsyncWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsApplicationUsageAsyncWithHttpInfo
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsApplicationUsageAsyncWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {
        $returnType = 'object[]';
        $request = $this->getNetworkClientsApplicationUsageRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsApplicationUsage'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsApplicationUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsApplicationUsageRequest($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsApplicationUsage'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsApplicationUsage'
            );
        }

        // verify the required parameter 'clients' is set
        if ($clients === null || (is_array($clients) && count($clients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clients when calling getNetworkClientsApplicationUsage'
            );
        }







        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling NetworksApi.getNetworkClientsApplicationUsage, must be smaller than or equal to 2678400.');
        }
        

        $resourcePath = '/networks/{networkId}/clients/applicationUsage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clients,
            'clients', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_number,
            'ssidNumber', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsBandwidthUsageHistory
     *
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]
     */
    public function getNetworkClientsBandwidthUsageHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {
        list($response) = $this->getNetworkClientsBandwidthUsageHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsBandwidthUsageHistoryWithHttpInfo
     *
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsBandwidthUsageHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {
        $request = $this->getNetworkClientsBandwidthUsageHistoryRequest($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsBandwidthUsageHistoryAsync
     *
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsBandwidthUsageHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {
        return $this->getNetworkClientsBandwidthUsageHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsBandwidthUsageHistoryAsyncWithHttpInfo
     *
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsBandwidthUsageHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientsBandwidthUsageHistory200ResponseInner[]';
        $request = $this->getNetworkClientsBandwidthUsageHistoryRequest($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsBandwidthUsageHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsBandwidthUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsBandwidthUsageHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkClientsBandwidthUsageHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsBandwidthUsageHistory'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling NetworksApi.getNetworkClientsBandwidthUsageHistory, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/networks/{networkId}/clients/bandwidthUsageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsOverview
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientsOverview200Response
     */
    public function getNetworkClientsOverview($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {
        list($response) = $this->getNetworkClientsOverviewWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsOverviewWithHttpInfo
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientsOverview200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsOverviewWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {
        $request = $this->getNetworkClientsOverviewRequest($network_id, $t0, $t1, $timespan, $resolution, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientsOverview200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientsOverview200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientsOverview200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientsOverview200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientsOverview200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsOverviewAsync
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsOverviewAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {
        return $this->getNetworkClientsOverviewAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsOverviewAsyncWithHttpInfo
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsOverviewAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientsOverview200Response';
        $request = $this->getNetworkClientsOverviewRequest($network_id, $t0, $t1, $timespan, $resolution, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsOverview'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsOverviewRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, string $contentType = self::contentTypes['getNetworkClientsOverview'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsOverview'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling NetworksApi.getNetworkClientsOverview, must be smaller than or equal to 2678400.');
        }
        


        $resourcePath = '/networks/{networkId}/clients/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsUsageHistories
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getNetworkClientsUsageHistories($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {
        list($response) = $this->getNetworkClientsUsageHistoriesWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkClientsUsageHistoriesWithHttpInfo
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsUsageHistoriesWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {
        $request = $this->getNetworkClientsUsageHistoriesRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsUsageHistoriesAsync
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsUsageHistoriesAsync($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {
        return $this->getNetworkClientsUsageHistoriesAsyncWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsUsageHistoriesAsyncWithHttpInfo
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsUsageHistoriesAsyncWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {
        $returnType = 'object[]';
        $request = $this->getNetworkClientsUsageHistoriesRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsUsageHistories'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int|null $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkClientsUsageHistories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkClientsUsageHistoriesRequest($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkClientsUsageHistories'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsUsageHistories'
            );
        }

        // verify the required parameter 'clients' is set
        if ($clients === null || (is_array($clients) && count($clients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clients when calling getNetworkClientsUsageHistories'
            );
        }







        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling NetworksApi.getNetworkClientsUsageHistories, must be smaller than or equal to 2678400.');
        }
        

        $resourcePath = '/networks/{networkId}/clients/usageHistories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clients,
            'clients', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_number,
            'ssidNumber', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkDevices
     *
     * List the devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDevice200Response[]
     * @deprecated
     */
    public function getNetworkDevices($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {
        list($response) = $this->getNetworkDevicesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkDevicesWithHttpInfo
     *
     * List the devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDevice200Response[], HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getNetworkDevicesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {
        $request = $this->getNetworkDevicesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDevice200Response[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDevice200Response[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDevice200Response[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDevice200Response[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDevice200Response[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkDevicesAsync
     *
     * List the devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getNetworkDevicesAsync($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {
        return $this->getNetworkDevicesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkDevicesAsyncWithHttpInfo
     *
     * List the devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getNetworkDevicesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {
        $returnType = '\Meraki\Model\GetDevice200Response[]';
        $request = $this->getNetworkDevicesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getNetworkDevicesRequest($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkDevices'
            );
        }


        $resourcePath = '/networks/{networkId}/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkEvents
     *
     * List the events for the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, wirelessController, and secureConnect (optional)
     * @param  string[]|null $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[]|null $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string|null $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string|null $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string|null $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $event_details The details of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  string|null $event_severity The severity of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  bool|null $is_catalyst Boolean indicating that whether it is a Catalyst device. For Catalyst device, eventDetails and eventSeverity can be used to filter events. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkEvents200Response
     */
    public function getNetworkEvents($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $event_details = null, $event_severity = null, $is_catalyst = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkEvents'][0])
    {
        list($response) = $this->getNetworkEventsWithHttpInfo($network_id, $product_type, $included_event_types, $excluded_event_types, $device_mac, $device_serial, $device_name, $client_ip, $client_mac, $client_name, $sm_device_mac, $sm_device_name, $event_details, $event_severity, $is_catalyst, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkEventsWithHttpInfo
     *
     * List the events for the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, wirelessController, and secureConnect (optional)
     * @param  string[]|null $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[]|null $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string|null $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string|null $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string|null $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $event_details The details of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  string|null $event_severity The severity of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  bool|null $is_catalyst Boolean indicating that whether it is a Catalyst device. For Catalyst device, eventDetails and eventSeverity can be used to filter events. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkEvents200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkEventsWithHttpInfo($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $event_details = null, $event_severity = null, $is_catalyst = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkEvents'][0])
    {
        $request = $this->getNetworkEventsRequest($network_id, $product_type, $included_event_types, $excluded_event_types, $device_mac, $device_serial, $device_name, $client_ip, $client_mac, $client_name, $sm_device_mac, $sm_device_name, $event_details, $event_severity, $is_catalyst, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkEvents200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkEvents200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkEvents200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkEvents200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkEvents200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkEventsAsync
     *
     * List the events for the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, wirelessController, and secureConnect (optional)
     * @param  string[]|null $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[]|null $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string|null $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string|null $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string|null $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $event_details The details of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  string|null $event_severity The severity of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  bool|null $is_catalyst Boolean indicating that whether it is a Catalyst device. For Catalyst device, eventDetails and eventSeverity can be used to filter events. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkEventsAsync($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $event_details = null, $event_severity = null, $is_catalyst = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkEvents'][0])
    {
        return $this->getNetworkEventsAsyncWithHttpInfo($network_id, $product_type, $included_event_types, $excluded_event_types, $device_mac, $device_serial, $device_name, $client_ip, $client_mac, $client_name, $sm_device_mac, $sm_device_name, $event_details, $event_severity, $is_catalyst, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkEventsAsyncWithHttpInfo
     *
     * List the events for the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, wirelessController, and secureConnect (optional)
     * @param  string[]|null $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[]|null $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string|null $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string|null $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string|null $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $event_details The details of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  string|null $event_severity The severity of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  bool|null $is_catalyst Boolean indicating that whether it is a Catalyst device. For Catalyst device, eventDetails and eventSeverity can be used to filter events. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkEventsAsyncWithHttpInfo($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $event_details = null, $event_severity = null, $is_catalyst = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkEvents'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkEvents200Response';
        $request = $this->getNetworkEventsRequest($network_id, $product_type, $included_event_types, $excluded_event_types, $device_mac, $device_serial, $device_name, $client_ip, $client_mac, $client_name, $sm_device_mac, $sm_device_name, $event_details, $event_severity, $is_catalyst, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkEvents'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, wirelessController, and secureConnect (optional)
     * @param  string[]|null $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[]|null $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string|null $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string|null $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string|null $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string|null $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string|null $event_details The details of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  string|null $event_severity The severity of the event(Catalyst device only) which the list of events will be filtered with (optional)
     * @param  bool|null $is_catalyst Boolean indicating that whether it is a Catalyst device. For Catalyst device, eventDetails and eventSeverity can be used to filter events. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkEventsRequest($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $event_details = null, $event_severity = null, $is_catalyst = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkEvents'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkEvents'
            );
        }



















        $resourcePath = '/networks/{networkId}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_type,
            'productType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $included_event_types,
            'includedEventTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $excluded_event_types,
            'excludedEventTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_mac,
            'deviceMac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_serial,
            'deviceSerial', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_name,
            'deviceName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_ip,
            'clientIp', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_mac,
            'clientMac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_name,
            'clientName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sm_device_mac,
            'smDeviceMac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sm_device_name,
            'smDeviceName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_details,
            'eventDetails', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_severity,
            'eventSeverity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_catalyst,
            'isCatalyst', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkEventsEventTypes
     *
     * List the event type to human-readable description
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEventsEventTypes'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkEventsEventTypes200ResponseInner[]
     */
    public function getNetworkEventsEventTypes($network_id, string $contentType = self::contentTypes['getNetworkEventsEventTypes'][0])
    {
        list($response) = $this->getNetworkEventsEventTypesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkEventsEventTypesWithHttpInfo
     *
     * List the event type to human-readable description
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEventsEventTypes'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkEventsEventTypes200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkEventsEventTypesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkEventsEventTypes'][0])
    {
        $request = $this->getNetworkEventsEventTypesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkEventsEventTypes200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkEventsEventTypes200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkEventsEventTypes200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkEventsEventTypes200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkEventsEventTypes200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkEventsEventTypesAsync
     *
     * List the event type to human-readable description
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEventsEventTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkEventsEventTypesAsync($network_id, string $contentType = self::contentTypes['getNetworkEventsEventTypes'][0])
    {
        return $this->getNetworkEventsEventTypesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkEventsEventTypesAsyncWithHttpInfo
     *
     * List the event type to human-readable description
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEventsEventTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkEventsEventTypesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkEventsEventTypes'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkEventsEventTypes200ResponseInner[]';
        $request = $this->getNetworkEventsEventTypesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkEventsEventTypes'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkEventsEventTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkEventsEventTypesRequest($network_id, string $contentType = self::contentTypes['getNetworkEventsEventTypes'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkEventsEventTypes'
            );
        }


        $resourcePath = '/networks/{networkId}/events/eventTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkFirmwareUpgrades
     *
     * Get firmware upgrade information for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgrades200Response
     */
    public function getNetworkFirmwareUpgrades($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgrades'][0])
    {
        list($response) = $this->getNetworkFirmwareUpgradesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkFirmwareUpgradesWithHttpInfo
     *
     * Get firmware upgrade information for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgrades200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkFirmwareUpgradesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgrades'][0])
    {
        $request = $this->getNetworkFirmwareUpgradesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgrades200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgrades200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgrades200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgrades200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgrades200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkFirmwareUpgradesAsync
     *
     * Get firmware upgrade information for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesAsync($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgrades'][0])
    {
        return $this->getNetworkFirmwareUpgradesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkFirmwareUpgradesAsyncWithHttpInfo
     *
     * Get firmware upgrade information for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgrades'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgrades200Response';
        $request = $this->getNetworkFirmwareUpgradesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkFirmwareUpgrades'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkFirmwareUpgradesRequest($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgrades'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkFirmwareUpgrades'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedEvents
     *
     * Get the Staged Upgrade Event from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response
     */
    public function getNetworkFirmwareUpgradesStagedEvents($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'][0])
    {
        list($response) = $this->getNetworkFirmwareUpgradesStagedEventsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedEventsWithHttpInfo
     *
     * Get the Staged Upgrade Event from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkFirmwareUpgradesStagedEventsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'][0])
    {
        $request = $this->getNetworkFirmwareUpgradesStagedEventsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedEventsAsync
     *
     * Get the Staged Upgrade Event from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesStagedEventsAsync($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'][0])
    {
        return $this->getNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo
     *
     * Get the Staged Upgrade Event from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
        $request = $this->getNetworkFirmwareUpgradesStagedEventsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkFirmwareUpgradesStagedEvents'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkFirmwareUpgradesStagedEventsRequest($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedEvents'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkFirmwareUpgradesStagedEvents'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedGroup
     *
     * Get a Staged Upgrade Group from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner
     */
    public function getNetworkFirmwareUpgradesStagedGroup($network_id, $group_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'][0])
    {
        list($response) = $this->getNetworkFirmwareUpgradesStagedGroupWithHttpInfo($network_id, $group_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedGroupWithHttpInfo
     *
     * Get a Staged Upgrade Group from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkFirmwareUpgradesStagedGroupWithHttpInfo($network_id, $group_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'][0])
    {
        $request = $this->getNetworkFirmwareUpgradesStagedGroupRequest($network_id, $group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedGroupAsync
     *
     * Get a Staged Upgrade Group from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesStagedGroupAsync($network_id, $group_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'][0])
    {
        return $this->getNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo($network_id, $group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo
     *
     * Get a Staged Upgrade Group from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo($network_id, $group_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner';
        $request = $this->getNetworkFirmwareUpgradesStagedGroupRequest($network_id, $group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkFirmwareUpgradesStagedGroup'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkFirmwareUpgradesStagedGroupRequest($network_id, $group_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroup'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkFirmwareUpgradesStagedGroup'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getNetworkFirmwareUpgradesStagedGroup'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedGroups
     *
     * List of Staged Upgrade Groups in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner[]
     */
    public function getNetworkFirmwareUpgradesStagedGroups($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'][0])
    {
        list($response) = $this->getNetworkFirmwareUpgradesStagedGroupsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedGroupsWithHttpInfo
     *
     * List of Staged Upgrade Groups in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkFirmwareUpgradesStagedGroupsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'][0])
    {
        $request = $this->getNetworkFirmwareUpgradesStagedGroupsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedGroupsAsync
     *
     * List of Staged Upgrade Groups in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesStagedGroupsAsync($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'][0])
    {
        return $this->getNetworkFirmwareUpgradesStagedGroupsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedGroupsAsyncWithHttpInfo
     *
     * List of Staged Upgrade Groups in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesStagedGroupsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner[]';
        $request = $this->getNetworkFirmwareUpgradesStagedGroupsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkFirmwareUpgradesStagedGroups'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkFirmwareUpgradesStagedGroupsRequest($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedGroups'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkFirmwareUpgradesStagedGroups'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedStages
     *
     * Order of Staged Upgrade Groups in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]
     */
    public function getNetworkFirmwareUpgradesStagedStages($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedStages'][0])
    {
        list($response) = $this->getNetworkFirmwareUpgradesStagedStagesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedStagesWithHttpInfo
     *
     * Order of Staged Upgrade Groups in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkFirmwareUpgradesStagedStagesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedStages'][0])
    {
        $request = $this->getNetworkFirmwareUpgradesStagedStagesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedStagesAsync
     *
     * Order of Staged Upgrade Groups in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesStagedStagesAsync($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedStages'][0])
    {
        return $this->getNetworkFirmwareUpgradesStagedStagesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkFirmwareUpgradesStagedStagesAsyncWithHttpInfo
     *
     * Order of Staged Upgrade Groups in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFirmwareUpgradesStagedStagesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedStages'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]';
        $request = $this->getNetworkFirmwareUpgradesStagedStagesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkFirmwareUpgradesStagedStages'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkFirmwareUpgradesStagedStagesRequest($network_id, string $contentType = self::contentTypes['getNetworkFirmwareUpgradesStagedStages'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkFirmwareUpgradesStagedStages'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/stages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkFloorPlan
     *
     * Find a floor plan by ID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFloorPlans200ResponseInner
     */
    public function getNetworkFloorPlan($network_id, $floor_plan_id, string $contentType = self::contentTypes['getNetworkFloorPlan'][0])
    {
        list($response) = $this->getNetworkFloorPlanWithHttpInfo($network_id, $floor_plan_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkFloorPlanWithHttpInfo
     *
     * Find a floor plan by ID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFloorPlans200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkFloorPlanWithHttpInfo($network_id, $floor_plan_id, string $contentType = self::contentTypes['getNetworkFloorPlan'][0])
    {
        $request = $this->getNetworkFloorPlanRequest($network_id, $floor_plan_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFloorPlans200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFloorPlans200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkFloorPlanAsync
     *
     * Find a floor plan by ID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFloorPlanAsync($network_id, $floor_plan_id, string $contentType = self::contentTypes['getNetworkFloorPlan'][0])
    {
        return $this->getNetworkFloorPlanAsyncWithHttpInfo($network_id, $floor_plan_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkFloorPlanAsyncWithHttpInfo
     *
     * Find a floor plan by ID
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFloorPlanAsyncWithHttpInfo($network_id, $floor_plan_id, string $contentType = self::contentTypes['getNetworkFloorPlan'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner';
        $request = $this->getNetworkFloorPlanRequest($network_id, $floor_plan_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkFloorPlan'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkFloorPlanRequest($network_id, $floor_plan_id, string $contentType = self::contentTypes['getNetworkFloorPlan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkFloorPlan'
            );
        }

        // verify the required parameter 'floor_plan_id' is set
        if ($floor_plan_id === null || (is_array($floor_plan_id) && count($floor_plan_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $floor_plan_id when calling getNetworkFloorPlan'
            );
        }


        $resourcePath = '/networks/{networkId}/floorPlans/{floorPlanId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($floor_plan_id !== null) {
            $resourcePath = str_replace(
                '{' . 'floorPlanId' . '}',
                ObjectSerializer::toPathValue($floor_plan_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkFloorPlans
     *
     * List the floor plans that belong to your network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlans'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFloorPlans200ResponseInner[]
     */
    public function getNetworkFloorPlans($network_id, string $contentType = self::contentTypes['getNetworkFloorPlans'][0])
    {
        list($response) = $this->getNetworkFloorPlansWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkFloorPlansWithHttpInfo
     *
     * List the floor plans that belong to your network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlans'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFloorPlans200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkFloorPlansWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFloorPlans'][0])
    {
        $request = $this->getNetworkFloorPlansRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFloorPlans200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFloorPlans200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkFloorPlansAsync
     *
     * List the floor plans that belong to your network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFloorPlansAsync($network_id, string $contentType = self::contentTypes['getNetworkFloorPlans'][0])
    {
        return $this->getNetworkFloorPlansAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkFloorPlansAsyncWithHttpInfo
     *
     * List the floor plans that belong to your network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkFloorPlansAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkFloorPlans'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner[]';
        $request = $this->getNetworkFloorPlansRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkFloorPlans'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkFloorPlans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkFloorPlansRequest($network_id, string $contentType = self::contentTypes['getNetworkFloorPlans'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkFloorPlans'
            );
        }


        $resourcePath = '/networks/{networkId}/floorPlans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkGroupPolicies
     *
     * List the group policies in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicies'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkGroupPolicies200ResponseInner[]
     */
    public function getNetworkGroupPolicies($network_id, string $contentType = self::contentTypes['getNetworkGroupPolicies'][0])
    {
        list($response) = $this->getNetworkGroupPoliciesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkGroupPoliciesWithHttpInfo
     *
     * List the group policies in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicies'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkGroupPolicies200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkGroupPoliciesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkGroupPolicies'][0])
    {
        $request = $this->getNetworkGroupPoliciesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkGroupPolicies200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkGroupPolicies200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkGroupPoliciesAsync
     *
     * List the group policies in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkGroupPoliciesAsync($network_id, string $contentType = self::contentTypes['getNetworkGroupPolicies'][0])
    {
        return $this->getNetworkGroupPoliciesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkGroupPoliciesAsyncWithHttpInfo
     *
     * List the group policies in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkGroupPoliciesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkGroupPolicies'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner[]';
        $request = $this->getNetworkGroupPoliciesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkGroupPolicies'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkGroupPoliciesRequest($network_id, string $contentType = self::contentTypes['getNetworkGroupPolicies'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkGroupPolicies'
            );
        }


        $resourcePath = '/networks/{networkId}/groupPolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkGroupPolicy
     *
     * Display a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkGroupPolicies200ResponseInner
     */
    public function getNetworkGroupPolicy($network_id, $group_policy_id, string $contentType = self::contentTypes['getNetworkGroupPolicy'][0])
    {
        list($response) = $this->getNetworkGroupPolicyWithHttpInfo($network_id, $group_policy_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkGroupPolicyWithHttpInfo
     *
     * Display a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkGroupPolicies200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkGroupPolicyWithHttpInfo($network_id, $group_policy_id, string $contentType = self::contentTypes['getNetworkGroupPolicy'][0])
    {
        $request = $this->getNetworkGroupPolicyRequest($network_id, $group_policy_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkGroupPolicies200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkGroupPolicies200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkGroupPolicyAsync
     *
     * Display a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkGroupPolicyAsync($network_id, $group_policy_id, string $contentType = self::contentTypes['getNetworkGroupPolicy'][0])
    {
        return $this->getNetworkGroupPolicyAsyncWithHttpInfo($network_id, $group_policy_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkGroupPolicyAsyncWithHttpInfo
     *
     * Display a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkGroupPolicyAsyncWithHttpInfo($network_id, $group_policy_id, string $contentType = self::contentTypes['getNetworkGroupPolicy'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner';
        $request = $this->getNetworkGroupPolicyRequest($network_id, $group_policy_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkGroupPolicy'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkGroupPolicyRequest($network_id, $group_policy_id, string $contentType = self::contentTypes['getNetworkGroupPolicy'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkGroupPolicy'
            );
        }

        // verify the required parameter 'group_policy_id' is set
        if ($group_policy_id === null || (is_array($group_policy_id) && count($group_policy_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_policy_id when calling getNetworkGroupPolicy'
            );
        }


        $resourcePath = '/networks/{networkId}/groupPolicies/{groupPolicyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($group_policy_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupPolicyId' . '}',
                ObjectSerializer::toPathValue($group_policy_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkHealthAlerts
     *
     * Return all global alerts on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]
     * @deprecated
     */
    public function getNetworkHealthAlerts($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {
        list($response) = $this->getNetworkHealthAlertsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkHealthAlertsWithHttpInfo
     *
     * Return all global alerts on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkHealthAlerts200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getNetworkHealthAlertsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {
        $request = $this->getNetworkHealthAlertsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkHealthAlertsAsync
     *
     * Return all global alerts on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getNetworkHealthAlertsAsync($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {
        return $this->getNetworkHealthAlertsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkHealthAlertsAsyncWithHttpInfo
     *
     * Return all global alerts on this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getNetworkHealthAlertsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkHealthAlerts200ResponseInner[]';
        $request = $this->getNetworkHealthAlertsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkHealthAlerts'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkHealthAlerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getNetworkHealthAlertsRequest($network_id, string $contentType = self::contentTypes['getNetworkHealthAlerts'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkHealthAlerts'
            );
        }


        $resourcePath = '/networks/{networkId}/health/alerts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkMerakiAuthUser
     *
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner
     */
    public function getNetworkMerakiAuthUser($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {
        list($response) = $this->getNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkMerakiAuthUserWithHttpInfo
     *
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {
        $request = $this->getNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkMerakiAuthUserAsync
     *
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMerakiAuthUserAsync($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {
        return $this->getNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkMerakiAuthUserAsyncWithHttpInfo
     *
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
        $request = $this->getNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkMerakiAuthUser'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUser'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkMerakiAuthUser'
            );
        }

        // verify the required parameter 'meraki_auth_user_id' is set
        if ($meraki_auth_user_id === null || (is_array($meraki_auth_user_id) && count($meraki_auth_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meraki_auth_user_id when calling getNetworkMerakiAuthUser'
            );
        }


        $resourcePath = '/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($meraki_auth_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merakiAuthUserId' . '}',
                ObjectSerializer::toPathValue($meraki_auth_user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkMerakiAuthUsers
     *
     * List the authorized users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a MX network)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]
     */
    public function getNetworkMerakiAuthUsers($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {
        list($response) = $this->getNetworkMerakiAuthUsersWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkMerakiAuthUsersWithHttpInfo
     *
     * List the authorized users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a MX network)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkMerakiAuthUsersWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {
        $request = $this->getNetworkMerakiAuthUsersRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkMerakiAuthUsersAsync
     *
     * List the authorized users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a MX network)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMerakiAuthUsersAsync($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {
        return $this->getNetworkMerakiAuthUsersAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkMerakiAuthUsersAsyncWithHttpInfo
     *
     * List the authorized users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a MX network)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMerakiAuthUsersAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner[]';
        $request = $this->getNetworkMerakiAuthUsersRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkMerakiAuthUsers'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMerakiAuthUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkMerakiAuthUsersRequest($network_id, string $contentType = self::contentTypes['getNetworkMerakiAuthUsers'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkMerakiAuthUsers'
            );
        }


        $resourcePath = '/networks/{networkId}/merakiAuthUsers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkMqttBroker
     *
     * Return an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMqttBrokers200ResponseInner
     */
    public function getNetworkMqttBroker($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['getNetworkMqttBroker'][0])
    {
        list($response) = $this->getNetworkMqttBrokerWithHttpInfo($network_id, $mqtt_broker_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkMqttBrokerWithHttpInfo
     *
     * Return an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMqttBrokers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkMqttBrokerWithHttpInfo($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['getNetworkMqttBroker'][0])
    {
        $request = $this->getNetworkMqttBrokerRequest($network_id, $mqtt_broker_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkMqttBrokers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMqttBrokers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkMqttBrokerAsync
     *
     * Return an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMqttBrokerAsync($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['getNetworkMqttBroker'][0])
    {
        return $this->getNetworkMqttBrokerAsyncWithHttpInfo($network_id, $mqtt_broker_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkMqttBrokerAsyncWithHttpInfo
     *
     * Return an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMqttBrokerAsyncWithHttpInfo($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['getNetworkMqttBroker'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner';
        $request = $this->getNetworkMqttBrokerRequest($network_id, $mqtt_broker_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkMqttBroker'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkMqttBrokerRequest($network_id, $mqtt_broker_id, string $contentType = self::contentTypes['getNetworkMqttBroker'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkMqttBroker'
            );
        }

        // verify the required parameter 'mqtt_broker_id' is set
        if ($mqtt_broker_id === null || (is_array($mqtt_broker_id) && count($mqtt_broker_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mqtt_broker_id when calling getNetworkMqttBroker'
            );
        }


        $resourcePath = '/networks/{networkId}/mqttBrokers/{mqttBrokerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($mqtt_broker_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mqttBrokerId' . '}',
                ObjectSerializer::toPathValue($mqtt_broker_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkMqttBrokers
     *
     * List the MQTT brokers for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBrokers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMqttBrokers200ResponseInner[]
     */
    public function getNetworkMqttBrokers($network_id, string $contentType = self::contentTypes['getNetworkMqttBrokers'][0])
    {
        list($response) = $this->getNetworkMqttBrokersWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkMqttBrokersWithHttpInfo
     *
     * List the MQTT brokers for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBrokers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMqttBrokers200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkMqttBrokersWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkMqttBrokers'][0])
    {
        $request = $this->getNetworkMqttBrokersRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkMqttBrokers200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMqttBrokers200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkMqttBrokersAsync
     *
     * List the MQTT brokers for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBrokers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMqttBrokersAsync($network_id, string $contentType = self::contentTypes['getNetworkMqttBrokers'][0])
    {
        return $this->getNetworkMqttBrokersAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkMqttBrokersAsyncWithHttpInfo
     *
     * List the MQTT brokers for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBrokers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkMqttBrokersAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkMqttBrokers'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner[]';
        $request = $this->getNetworkMqttBrokersRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkMqttBrokers'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkMqttBrokers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkMqttBrokersRequest($network_id, string $contentType = self::contentTypes['getNetworkMqttBrokers'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkMqttBrokers'
            );
        }


        $resourcePath = '/networks/{networkId}/mqttBrokers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkNetflow
     *
     * Return the NetFlow traffic reporting settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkNetflow200Response
     */
    public function getNetworkNetflow($network_id, string $contentType = self::contentTypes['getNetworkNetflow'][0])
    {
        list($response) = $this->getNetworkNetflowWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkNetflowWithHttpInfo
     *
     * Return the NetFlow traffic reporting settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkNetflow200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkNetflowWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkNetflow'][0])
    {
        $request = $this->getNetworkNetflowRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkNetflow200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkNetflow200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkNetflow200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkNetflow200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkNetflow200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkNetflowAsync
     *
     * Return the NetFlow traffic reporting settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkNetflowAsync($network_id, string $contentType = self::contentTypes['getNetworkNetflow'][0])
    {
        return $this->getNetworkNetflowAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkNetflowAsyncWithHttpInfo
     *
     * Return the NetFlow traffic reporting settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkNetflowAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkNetflow'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkNetflow200Response';
        $request = $this->getNetworkNetflowRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkNetflow'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkNetflowRequest($network_id, string $contentType = self::contentTypes['getNetworkNetflow'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkNetflow'
            );
        }


        $resourcePath = '/networks/{networkId}/netflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkNetworkHealthChannelUtilization
     *
     * Get the channel utilization over each radio for all APs in a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetworkHealthChannelUtilization'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkNetworkHealthChannelUtilization200ResponseInner[]
     */
    public function getNetworkNetworkHealthChannelUtilization($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkNetworkHealthChannelUtilization'][0])
    {
        list($response) = $this->getNetworkNetworkHealthChannelUtilizationWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkNetworkHealthChannelUtilizationWithHttpInfo
     *
     * Get the channel utilization over each radio for all APs in a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetworkHealthChannelUtilization'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkNetworkHealthChannelUtilization200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkNetworkHealthChannelUtilizationWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkNetworkHealthChannelUtilization'][0])
    {
        $request = $this->getNetworkNetworkHealthChannelUtilizationRequest($network_id, $t0, $t1, $timespan, $resolution, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkNetworkHealthChannelUtilization200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkNetworkHealthChannelUtilization200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkNetworkHealthChannelUtilization200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkNetworkHealthChannelUtilization200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkNetworkHealthChannelUtilization200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkNetworkHealthChannelUtilizationAsync
     *
     * Get the channel utilization over each radio for all APs in a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetworkHealthChannelUtilization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkNetworkHealthChannelUtilizationAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkNetworkHealthChannelUtilization'][0])
    {
        return $this->getNetworkNetworkHealthChannelUtilizationAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkNetworkHealthChannelUtilizationAsyncWithHttpInfo
     *
     * Get the channel utilization over each radio for all APs in a network.
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetworkHealthChannelUtilization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkNetworkHealthChannelUtilizationAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkNetworkHealthChannelUtilization'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkNetworkHealthChannelUtilization200ResponseInner[]';
        $request = $this->getNetworkNetworkHealthChannelUtilizationRequest($network_id, $t0, $t1, $timespan, $resolution, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkNetworkHealthChannelUtilization'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkNetworkHealthChannelUtilization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkNetworkHealthChannelUtilizationRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkNetworkHealthChannelUtilization'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkNetworkHealthChannelUtilization'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling NetworksApi.getNetworkNetworkHealthChannelUtilization, must be smaller than or equal to 2678400.');
        }
        





        $resourcePath = '/networks/{networkId}/networkHealth/channelUtilization';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkPiiPiiKeys
     *
     * List the keys required to access Personally Identifiable Information (PII) for a given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiPiiKeys'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,\Meraki\Model\GetNetworkPiiPiiKeys200ResponseValue>
     */
    public function getNetworkPiiPiiKeys($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiPiiKeys'][0])
    {
        list($response) = $this->getNetworkPiiPiiKeysWithHttpInfo($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkPiiPiiKeysWithHttpInfo
     *
     * List the keys required to access Personally Identifiable Information (PII) for a given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiPiiKeys'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,\Meraki\Model\GetNetworkPiiPiiKeys200ResponseValue>, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkPiiPiiKeysWithHttpInfo($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiPiiKeys'][0])
    {
        $request = $this->getNetworkPiiPiiKeysRequest($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('array<string,\Meraki\Model\GetNetworkPiiPiiKeys200ResponseValue>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,\Meraki\Model\GetNetworkPiiPiiKeys200ResponseValue>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,\Meraki\Model\GetNetworkPiiPiiKeys200ResponseValue>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'array<string,\Meraki\Model\GetNetworkPiiPiiKeys200ResponseValue>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,\Meraki\Model\GetNetworkPiiPiiKeys200ResponseValue>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkPiiPiiKeysAsync
     *
     * List the keys required to access Personally Identifiable Information (PII) for a given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiPiiKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiPiiKeysAsync($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiPiiKeys'][0])
    {
        return $this->getNetworkPiiPiiKeysAsyncWithHttpInfo($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkPiiPiiKeysAsyncWithHttpInfo
     *
     * List the keys required to access Personally Identifiable Information (PII) for a given identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiPiiKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiPiiKeysAsyncWithHttpInfo($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiPiiKeys'][0])
    {
        $returnType = 'array<string,\Meraki\Model\GetNetworkPiiPiiKeys200ResponseValue>';
        $request = $this->getNetworkPiiPiiKeysRequest($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkPiiPiiKeys'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiPiiKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkPiiPiiKeysRequest($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiPiiKeys'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkPiiPiiKeys'
            );
        }








        $resourcePath = '/networks/{networkId}/pii/piiKeys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username,
            'username', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mac,
            'mac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serial,
            'serial', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $imei,
            'imei', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bluetooth_mac,
            'bluetoothMac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkPiiRequest
     *
     * Return a PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkPiiRequests200ResponseInner
     */
    public function getNetworkPiiRequest($network_id, $request_id, string $contentType = self::contentTypes['getNetworkPiiRequest'][0])
    {
        list($response) = $this->getNetworkPiiRequestWithHttpInfo($network_id, $request_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkPiiRequestWithHttpInfo
     *
     * Return a PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkPiiRequests200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkPiiRequestWithHttpInfo($network_id, $request_id, string $contentType = self::contentTypes['getNetworkPiiRequest'][0])
    {
        $request = $this->getNetworkPiiRequestRequest($network_id, $request_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkPiiRequests200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkPiiRequests200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkPiiRequests200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkPiiRequests200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkPiiRequests200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkPiiRequestAsync
     *
     * Return a PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiRequestAsync($network_id, $request_id, string $contentType = self::contentTypes['getNetworkPiiRequest'][0])
    {
        return $this->getNetworkPiiRequestAsyncWithHttpInfo($network_id, $request_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkPiiRequestAsyncWithHttpInfo
     *
     * Return a PII request
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiRequestAsyncWithHttpInfo($network_id, $request_id, string $contentType = self::contentTypes['getNetworkPiiRequest'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkPiiRequests200ResponseInner';
        $request = $this->getNetworkPiiRequestRequest($network_id, $request_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkPiiRequest'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $request_id Request ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkPiiRequestRequest($network_id, $request_id, string $contentType = self::contentTypes['getNetworkPiiRequest'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkPiiRequest'
            );
        }

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getNetworkPiiRequest'
            );
        }


        $resourcePath = '/networks/{networkId}/pii/requests/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkPiiRequests
     *
     * List the PII requests for this network or organization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequests'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkPiiRequests200ResponseInner[]
     */
    public function getNetworkPiiRequests($network_id, string $contentType = self::contentTypes['getNetworkPiiRequests'][0])
    {
        list($response) = $this->getNetworkPiiRequestsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkPiiRequestsWithHttpInfo
     *
     * List the PII requests for this network or organization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequests'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkPiiRequests200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkPiiRequestsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkPiiRequests'][0])
    {
        $request = $this->getNetworkPiiRequestsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkPiiRequests200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkPiiRequests200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkPiiRequests200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkPiiRequests200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkPiiRequests200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkPiiRequestsAsync
     *
     * List the PII requests for this network or organization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiRequestsAsync($network_id, string $contentType = self::contentTypes['getNetworkPiiRequests'][0])
    {
        return $this->getNetworkPiiRequestsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkPiiRequestsAsyncWithHttpInfo
     *
     * List the PII requests for this network or organization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiRequestsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkPiiRequests'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkPiiRequests200ResponseInner[]';
        $request = $this->getNetworkPiiRequestsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkPiiRequests'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiRequests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkPiiRequestsRequest($network_id, string $contentType = self::contentTypes['getNetworkPiiRequests'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkPiiRequests'
            );
        }


        $resourcePath = '/networks/{networkId}/pii/requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkPiiSmDevicesForKey
     *
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmDevicesForKey'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,string[]>
     */
    public function getNetworkPiiSmDevicesForKey($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmDevicesForKey'][0])
    {
        list($response) = $this->getNetworkPiiSmDevicesForKeyWithHttpInfo($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkPiiSmDevicesForKeyWithHttpInfo
     *
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmDevicesForKey'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,string[]>, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkPiiSmDevicesForKeyWithHttpInfo($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmDevicesForKey'][0])
    {
        $request = $this->getNetworkPiiSmDevicesForKeyRequest($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('array<string,string[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string[]>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'array<string,string[]>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkPiiSmDevicesForKeyAsync
     *
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmDevicesForKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiSmDevicesForKeyAsync($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmDevicesForKey'][0])
    {
        return $this->getNetworkPiiSmDevicesForKeyAsyncWithHttpInfo($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkPiiSmDevicesForKeyAsyncWithHttpInfo
     *
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmDevicesForKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiSmDevicesForKeyAsyncWithHttpInfo($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmDevicesForKey'][0])
    {
        $returnType = 'array<string,string[]>';
        $request = $this->getNetworkPiiSmDevicesForKeyRequest($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkPiiSmDevicesForKey'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmDevicesForKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkPiiSmDevicesForKeyRequest($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmDevicesForKey'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkPiiSmDevicesForKey'
            );
        }








        $resourcePath = '/networks/{networkId}/pii/smDevicesForKey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username,
            'username', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mac,
            'mac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serial,
            'serial', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $imei,
            'imei', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bluetooth_mac,
            'bluetoothMac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkPiiSmOwnersForKey
     *
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmOwnersForKey'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,string[]>
     */
    public function getNetworkPiiSmOwnersForKey($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmOwnersForKey'][0])
    {
        list($response) = $this->getNetworkPiiSmOwnersForKeyWithHttpInfo($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkPiiSmOwnersForKeyWithHttpInfo
     *
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmOwnersForKey'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,string[]>, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkPiiSmOwnersForKeyWithHttpInfo($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmOwnersForKey'][0])
    {
        $request = $this->getNetworkPiiSmOwnersForKeyRequest($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('array<string,string[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string[]>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'array<string,string[]>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkPiiSmOwnersForKeyAsync
     *
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmOwnersForKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiSmOwnersForKeyAsync($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmOwnersForKey'][0])
    {
        return $this->getNetworkPiiSmOwnersForKeyAsyncWithHttpInfo($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkPiiSmOwnersForKeyAsyncWithHttpInfo
     *
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmOwnersForKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPiiSmOwnersForKeyAsyncWithHttpInfo($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmOwnersForKey'][0])
    {
        $returnType = 'array<string,string[]>';
        $request = $this->getNetworkPiiSmOwnersForKeyRequest($network_id, $username, $email, $mac, $serial, $imei, $bluetooth_mac, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkPiiSmOwnersForKey'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $username The username of a Systems Manager user (optional)
     * @param  string|null $email The email of a network user account or a Systems Manager device (optional)
     * @param  string|null $mac The MAC of a network client device or a Systems Manager device (optional)
     * @param  string|null $serial The serial of a Systems Manager device (optional)
     * @param  string|null $imei The IMEI of a Systems Manager device (optional)
     * @param  string|null $bluetooth_mac The MAC of a Bluetooth client (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPiiSmOwnersForKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkPiiSmOwnersForKeyRequest($network_id, $username = null, $email = null, $mac = null, $serial = null, $imei = null, $bluetooth_mac = null, string $contentType = self::contentTypes['getNetworkPiiSmOwnersForKey'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkPiiSmOwnersForKey'
            );
        }








        $resourcePath = '/networks/{networkId}/pii/smOwnersForKey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username,
            'username', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mac,
            'mac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serial,
            'serial', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $imei,
            'imei', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bluetooth_mac,
            'bluetoothMac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkPoliciesByClient
     *
     * Get policies for all clients with policies
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPoliciesByClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkPoliciesByClient200ResponseInner[]
     */
    public function getNetworkPoliciesByClient($network_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkPoliciesByClient'][0])
    {
        list($response) = $this->getNetworkPoliciesByClientWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $t0, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkPoliciesByClientWithHttpInfo
     *
     * Get policies for all clients with policies
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPoliciesByClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkPoliciesByClient200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkPoliciesByClientWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkPoliciesByClient'][0])
    {
        $request = $this->getNetworkPoliciesByClientRequest($network_id, $per_page, $starting_after, $ending_before, $t0, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkPoliciesByClient200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkPoliciesByClient200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkPoliciesByClient200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkPoliciesByClient200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkPoliciesByClient200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkPoliciesByClientAsync
     *
     * Get policies for all clients with policies
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPoliciesByClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPoliciesByClientAsync($network_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkPoliciesByClient'][0])
    {
        return $this->getNetworkPoliciesByClientAsyncWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $t0, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkPoliciesByClientAsyncWithHttpInfo
     *
     * Get policies for all clients with policies
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPoliciesByClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkPoliciesByClientAsyncWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkPoliciesByClient'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkPoliciesByClient200ResponseInner[]';
        $request = $this->getNetworkPoliciesByClientRequest($network_id, $per_page, $starting_after, $ending_before, $t0, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkPoliciesByClient'
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkPoliciesByClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkPoliciesByClientRequest($network_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getNetworkPoliciesByClient'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkPoliciesByClient'
            );
        }





        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling NetworksApi.getNetworkPoliciesByClient, must be smaller than or equal to 2678400.');
        }
        

        $resourcePath = '/networks/{networkId}/policies/byClient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSettings
     *
     * Return the settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSettings200Response
     */
    public function getNetworkSettings($network_id, string $contentType = self::contentTypes['getNetworkSettings'][0])
    {
        list($response) = $this->getNetworkSettingsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSettingsWithHttpInfo
     *
     * Return the settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSettingsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSettings'][0])
    {
        $request = $this->getNetworkSettingsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSettingsAsync
     *
     * Return the settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSettingsAsync($network_id, string $contentType = self::contentTypes['getNetworkSettings'][0])
    {
        return $this->getNetworkSettingsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSettingsAsyncWithHttpInfo
     *
     * Return the settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSettingsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSettings200Response';
        $request = $this->getNetworkSettingsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSettingsRequest($network_id, string $contentType = self::contentTypes['getNetworkSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSettings'
            );
        }


        $resourcePath = '/networks/{networkId}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSnmp
     *
     * Return the SNMP settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSnmp200Response
     */
    public function getNetworkSnmp($network_id, string $contentType = self::contentTypes['getNetworkSnmp'][0])
    {
        list($response) = $this->getNetworkSnmpWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSnmpWithHttpInfo
     *
     * Return the SNMP settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSnmp200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSnmpWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSnmp'][0])
    {
        $request = $this->getNetworkSnmpRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSnmp200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSnmp200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSnmp200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSnmp200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSnmp200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSnmpAsync
     *
     * Return the SNMP settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSnmpAsync($network_id, string $contentType = self::contentTypes['getNetworkSnmp'][0])
    {
        return $this->getNetworkSnmpAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSnmpAsyncWithHttpInfo
     *
     * Return the SNMP settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSnmpAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSnmp'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSnmp200Response';
        $request = $this->getNetworkSnmpRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSnmp'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSnmpRequest($network_id, string $contentType = self::contentTypes['getNetworkSnmp'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSnmp'
            );
        }


        $resourcePath = '/networks/{networkId}/snmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSplashLoginAttempts
     *
     * List the splash login attempts for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string|null $login_identifier The username, email, or phone number used during login (optional)
     * @param  int|null $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSplashLoginAttempts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSplashLoginAttempts200ResponseInner[]
     */
    public function getNetworkSplashLoginAttempts($network_id, $ssid_number = null, $login_identifier = null, $timespan = null, string $contentType = self::contentTypes['getNetworkSplashLoginAttempts'][0])
    {
        list($response) = $this->getNetworkSplashLoginAttemptsWithHttpInfo($network_id, $ssid_number, $login_identifier, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSplashLoginAttemptsWithHttpInfo
     *
     * List the splash login attempts for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string|null $login_identifier The username, email, or phone number used during login (optional)
     * @param  int|null $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSplashLoginAttempts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSplashLoginAttempts200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSplashLoginAttemptsWithHttpInfo($network_id, $ssid_number = null, $login_identifier = null, $timespan = null, string $contentType = self::contentTypes['getNetworkSplashLoginAttempts'][0])
    {
        $request = $this->getNetworkSplashLoginAttemptsRequest($network_id, $ssid_number, $login_identifier, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSplashLoginAttempts200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSplashLoginAttempts200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSplashLoginAttempts200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSplashLoginAttempts200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSplashLoginAttempts200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSplashLoginAttemptsAsync
     *
     * List the splash login attempts for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string|null $login_identifier The username, email, or phone number used during login (optional)
     * @param  int|null $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSplashLoginAttempts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSplashLoginAttemptsAsync($network_id, $ssid_number = null, $login_identifier = null, $timespan = null, string $contentType = self::contentTypes['getNetworkSplashLoginAttempts'][0])
    {
        return $this->getNetworkSplashLoginAttemptsAsyncWithHttpInfo($network_id, $ssid_number, $login_identifier, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSplashLoginAttemptsAsyncWithHttpInfo
     *
     * List the splash login attempts for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string|null $login_identifier The username, email, or phone number used during login (optional)
     * @param  int|null $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSplashLoginAttempts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSplashLoginAttemptsAsyncWithHttpInfo($network_id, $ssid_number = null, $login_identifier = null, $timespan = null, string $contentType = self::contentTypes['getNetworkSplashLoginAttempts'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSplashLoginAttempts200ResponseInner[]';
        $request = $this->getNetworkSplashLoginAttemptsRequest($network_id, $ssid_number, $login_identifier, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSplashLoginAttempts'
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string|null $login_identifier The username, email, or phone number used during login (optional)
     * @param  int|null $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSplashLoginAttempts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSplashLoginAttemptsRequest($network_id, $ssid_number = null, $login_identifier = null, $timespan = null, string $contentType = self::contentTypes['getNetworkSplashLoginAttempts'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSplashLoginAttempts'
            );
        }





        $resourcePath = '/networks/{networkId}/splashLoginAttempts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_number,
            'ssidNumber', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $login_identifier,
            'loginIdentifier', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSyslogServers
     *
     * List the syslog servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSyslogServers200Response
     */
    public function getNetworkSyslogServers($network_id, string $contentType = self::contentTypes['getNetworkSyslogServers'][0])
    {
        list($response) = $this->getNetworkSyslogServersWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSyslogServersWithHttpInfo
     *
     * List the syslog servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSyslogServers200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSyslogServersWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSyslogServers'][0])
    {
        $request = $this->getNetworkSyslogServersRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSyslogServers200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSyslogServers200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSyslogServers200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSyslogServers200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSyslogServers200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSyslogServersAsync
     *
     * List the syslog servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSyslogServersAsync($network_id, string $contentType = self::contentTypes['getNetworkSyslogServers'][0])
    {
        return $this->getNetworkSyslogServersAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSyslogServersAsyncWithHttpInfo
     *
     * List the syslog servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSyslogServersAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkSyslogServers'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSyslogServers200Response';
        $request = $this->getNetworkSyslogServersRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSyslogServers'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSyslogServersRequest($network_id, string $contentType = self::contentTypes['getNetworkSyslogServers'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSyslogServers'
            );
        }


        $resourcePath = '/networks/{networkId}/syslogServers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkTopologyLinkLayer
     *
     * List the LLDP and CDP information for all discovered devices and connections in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTopologyLinkLayer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkTopologyLinkLayer($network_id, string $contentType = self::contentTypes['getNetworkTopologyLinkLayer'][0])
    {
        list($response) = $this->getNetworkTopologyLinkLayerWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkTopologyLinkLayerWithHttpInfo
     *
     * List the LLDP and CDP information for all discovered devices and connections in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTopologyLinkLayer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkTopologyLinkLayerWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkTopologyLinkLayer'][0])
    {
        $request = $this->getNetworkTopologyLinkLayerRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkTopologyLinkLayerAsync
     *
     * List the LLDP and CDP information for all discovered devices and connections in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTopologyLinkLayer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTopologyLinkLayerAsync($network_id, string $contentType = self::contentTypes['getNetworkTopologyLinkLayer'][0])
    {
        return $this->getNetworkTopologyLinkLayerAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkTopologyLinkLayerAsyncWithHttpInfo
     *
     * List the LLDP and CDP information for all discovered devices and connections in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTopologyLinkLayer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTopologyLinkLayerAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkTopologyLinkLayer'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkTopologyLinkLayerRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkTopologyLinkLayer'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTopologyLinkLayer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkTopologyLinkLayerRequest($network_id, string $contentType = self::contentTypes['getNetworkTopologyLinkLayer'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkTopologyLinkLayer'
            );
        }


        $resourcePath = '/networks/{networkId}/topology/linkLayer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkTraffic
     *
     * Return the traffic analysis data for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string|null $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTraffic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkTraffic200ResponseInner[]
     */
    public function getNetworkTraffic($network_id, $t0 = null, $timespan = null, $device_type = null, string $contentType = self::contentTypes['getNetworkTraffic'][0])
    {
        list($response) = $this->getNetworkTrafficWithHttpInfo($network_id, $t0, $timespan, $device_type, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkTrafficWithHttpInfo
     *
     * Return the traffic analysis data for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string|null $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTraffic'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkTraffic200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkTrafficWithHttpInfo($network_id, $t0 = null, $timespan = null, $device_type = null, string $contentType = self::contentTypes['getNetworkTraffic'][0])
    {
        $request = $this->getNetworkTrafficRequest($network_id, $t0, $timespan, $device_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkTraffic200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkTraffic200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkTraffic200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkTraffic200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkTraffic200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkTrafficAsync
     *
     * Return the traffic analysis data for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string|null $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTraffic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficAsync($network_id, $t0 = null, $timespan = null, $device_type = null, string $contentType = self::contentTypes['getNetworkTraffic'][0])
    {
        return $this->getNetworkTrafficAsyncWithHttpInfo($network_id, $t0, $timespan, $device_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkTrafficAsyncWithHttpInfo
     *
     * Return the traffic analysis data for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string|null $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTraffic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficAsyncWithHttpInfo($network_id, $t0 = null, $timespan = null, $device_type = null, string $contentType = self::contentTypes['getNetworkTraffic'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkTraffic200ResponseInner[]';
        $request = $this->getNetworkTrafficRequest($network_id, $t0, $timespan, $device_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkTraffic'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string|null $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTraffic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkTrafficRequest($network_id, $t0 = null, $timespan = null, $device_type = null, string $contentType = self::contentTypes['getNetworkTraffic'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkTraffic'
            );
        }


        if ($timespan !== null && $timespan > 2592000) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling NetworksApi.getNetworkTraffic, must be smaller than or equal to 2592000.');
        }
        


        $resourcePath = '/networks/{networkId}/traffic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_type,
            'deviceType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkTrafficAnalysis
     *
     * Return the traffic analysis settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkTrafficAnalysis200Response
     */
    public function getNetworkTrafficAnalysis($network_id, string $contentType = self::contentTypes['getNetworkTrafficAnalysis'][0])
    {
        list($response) = $this->getNetworkTrafficAnalysisWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkTrafficAnalysisWithHttpInfo
     *
     * Return the traffic analysis settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkTrafficAnalysis200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkTrafficAnalysisWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkTrafficAnalysis'][0])
    {
        $request = $this->getNetworkTrafficAnalysisRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkTrafficAnalysis200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkTrafficAnalysis200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkTrafficAnalysis200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkTrafficAnalysis200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkTrafficAnalysis200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkTrafficAnalysisAsync
     *
     * Return the traffic analysis settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficAnalysisAsync($network_id, string $contentType = self::contentTypes['getNetworkTrafficAnalysis'][0])
    {
        return $this->getNetworkTrafficAnalysisAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkTrafficAnalysisAsyncWithHttpInfo
     *
     * Return the traffic analysis settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficAnalysisAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkTrafficAnalysis'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkTrafficAnalysis200Response';
        $request = $this->getNetworkTrafficAnalysisRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkTrafficAnalysis'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkTrafficAnalysisRequest($network_id, string $contentType = self::contentTypes['getNetworkTrafficAnalysis'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkTrafficAnalysis'
            );
        }


        $resourcePath = '/networks/{networkId}/trafficAnalysis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkTrafficShapingApplicationCategories
     *
     * Returns the application categories for traffic shaping rules
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingApplicationCategories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkTrafficShapingApplicationCategories($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingApplicationCategories'][0])
    {
        list($response) = $this->getNetworkTrafficShapingApplicationCategoriesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkTrafficShapingApplicationCategoriesWithHttpInfo
     *
     * Returns the application categories for traffic shaping rules
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingApplicationCategories'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkTrafficShapingApplicationCategoriesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingApplicationCategories'][0])
    {
        $request = $this->getNetworkTrafficShapingApplicationCategoriesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkTrafficShapingApplicationCategoriesAsync
     *
     * Returns the application categories for traffic shaping rules
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingApplicationCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficShapingApplicationCategoriesAsync($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingApplicationCategories'][0])
    {
        return $this->getNetworkTrafficShapingApplicationCategoriesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkTrafficShapingApplicationCategoriesAsyncWithHttpInfo
     *
     * Returns the application categories for traffic shaping rules
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingApplicationCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficShapingApplicationCategoriesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingApplicationCategories'][0])
    {
        $returnType = 'object';
        $request = $this->getNetworkTrafficShapingApplicationCategoriesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkTrafficShapingApplicationCategories'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingApplicationCategories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkTrafficShapingApplicationCategoriesRequest($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingApplicationCategories'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkTrafficShapingApplicationCategories'
            );
        }


        $resourcePath = '/networks/{networkId}/trafficShaping/applicationCategories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkTrafficShapingDscpTaggingOptions
     *
     * Returns the available DSCP tagging options for your traffic shaping rules.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getNetworkTrafficShapingDscpTaggingOptions($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'][0])
    {
        list($response) = $this->getNetworkTrafficShapingDscpTaggingOptionsWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkTrafficShapingDscpTaggingOptionsWithHttpInfo
     *
     * Returns the available DSCP tagging options for your traffic shaping rules.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkTrafficShapingDscpTaggingOptionsWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'][0])
    {
        $request = $this->getNetworkTrafficShapingDscpTaggingOptionsRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkTrafficShapingDscpTaggingOptionsAsync
     *
     * Returns the available DSCP tagging options for your traffic shaping rules.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficShapingDscpTaggingOptionsAsync($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'][0])
    {
        return $this->getNetworkTrafficShapingDscpTaggingOptionsAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkTrafficShapingDscpTaggingOptionsAsyncWithHttpInfo
     *
     * Returns the available DSCP tagging options for your traffic shaping rules.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficShapingDscpTaggingOptionsAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'][0])
    {
        $returnType = 'object[]';
        $request = $this->getNetworkTrafficShapingDscpTaggingOptionsRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkTrafficShapingDscpTaggingOptions'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkTrafficShapingDscpTaggingOptionsRequest($network_id, string $contentType = self::contentTypes['getNetworkTrafficShapingDscpTaggingOptions'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkTrafficShapingDscpTaggingOptions'
            );
        }


        $resourcePath = '/networks/{networkId}/trafficShaping/dscpTaggingOptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkVlanProfile
     *
     * Get an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfiles200ResponseInner
     */
    public function getNetworkVlanProfile($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {
        list($response) = $this->getNetworkVlanProfileWithHttpInfo($network_id, $iname, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkVlanProfileWithHttpInfo
     *
     * Get an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkVlanProfileWithHttpInfo($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {
        $request = $this->getNetworkVlanProfileRequest($network_id, $iname, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkVlanProfileAsync
     *
     * Get an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfileAsync($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {
        return $this->getNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkVlanProfileAsyncWithHttpInfo
     *
     * Get an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
        $request = $this->getNetworkVlanProfileRequest($network_id, $iname, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkVlanProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkVlanProfileRequest($network_id, $iname, string $contentType = self::contentTypes['getNetworkVlanProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkVlanProfile'
            );
        }

        // verify the required parameter 'iname' is set
        if ($iname === null || (is_array($iname) && count($iname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iname when calling getNetworkVlanProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles/{iname}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($iname !== null) {
            $resourcePath = str_replace(
                '{' . 'iname' . '}',
                ObjectSerializer::toPathValue($iname),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkVlanProfiles
     *
     * List VLAN profiles for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]
     */
    public function getNetworkVlanProfiles($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {
        list($response) = $this->getNetworkVlanProfilesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkVlanProfilesWithHttpInfo
     *
     * List VLAN profiles for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfiles200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkVlanProfilesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {
        $request = $this->getNetworkVlanProfilesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkVlanProfilesAsync
     *
     * List VLAN profiles for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfilesAsync($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {
        return $this->getNetworkVlanProfilesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkVlanProfilesAsyncWithHttpInfo
     *
     * List VLAN profiles for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfilesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner[]';
        $request = $this->getNetworkVlanProfilesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkVlanProfiles'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkVlanProfilesRequest($network_id, string $contentType = self::contentTypes['getNetworkVlanProfiles'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkVlanProfiles'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkVlanProfilesAssignmentsByDevice
     *
     * Get the assigned VLAN Profiles for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]
     */
    public function getNetworkVlanProfilesAssignmentsByDevice($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {
        list($response) = $this->getNetworkVlanProfilesAssignmentsByDeviceWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $serials, $product_types, $stack_ids, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkVlanProfilesAssignmentsByDeviceWithHttpInfo
     *
     * Get the assigned VLAN Profiles for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkVlanProfilesAssignmentsByDeviceWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {
        $request = $this->getNetworkVlanProfilesAssignmentsByDeviceRequest($network_id, $per_page, $starting_after, $ending_before, $serials, $product_types, $stack_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkVlanProfilesAssignmentsByDeviceAsync
     *
     * Get the assigned VLAN Profiles for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfilesAssignmentsByDeviceAsync($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {
        return $this->getNetworkVlanProfilesAssignmentsByDeviceAsyncWithHttpInfo($network_id, $per_page, $starting_after, $ending_before, $serials, $product_types, $stack_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkVlanProfilesAssignmentsByDeviceAsyncWithHttpInfo
     *
     * Get the assigned VLAN Profiles for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkVlanProfilesAssignmentsByDeviceAsyncWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfilesAssignmentsByDevice200ResponseInner[]';
        $request = $this->getNetworkVlanProfilesAssignmentsByDeviceRequest($network_id, $per_page, $starting_after, $ending_before, $serials, $product_types, $stack_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkVlanProfilesAssignmentsByDevice'
     *
     * @param  string $network_id Network ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. All devices returned belong to serial numbers that are an exact match. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product types. (optional)
     * @param  string[]|null $stack_ids Optional parameter to filter devices by Switch Stack ids. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkVlanProfilesAssignmentsByDeviceRequest($network_id, $per_page = null, $starting_after = null, $ending_before = null, $serials = null, $product_types = null, $stack_ids = null, string $contentType = self::contentTypes['getNetworkVlanProfilesAssignmentsByDevice'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkVlanProfilesAssignmentsByDevice'
            );
        }








        $resourcePath = '/networks/{networkId}/vlanProfiles/assignments/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stack_ids,
            'stackIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksHttpServer
     *
     * Return an HTTP server for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner
     */
    public function getNetworkWebhooksHttpServer($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {
        list($response) = $this->getNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksHttpServerWithHttpInfo
     *
     * Return an HTTP server for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {
        $request = $this->getNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksHttpServerAsync
     *
     * Return an HTTP server for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksHttpServerAsync($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {
        return $this->getNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksHttpServerAsyncWithHttpInfo
     *
     * Return an HTTP server for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
        $request = $this->getNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksHttpServer'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksHttpServerRequest($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksHttpServer'
            );
        }

        // verify the required parameter 'http_server_id' is set
        if ($http_server_id === null || (is_array($http_server_id) && count($http_server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_server_id when calling getNetworkWebhooksHttpServer'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/httpServers/{httpServerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($http_server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'httpServerId' . '}',
                ObjectSerializer::toPathValue($http_server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksHttpServers
     *
     * List the HTTP servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]
     */
    public function getNetworkWebhooksHttpServers($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {
        list($response) = $this->getNetworkWebhooksHttpServersWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksHttpServersWithHttpInfo
     *
     * List the HTTP servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksHttpServersWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {
        $request = $this->getNetworkWebhooksHttpServersRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksHttpServersAsync
     *
     * List the HTTP servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksHttpServersAsync($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {
        return $this->getNetworkWebhooksHttpServersAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksHttpServersAsyncWithHttpInfo
     *
     * List the HTTP servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksHttpServersAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]';
        $request = $this->getNetworkWebhooksHttpServersRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksHttpServers'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksHttpServersRequest($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksHttpServers'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/httpServers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplate
     *
     * Get the webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner
     */
    public function getNetworkWebhooksPayloadTemplate($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {
        list($response) = $this->getNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplateWithHttpInfo
     *
     * Get the webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {
        $request = $this->getNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplateAsync
     *
     * Get the webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksPayloadTemplateAsync($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {
        return $this->getNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplateAsyncWithHttpInfo
     *
     * Get the webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
        $request = $this->getNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksPayloadTemplate'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksPayloadTemplate'
            );
        }

        // verify the required parameter 'payload_template_id' is set
        if ($payload_template_id === null || (is_array($payload_template_id) && count($payload_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payload_template_id when calling getNetworkWebhooksPayloadTemplate'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($payload_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'payloadTemplateId' . '}',
                ObjectSerializer::toPathValue($payload_template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplates
     *
     * List the webhook payload templates for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]
     */
    public function getNetworkWebhooksPayloadTemplates($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {
        list($response) = $this->getNetworkWebhooksPayloadTemplatesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplatesWithHttpInfo
     *
     * List the webhook payload templates for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksPayloadTemplatesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {
        $request = $this->getNetworkWebhooksPayloadTemplatesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplatesAsync
     *
     * List the webhook payload templates for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksPayloadTemplatesAsync($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {
        return $this->getNetworkWebhooksPayloadTemplatesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplatesAsyncWithHttpInfo
     *
     * List the webhook payload templates for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksPayloadTemplatesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]';
        $request = $this->getNetworkWebhooksPayloadTemplatesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksPayloadTemplates'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksPayloadTemplatesRequest($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksPayloadTemplates'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksWebhookTest
     *
     * Return the status of a webhook test for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateNetworkWebhooksWebhookTest201Response
     */
    public function getNetworkWebhooksWebhookTest($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {
        list($response) = $this->getNetworkWebhooksWebhookTestWithHttpInfo($network_id, $webhook_test_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksWebhookTestWithHttpInfo
     *
     * Return the status of a webhook test for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateNetworkWebhooksWebhookTest201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksWebhookTestWithHttpInfo($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {
        $request = $this->getNetworkWebhooksWebhookTestRequest($network_id, $webhook_test_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksWebhookTestAsync
     *
     * Return the status of a webhook test for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksWebhookTestAsync($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {
        return $this->getNetworkWebhooksWebhookTestAsyncWithHttpInfo($network_id, $webhook_test_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksWebhookTestAsyncWithHttpInfo
     *
     * Return the status of a webhook test for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksWebhookTestAsyncWithHttpInfo($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {
        $returnType = '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response';
        $request = $this->getNetworkWebhooksWebhookTestRequest($network_id, $webhook_test_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksWebhookTest'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksWebhookTestRequest($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksWebhookTest'
            );
        }

        // verify the required parameter 'webhook_test_id' is set
        if ($webhook_test_id === null || (is_array($webhook_test_id) && count($webhook_test_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_test_id when calling getNetworkWebhooksWebhookTest'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/webhookTests/{webhookTestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_test_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookTestId' . '}',
                ObjectSerializer::toPathValue($webhook_test_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationIntegrationsXdrNetworks
     *
     * Returns the networks in the organization that have XDR enabled
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationIntegrationsXdrNetworks200Response
     */
    public function getOrganizationIntegrationsXdrNetworks($organization_id, $network_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationIntegrationsXdrNetworks'][0])
    {
        list($response) = $this->getOrganizationIntegrationsXdrNetworksWithHttpInfo($organization_id, $network_ids, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationIntegrationsXdrNetworksWithHttpInfo
     *
     * Returns the networks in the organization that have XDR enabled
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationIntegrationsXdrNetworks200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationIntegrationsXdrNetworksWithHttpInfo($organization_id, $network_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationIntegrationsXdrNetworks'][0])
    {
        $request = $this->getOrganizationIntegrationsXdrNetworksRequest($organization_id, $network_ids, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationIntegrationsXdrNetworks200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationIntegrationsXdrNetworks200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationIntegrationsXdrNetworks200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationIntegrationsXdrNetworks200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationIntegrationsXdrNetworks200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationIntegrationsXdrNetworksAsync
     *
     * Returns the networks in the organization that have XDR enabled
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationIntegrationsXdrNetworksAsync($organization_id, $network_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationIntegrationsXdrNetworks'][0])
    {
        return $this->getOrganizationIntegrationsXdrNetworksAsyncWithHttpInfo($organization_id, $network_ids, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationIntegrationsXdrNetworksAsyncWithHttpInfo
     *
     * Returns the networks in the organization that have XDR enabled
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationIntegrationsXdrNetworksAsyncWithHttpInfo($organization_id, $network_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationIntegrationsXdrNetworks'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationIntegrationsXdrNetworks200Response';
        $request = $this->getOrganizationIntegrationsXdrNetworksRequest($organization_id, $network_ids, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationIntegrationsXdrNetworks'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter the results by network IDs (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 20. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationIntegrationsXdrNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationIntegrationsXdrNetworksRequest($organization_id, $network_ids = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationIntegrationsXdrNetworks'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationIntegrationsXdrNetworks'
            );
        }






        $resourcePath = '/organizations/{organizationId}/integrations/xdr/networks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationInventoryOnboardingCloudMonitoringNetworks
     *
     * Returns list of networks eligible for adding cloud monitored device
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $device_type Device Type switch or wireless controller (required)
     * @param  string|null $search Optional parameter to search on network name (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetwork200Response[]
     */
    public function getOrganizationInventoryOnboardingCloudMonitoringNetworks($organization_id, $device_type, $search = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'][0])
    {
        list($response) = $this->getOrganizationInventoryOnboardingCloudMonitoringNetworksWithHttpInfo($organization_id, $device_type, $search, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationInventoryOnboardingCloudMonitoringNetworksWithHttpInfo
     *
     * Returns list of networks eligible for adding cloud monitored device
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $device_type Device Type switch or wireless controller (required)
     * @param  string|null $search Optional parameter to search on network name (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetwork200Response[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationInventoryOnboardingCloudMonitoringNetworksWithHttpInfo($organization_id, $device_type, $search = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'][0])
    {
        $request = $this->getOrganizationInventoryOnboardingCloudMonitoringNetworksRequest($organization_id, $device_type, $search, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\Meraki\Model\GetNetwork200Response[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetwork200Response[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetwork200Response[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetwork200Response[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetwork200Response[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationInventoryOnboardingCloudMonitoringNetworksAsync
     *
     * Returns list of networks eligible for adding cloud monitored device
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $device_type Device Type switch or wireless controller (required)
     * @param  string|null $search Optional parameter to search on network name (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationInventoryOnboardingCloudMonitoringNetworksAsync($organization_id, $device_type, $search = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'][0])
    {
        return $this->getOrganizationInventoryOnboardingCloudMonitoringNetworksAsyncWithHttpInfo($organization_id, $device_type, $search, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationInventoryOnboardingCloudMonitoringNetworksAsyncWithHttpInfo
     *
     * Returns list of networks eligible for adding cloud monitored device
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $device_type Device Type switch or wireless controller (required)
     * @param  string|null $search Optional parameter to search on network name (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationInventoryOnboardingCloudMonitoringNetworksAsyncWithHttpInfo($organization_id, $device_type, $search = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'][0])
    {
        $returnType = '\Meraki\Model\GetNetwork200Response[]';
        $request = $this->getOrganizationInventoryOnboardingCloudMonitoringNetworksRequest($organization_id, $device_type, $search, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationInventoryOnboardingCloudMonitoringNetworks'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $device_type Device Type switch or wireless controller (required)
     * @param  string|null $search Optional parameter to search on network name (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationInventoryOnboardingCloudMonitoringNetworksRequest($organization_id, $device_type, $search = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationInventoryOnboardingCloudMonitoringNetworks'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationInventoryOnboardingCloudMonitoringNetworks'
            );
        }

        // verify the required parameter 'device_type' is set
        if ($device_type === null || (is_array($device_type) && count($device_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_type when calling getOrganizationInventoryOnboardingCloudMonitoringNetworks'
            );
        }






        $resourcePath = '/organizations/{organizationId}/inventory/onboarding/cloudMonitoring/networks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_type,
            'deviceType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationNetworks
     *
     * List the networks that the user has privileges on in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $config_template_id An optional parameter that is the ID of a config template. Will return all networks bound to that template. (optional)
     * @param  bool|null $is_bound_to_config_template An optional parameter to filter config template bound networks. If configTemplateId is set, this cannot be false. (optional)
     * @param  string[]|null $tags An optional parameter to filter networks by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $product_types An optional parameter to filter networks by product type. Results will have at least one of the included product types. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetwork200Response[]
     */
    public function getOrganizationNetworks($organization_id, $config_template_id = null, $is_bound_to_config_template = null, $tags = null, $tags_filter_type = null, $product_types = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationNetworks'][0])
    {
        list($response) = $this->getOrganizationNetworksWithHttpInfo($organization_id, $config_template_id, $is_bound_to_config_template, $tags, $tags_filter_type, $product_types, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationNetworksWithHttpInfo
     *
     * List the networks that the user has privileges on in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $config_template_id An optional parameter that is the ID of a config template. Will return all networks bound to that template. (optional)
     * @param  bool|null $is_bound_to_config_template An optional parameter to filter config template bound networks. If configTemplateId is set, this cannot be false. (optional)
     * @param  string[]|null $tags An optional parameter to filter networks by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $product_types An optional parameter to filter networks by product type. Results will have at least one of the included product types. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetwork200Response[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationNetworksWithHttpInfo($organization_id, $config_template_id = null, $is_bound_to_config_template = null, $tags = null, $tags_filter_type = null, $product_types = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationNetworks'][0])
    {
        $request = $this->getOrganizationNetworksRequest($organization_id, $config_template_id, $is_bound_to_config_template, $tags, $tags_filter_type, $product_types, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetwork200Response[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetwork200Response[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetwork200Response[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetwork200Response[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetwork200Response[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationNetworksAsync
     *
     * List the networks that the user has privileges on in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $config_template_id An optional parameter that is the ID of a config template. Will return all networks bound to that template. (optional)
     * @param  bool|null $is_bound_to_config_template An optional parameter to filter config template bound networks. If configTemplateId is set, this cannot be false. (optional)
     * @param  string[]|null $tags An optional parameter to filter networks by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $product_types An optional parameter to filter networks by product type. Results will have at least one of the included product types. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationNetworksAsync($organization_id, $config_template_id = null, $is_bound_to_config_template = null, $tags = null, $tags_filter_type = null, $product_types = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationNetworks'][0])
    {
        return $this->getOrganizationNetworksAsyncWithHttpInfo($organization_id, $config_template_id, $is_bound_to_config_template, $tags, $tags_filter_type, $product_types, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationNetworksAsyncWithHttpInfo
     *
     * List the networks that the user has privileges on in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $config_template_id An optional parameter that is the ID of a config template. Will return all networks bound to that template. (optional)
     * @param  bool|null $is_bound_to_config_template An optional parameter to filter config template bound networks. If configTemplateId is set, this cannot be false. (optional)
     * @param  string[]|null $tags An optional parameter to filter networks by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $product_types An optional parameter to filter networks by product type. Results will have at least one of the included product types. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationNetworksAsyncWithHttpInfo($organization_id, $config_template_id = null, $is_bound_to_config_template = null, $tags = null, $tags_filter_type = null, $product_types = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationNetworks'][0])
    {
        $returnType = '\Meraki\Model\GetNetwork200Response[]';
        $request = $this->getOrganizationNetworksRequest($organization_id, $config_template_id, $is_bound_to_config_template, $tags, $tags_filter_type, $product_types, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationNetworks'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $config_template_id An optional parameter that is the ID of a config template. Will return all networks bound to that template. (optional)
     * @param  bool|null $is_bound_to_config_template An optional parameter to filter config template bound networks. If configTemplateId is set, this cannot be false. (optional)
     * @param  string[]|null $tags An optional parameter to filter networks by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $product_types An optional parameter to filter networks by product type. Results will have at least one of the included product types. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 100000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationNetworks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationNetworksRequest($organization_id, $config_template_id = null, $is_bound_to_config_template = null, $tags = null, $tags_filter_type = null, $product_types = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationNetworks'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationNetworks'
            );
        }










        $resourcePath = '/organizations/{organizationId}/networks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $config_template_id,
            'configTemplateId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_bound_to_config_template,
            'isBoundToConfigTemplate', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags_filter_type,
            'tagsFilterType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationSummaryTopNetworksByStatus
     *
     * List the client and status overview information for the networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopNetworksByStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationSummaryTopNetworksByStatus200ResponseInner[]
     */
    public function getOrganizationSummaryTopNetworksByStatus($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationSummaryTopNetworksByStatus'][0])
    {
        list($response) = $this->getOrganizationSummaryTopNetworksByStatusWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationSummaryTopNetworksByStatusWithHttpInfo
     *
     * List the client and status overview information for the networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopNetworksByStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationSummaryTopNetworksByStatus200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationSummaryTopNetworksByStatusWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationSummaryTopNetworksByStatus'][0])
    {
        $request = $this->getOrganizationSummaryTopNetworksByStatusRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationSummaryTopNetworksByStatus200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationSummaryTopNetworksByStatus200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationSummaryTopNetworksByStatus200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationSummaryTopNetworksByStatus200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationSummaryTopNetworksByStatus200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationSummaryTopNetworksByStatusAsync
     *
     * List the client and status overview information for the networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopNetworksByStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopNetworksByStatusAsync($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationSummaryTopNetworksByStatus'][0])
    {
        return $this->getOrganizationSummaryTopNetworksByStatusAsyncWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationSummaryTopNetworksByStatusAsyncWithHttpInfo
     *
     * List the client and status overview information for the networks in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopNetworksByStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopNetworksByStatusAsyncWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationSummaryTopNetworksByStatus'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationSummaryTopNetworksByStatus200ResponseInner[]';
        $request = $this->getOrganizationSummaryTopNetworksByStatusRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationSummaryTopNetworksByStatus'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 5000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopNetworksByStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationSummaryTopNetworksByStatusRequest($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationSummaryTopNetworksByStatus'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationSummaryTopNetworksByStatus'
            );
        }










        $resourcePath = '/organizations/{organizationId}/summary/top/networks/byStatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_tag,
            'networkTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tag,
            'deviceTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity,
            'quantity', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_name,
            'ssidName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $usage_uplink,
            'usageUplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation provisionNetworkClients
     *
     * Provisions a client with a name and policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\ProvisionNetworkClients201Response
     */
    public function provisionNetworkClients($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {
        list($response) = $this->provisionNetworkClientsWithHttpInfo($network_id, $provision_network_clients_request, $contentType);
        return $response;
    }

    /**
     * Operation provisionNetworkClientsWithHttpInfo
     *
     * Provisions a client with a name and policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\ProvisionNetworkClients201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function provisionNetworkClientsWithHttpInfo($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {
        $request = $this->provisionNetworkClientsRequest($network_id, $provision_network_clients_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\ProvisionNetworkClients201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\ProvisionNetworkClients201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\ProvisionNetworkClients201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\ProvisionNetworkClients201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\ProvisionNetworkClients201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation provisionNetworkClientsAsync
     *
     * Provisions a client with a name and policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provisionNetworkClientsAsync($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {
        return $this->provisionNetworkClientsAsyncWithHttpInfo($network_id, $provision_network_clients_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation provisionNetworkClientsAsyncWithHttpInfo
     *
     * Provisions a client with a name and policy
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provisionNetworkClientsAsyncWithHttpInfo($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {
        $returnType = '\Meraki\Model\ProvisionNetworkClients201Response';
        $request = $this->provisionNetworkClientsRequest($network_id, $provision_network_clients_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'provisionNetworkClients'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ProvisionNetworkClientsRequest $provision_network_clients_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['provisionNetworkClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function provisionNetworkClientsRequest($network_id, $provision_network_clients_request, string $contentType = self::contentTypes['provisionNetworkClients'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling provisionNetworkClients'
            );
        }

        // verify the required parameter 'provision_network_clients_request' is set
        if ($provision_network_clients_request === null || (is_array($provision_network_clients_request) && count($provision_network_clients_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provision_network_clients_request when calling provisionNetworkClients'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/provision';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($provision_network_clients_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($provision_network_clients_request));
            } else {
                $httpBody = $provision_network_clients_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation publishNetworkFloorPlansAutoLocateJob
     *
     * Update the status of a finished auto locate job to be published, and update device locations
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\PublishNetworkFloorPlansAutoLocateJobRequest|null $publish_network_floor_plans_auto_locate_job_request publish_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\PublishNetworkFloorPlansAutoLocateJob200Response
     */
    public function publishNetworkFloorPlansAutoLocateJob($network_id, $job_id, $publish_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['publishNetworkFloorPlansAutoLocateJob'][0])
    {
        list($response) = $this->publishNetworkFloorPlansAutoLocateJobWithHttpInfo($network_id, $job_id, $publish_network_floor_plans_auto_locate_job_request, $contentType);
        return $response;
    }

    /**
     * Operation publishNetworkFloorPlansAutoLocateJobWithHttpInfo
     *
     * Update the status of a finished auto locate job to be published, and update device locations
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\PublishNetworkFloorPlansAutoLocateJobRequest|null $publish_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\PublishNetworkFloorPlansAutoLocateJob200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function publishNetworkFloorPlansAutoLocateJobWithHttpInfo($network_id, $job_id, $publish_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['publishNetworkFloorPlansAutoLocateJob'][0])
    {
        $request = $this->publishNetworkFloorPlansAutoLocateJobRequest($network_id, $job_id, $publish_network_floor_plans_auto_locate_job_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\PublishNetworkFloorPlansAutoLocateJob200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\PublishNetworkFloorPlansAutoLocateJob200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\PublishNetworkFloorPlansAutoLocateJob200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\PublishNetworkFloorPlansAutoLocateJob200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\PublishNetworkFloorPlansAutoLocateJob200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation publishNetworkFloorPlansAutoLocateJobAsync
     *
     * Update the status of a finished auto locate job to be published, and update device locations
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\PublishNetworkFloorPlansAutoLocateJobRequest|null $publish_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishNetworkFloorPlansAutoLocateJobAsync($network_id, $job_id, $publish_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['publishNetworkFloorPlansAutoLocateJob'][0])
    {
        return $this->publishNetworkFloorPlansAutoLocateJobAsyncWithHttpInfo($network_id, $job_id, $publish_network_floor_plans_auto_locate_job_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation publishNetworkFloorPlansAutoLocateJobAsyncWithHttpInfo
     *
     * Update the status of a finished auto locate job to be published, and update device locations
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\PublishNetworkFloorPlansAutoLocateJobRequest|null $publish_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishNetworkFloorPlansAutoLocateJobAsyncWithHttpInfo($network_id, $job_id, $publish_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['publishNetworkFloorPlansAutoLocateJob'][0])
    {
        $returnType = '\Meraki\Model\PublishNetworkFloorPlansAutoLocateJob200Response';
        $request = $this->publishNetworkFloorPlansAutoLocateJobRequest($network_id, $job_id, $publish_network_floor_plans_auto_locate_job_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'publishNetworkFloorPlansAutoLocateJob'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\PublishNetworkFloorPlansAutoLocateJobRequest|null $publish_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function publishNetworkFloorPlansAutoLocateJobRequest($network_id, $job_id, $publish_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['publishNetworkFloorPlansAutoLocateJob'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling publishNetworkFloorPlansAutoLocateJob'
            );
        }

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling publishNetworkFloorPlansAutoLocateJob'
            );
        }



        $resourcePath = '/networks/{networkId}/floorPlans/autoLocate/jobs/{jobId}/publish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($publish_network_floor_plans_auto_locate_job_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($publish_network_floor_plans_auto_locate_job_request));
            } else {
                $httpBody = $publish_network_floor_plans_auto_locate_job_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reassignNetworkVlanProfilesAssignments
     *
     * Update the assigned VLAN Profile for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response
     */
    public function reassignNetworkVlanProfilesAssignments($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {
        list($response) = $this->reassignNetworkVlanProfilesAssignmentsWithHttpInfo($network_id, $reassign_network_vlan_profiles_assignments_request, $contentType);
        return $response;
    }

    /**
     * Operation reassignNetworkVlanProfilesAssignmentsWithHttpInfo
     *
     * Update the assigned VLAN Profile for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function reassignNetworkVlanProfilesAssignmentsWithHttpInfo($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {
        $request = $this->reassignNetworkVlanProfilesAssignmentsRequest($network_id, $reassign_network_vlan_profiles_assignments_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation reassignNetworkVlanProfilesAssignmentsAsync
     *
     * Update the assigned VLAN Profile for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reassignNetworkVlanProfilesAssignmentsAsync($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {
        return $this->reassignNetworkVlanProfilesAssignmentsAsyncWithHttpInfo($network_id, $reassign_network_vlan_profiles_assignments_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reassignNetworkVlanProfilesAssignmentsAsyncWithHttpInfo
     *
     * Update the assigned VLAN Profile for devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reassignNetworkVlanProfilesAssignmentsAsyncWithHttpInfo($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {
        $returnType = '\Meraki\Model\ReassignNetworkVlanProfilesAssignments200Response';
        $request = $this->reassignNetworkVlanProfilesAssignmentsRequest($network_id, $reassign_network_vlan_profiles_assignments_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reassignNetworkVlanProfilesAssignments'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ReassignNetworkVlanProfilesAssignmentsRequest $reassign_network_vlan_profiles_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reassignNetworkVlanProfilesAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reassignNetworkVlanProfilesAssignmentsRequest($network_id, $reassign_network_vlan_profiles_assignments_request, string $contentType = self::contentTypes['reassignNetworkVlanProfilesAssignments'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling reassignNetworkVlanProfilesAssignments'
            );
        }

        // verify the required parameter 'reassign_network_vlan_profiles_assignments_request' is set
        if ($reassign_network_vlan_profiles_assignments_request === null || (is_array($reassign_network_vlan_profiles_assignments_request) && count($reassign_network_vlan_profiles_assignments_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reassign_network_vlan_profiles_assignments_request when calling reassignNetworkVlanProfilesAssignments'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles/assignments/reassign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reassign_network_vlan_profiles_assignments_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reassign_network_vlan_profiles_assignments_request));
            } else {
                $httpBody = $reassign_network_vlan_profiles_assignments_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recalculateNetworkFloorPlansAutoLocateJob
     *
     * Trigger auto locate recalculation for a job, and optionally set anchors
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJobRequest|null $recalculate_network_floor_plans_auto_locate_job_request recalculate_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJob200Response
     */
    public function recalculateNetworkFloorPlansAutoLocateJob($network_id, $job_id, $recalculate_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'][0])
    {
        list($response) = $this->recalculateNetworkFloorPlansAutoLocateJobWithHttpInfo($network_id, $job_id, $recalculate_network_floor_plans_auto_locate_job_request, $contentType);
        return $response;
    }

    /**
     * Operation recalculateNetworkFloorPlansAutoLocateJobWithHttpInfo
     *
     * Trigger auto locate recalculation for a job, and optionally set anchors
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJobRequest|null $recalculate_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJob200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function recalculateNetworkFloorPlansAutoLocateJobWithHttpInfo($network_id, $job_id, $recalculate_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'][0])
    {
        $request = $this->recalculateNetworkFloorPlansAutoLocateJobRequest($network_id, $job_id, $recalculate_network_floor_plans_auto_locate_job_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJob200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJob200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJob200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJob200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJob200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recalculateNetworkFloorPlansAutoLocateJobAsync
     *
     * Trigger auto locate recalculation for a job, and optionally set anchors
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJobRequest|null $recalculate_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recalculateNetworkFloorPlansAutoLocateJobAsync($network_id, $job_id, $recalculate_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'][0])
    {
        return $this->recalculateNetworkFloorPlansAutoLocateJobAsyncWithHttpInfo($network_id, $job_id, $recalculate_network_floor_plans_auto_locate_job_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recalculateNetworkFloorPlansAutoLocateJobAsyncWithHttpInfo
     *
     * Trigger auto locate recalculation for a job, and optionally set anchors
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJobRequest|null $recalculate_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recalculateNetworkFloorPlansAutoLocateJobAsyncWithHttpInfo($network_id, $job_id, $recalculate_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'][0])
    {
        $returnType = '\Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJob200Response';
        $request = $this->recalculateNetworkFloorPlansAutoLocateJobRequest($network_id, $job_id, $recalculate_network_floor_plans_auto_locate_job_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recalculateNetworkFloorPlansAutoLocateJob'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $job_id Job ID (required)
     * @param  \Meraki\Model\RecalculateNetworkFloorPlansAutoLocateJobRequest|null $recalculate_network_floor_plans_auto_locate_job_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recalculateNetworkFloorPlansAutoLocateJobRequest($network_id, $job_id, $recalculate_network_floor_plans_auto_locate_job_request = null, string $contentType = self::contentTypes['recalculateNetworkFloorPlansAutoLocateJob'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling recalculateNetworkFloorPlansAutoLocateJob'
            );
        }

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling recalculateNetworkFloorPlansAutoLocateJob'
            );
        }



        $resourcePath = '/networks/{networkId}/floorPlans/autoLocate/jobs/{jobId}/recalculate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'jobId' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($recalculate_network_floor_plans_auto_locate_job_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($recalculate_network_floor_plans_auto_locate_job_request));
            } else {
                $httpBody = $recalculate_network_floor_plans_auto_locate_job_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeNetworkDevices
     *
     * Remove a single device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeNetworkDevices($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {
        $this->removeNetworkDevicesWithHttpInfo($network_id, $remove_network_devices_request, $contentType);
    }

    /**
     * Operation removeNetworkDevicesWithHttpInfo
     *
     * Remove a single device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeNetworkDevicesWithHttpInfo($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {
        $request = $this->removeNetworkDevicesRequest($network_id, $remove_network_devices_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeNetworkDevicesAsync
     *
     * Remove a single device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeNetworkDevicesAsync($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {
        return $this->removeNetworkDevicesAsyncWithHttpInfo($network_id, $remove_network_devices_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeNetworkDevicesAsyncWithHttpInfo
     *
     * Remove a single device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeNetworkDevicesAsyncWithHttpInfo($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {
        $returnType = '';
        $request = $this->removeNetworkDevicesRequest($network_id, $remove_network_devices_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeNetworkDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeNetworkDevicesRequest($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling removeNetworkDevices'
            );
        }

        // verify the required parameter 'remove_network_devices_request' is set
        if ($remove_network_devices_request === null || (is_array($remove_network_devices_request) && count($remove_network_devices_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_network_devices_request when calling removeNetworkDevices'
            );
        }


        $resourcePath = '/networks/{networkId}/devices/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($remove_network_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($remove_network_devices_request));
            } else {
                $httpBody = $remove_network_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rollbacksNetworkFirmwareUpgradesStagedEvents
     *
     * Rollback a Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RollbacksNetworkFirmwareUpgradesStagedEventsRequest $rollbacks_network_firmware_upgrades_staged_events_request rollbacks_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response
     */
    public function rollbacksNetworkFirmwareUpgradesStagedEvents($network_id, $rollbacks_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'][0])
    {
        list($response) = $this->rollbacksNetworkFirmwareUpgradesStagedEventsWithHttpInfo($network_id, $rollbacks_network_firmware_upgrades_staged_events_request, $contentType);
        return $response;
    }

    /**
     * Operation rollbacksNetworkFirmwareUpgradesStagedEventsWithHttpInfo
     *
     * Rollback a Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RollbacksNetworkFirmwareUpgradesStagedEventsRequest $rollbacks_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function rollbacksNetworkFirmwareUpgradesStagedEventsWithHttpInfo($network_id, $rollbacks_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'][0])
    {
        $request = $this->rollbacksNetworkFirmwareUpgradesStagedEventsRequest($network_id, $rollbacks_network_firmware_upgrades_staged_events_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rollbacksNetworkFirmwareUpgradesStagedEventsAsync
     *
     * Rollback a Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RollbacksNetworkFirmwareUpgradesStagedEventsRequest $rollbacks_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rollbacksNetworkFirmwareUpgradesStagedEventsAsync($network_id, $rollbacks_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'][0])
    {
        return $this->rollbacksNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo($network_id, $rollbacks_network_firmware_upgrades_staged_events_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rollbacksNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo
     *
     * Rollback a Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RollbacksNetworkFirmwareUpgradesStagedEventsRequest $rollbacks_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rollbacksNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo($network_id, $rollbacks_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
        $request = $this->rollbacksNetworkFirmwareUpgradesStagedEventsRequest($network_id, $rollbacks_network_firmware_upgrades_staged_events_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rollbacksNetworkFirmwareUpgradesStagedEvents'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RollbacksNetworkFirmwareUpgradesStagedEventsRequest $rollbacks_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function rollbacksNetworkFirmwareUpgradesStagedEventsRequest($network_id, $rollbacks_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['rollbacksNetworkFirmwareUpgradesStagedEvents'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling rollbacksNetworkFirmwareUpgradesStagedEvents'
            );
        }

        // verify the required parameter 'rollbacks_network_firmware_upgrades_staged_events_request' is set
        if ($rollbacks_network_firmware_upgrades_staged_events_request === null || (is_array($rollbacks_network_firmware_upgrades_staged_events_request) && count($rollbacks_network_firmware_upgrades_staged_events_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rollbacks_network_firmware_upgrades_staged_events_request when calling rollbacksNetworkFirmwareUpgradesStagedEvents'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/events/rollbacks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rollbacks_network_firmware_upgrades_staged_events_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rollbacks_network_firmware_upgrades_staged_events_request));
            } else {
                $httpBody = $rollbacks_network_firmware_upgrades_staged_events_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation splitNetwork
     *
     * Split a combined network into individual networks for each type of device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\SplitNetwork200Response
     */
    public function splitNetwork($network_id, string $contentType = self::contentTypes['splitNetwork'][0])
    {
        list($response) = $this->splitNetworkWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation splitNetworkWithHttpInfo
     *
     * Split a combined network into individual networks for each type of device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\SplitNetwork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function splitNetworkWithHttpInfo($network_id, string $contentType = self::contentTypes['splitNetwork'][0])
    {
        $request = $this->splitNetworkRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\SplitNetwork200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\SplitNetwork200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\SplitNetwork200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\SplitNetwork200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\SplitNetwork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation splitNetworkAsync
     *
     * Split a combined network into individual networks for each type of device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitNetworkAsync($network_id, string $contentType = self::contentTypes['splitNetwork'][0])
    {
        return $this->splitNetworkAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation splitNetworkAsyncWithHttpInfo
     *
     * Split a combined network into individual networks for each type of device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitNetworkAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['splitNetwork'][0])
    {
        $returnType = '\Meraki\Model\SplitNetwork200Response';
        $request = $this->splitNetworkRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'splitNetwork'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function splitNetworkRequest($network_id, string $contentType = self::contentTypes['splitNetwork'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling splitNetwork'
            );
        }


        $resourcePath = '/networks/{networkId}/split';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unbindNetwork
     *
     * Unbind a network from a template.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UnbindNetworkRequest|null $unbind_network_request unbind_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbindNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetwork200Response
     */
    public function unbindNetwork($network_id, $unbind_network_request = null, string $contentType = self::contentTypes['unbindNetwork'][0])
    {
        list($response) = $this->unbindNetworkWithHttpInfo($network_id, $unbind_network_request, $contentType);
        return $response;
    }

    /**
     * Operation unbindNetworkWithHttpInfo
     *
     * Unbind a network from a template.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UnbindNetworkRequest|null $unbind_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbindNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetwork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function unbindNetworkWithHttpInfo($network_id, $unbind_network_request = null, string $contentType = self::contentTypes['unbindNetwork'][0])
    {
        $request = $this->unbindNetworkRequest($network_id, $unbind_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetwork200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetwork200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetwork200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetwork200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetwork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unbindNetworkAsync
     *
     * Unbind a network from a template.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UnbindNetworkRequest|null $unbind_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbindNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unbindNetworkAsync($network_id, $unbind_network_request = null, string $contentType = self::contentTypes['unbindNetwork'][0])
    {
        return $this->unbindNetworkAsyncWithHttpInfo($network_id, $unbind_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unbindNetworkAsyncWithHttpInfo
     *
     * Unbind a network from a template.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UnbindNetworkRequest|null $unbind_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbindNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unbindNetworkAsyncWithHttpInfo($network_id, $unbind_network_request = null, string $contentType = self::contentTypes['unbindNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetNetwork200Response';
        $request = $this->unbindNetworkRequest($network_id, $unbind_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unbindNetwork'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UnbindNetworkRequest|null $unbind_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbindNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unbindNetworkRequest($network_id, $unbind_network_request = null, string $contentType = self::contentTypes['unbindNetwork'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling unbindNetwork'
            );
        }



        $resourcePath = '/networks/{networkId}/unbind';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($unbind_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($unbind_network_request));
            } else {
                $httpBody = $unbind_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetwork
     *
     * Update a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkRequest|null $update_network_request update_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetwork200Response
     */
    public function updateNetwork($network_id, $update_network_request = null, string $contentType = self::contentTypes['updateNetwork'][0])
    {
        list($response) = $this->updateNetworkWithHttpInfo($network_id, $update_network_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkWithHttpInfo
     *
     * Update a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkRequest|null $update_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetwork200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWithHttpInfo($network_id, $update_network_request = null, string $contentType = self::contentTypes['updateNetwork'][0])
    {
        $request = $this->updateNetworkRequest($network_id, $update_network_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetwork200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetwork200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetwork200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetwork200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetwork200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkAsync
     *
     * Update a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkRequest|null $update_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAsync($network_id, $update_network_request = null, string $contentType = self::contentTypes['updateNetwork'][0])
    {
        return $this->updateNetworkAsyncWithHttpInfo($network_id, $update_network_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkAsyncWithHttpInfo
     *
     * Update a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkRequest|null $update_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAsyncWithHttpInfo($network_id, $update_network_request = null, string $contentType = self::contentTypes['updateNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetNetwork200Response';
        $request = $this->updateNetworkRequest($network_id, $update_network_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetwork'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkRequest|null $update_network_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkRequest($network_id, $update_network_request = null, string $contentType = self::contentTypes['updateNetwork'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetwork'
            );
        }



        $resourcePath = '/networks/{networkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_request));
            } else {
                $httpBody = $update_network_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkAlertsSettings
     *
     * Update the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkAlertsSettings200Response
     */
    public function updateNetworkAlertsSettings($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {
        list($response) = $this->updateNetworkAlertsSettingsWithHttpInfo($network_id, $update_network_alerts_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkAlertsSettingsWithHttpInfo
     *
     * Update the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkAlertsSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkAlertsSettingsWithHttpInfo($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {
        $request = $this->updateNetworkAlertsSettingsRequest($network_id, $update_network_alerts_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkAlertsSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkAlertsSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkAlertsSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkAlertsSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkAlertsSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkAlertsSettingsAsync
     *
     * Update the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAlertsSettingsAsync($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {
        return $this->updateNetworkAlertsSettingsAsyncWithHttpInfo($network_id, $update_network_alerts_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkAlertsSettingsAsyncWithHttpInfo
     *
     * Update the alert configuration for this network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkAlertsSettingsAsyncWithHttpInfo($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkAlertsSettings200Response';
        $request = $this->updateNetworkAlertsSettingsRequest($network_id, $update_network_alerts_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkAlertsSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkAlertsSettingsRequest|null $update_network_alerts_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkAlertsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkAlertsSettingsRequest($network_id, $update_network_alerts_settings_request = null, string $contentType = self::contentTypes['updateNetworkAlertsSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkAlertsSettings'
            );
        }



        $resourcePath = '/networks/{networkId}/alerts/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_alerts_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_alerts_settings_request));
            } else {
                $httpBody = $update_network_alerts_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkClientPolicy
     *
     * Update the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkClientPolicy200Response
     */
    public function updateNetworkClientPolicy($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {
        list($response) = $this->updateNetworkClientPolicyWithHttpInfo($network_id, $client_id, $update_network_client_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkClientPolicyWithHttpInfo
     *
     * Update the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkClientPolicy200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkClientPolicyWithHttpInfo($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {
        $request = $this->updateNetworkClientPolicyRequest($network_id, $client_id, $update_network_client_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkClientPolicy200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkClientPolicy200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkClientPolicy200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkClientPolicy200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkClientPolicy200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkClientPolicyAsync
     *
     * Update the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkClientPolicyAsync($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {
        return $this->updateNetworkClientPolicyAsyncWithHttpInfo($network_id, $client_id, $update_network_client_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkClientPolicyAsyncWithHttpInfo
     *
     * Update the policy assigned to a client on the network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkClientPolicyAsyncWithHttpInfo($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkClientPolicy200Response';
        $request = $this->updateNetworkClientPolicyRequest($network_id, $client_id, $update_network_client_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkClientPolicy'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientPolicyRequest $update_network_client_policy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkClientPolicyRequest($network_id, $client_id, $update_network_client_policy_request, string $contentType = self::contentTypes['updateNetworkClientPolicy'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkClientPolicy'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling updateNetworkClientPolicy'
            );
        }

        // verify the required parameter 'update_network_client_policy_request' is set
        if ($update_network_client_policy_request === null || (is_array($update_network_client_policy_request) && count($update_network_client_policy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_client_policy_request when calling updateNetworkClientPolicy'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_client_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_client_policy_request));
            } else {
                $httpBody = $update_network_client_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkClientSplashAuthorizationStatus
     *
     * Update a client&#39;s splash authorization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkClientSplashAuthorizationStatus($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {
        list($response) = $this->updateNetworkClientSplashAuthorizationStatusWithHttpInfo($network_id, $client_id, $update_network_client_splash_authorization_status_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkClientSplashAuthorizationStatusWithHttpInfo
     *
     * Update a client&#39;s splash authorization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkClientSplashAuthorizationStatusWithHttpInfo($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {
        $request = $this->updateNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $update_network_client_splash_authorization_status_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkClientSplashAuthorizationStatusAsync
     *
     * Update a client&#39;s splash authorization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkClientSplashAuthorizationStatusAsync($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {
        return $this->updateNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo($network_id, $client_id, $update_network_client_splash_authorization_status_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo
     *
     * Update a client&#39;s splash authorization
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkClientSplashAuthorizationStatusAsyncWithHttpInfo($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {
        $returnType = 'object';
        $request = $this->updateNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $update_network_client_splash_authorization_status_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkClientSplashAuthorizationStatus'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $client_id Client ID (required)
     * @param  \Meraki\Model\UpdateNetworkClientSplashAuthorizationStatusRequest $update_network_client_splash_authorization_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkClientSplashAuthorizationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkClientSplashAuthorizationStatusRequest($network_id, $client_id, $update_network_client_splash_authorization_status_request, string $contentType = self::contentTypes['updateNetworkClientSplashAuthorizationStatus'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkClientSplashAuthorizationStatus'
            );
        }

        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling updateNetworkClientSplashAuthorizationStatus'
            );
        }

        // verify the required parameter 'update_network_client_splash_authorization_status_request' is set
        if ($update_network_client_splash_authorization_status_request === null || (is_array($update_network_client_splash_authorization_status_request) && count($update_network_client_splash_authorization_status_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_client_splash_authorization_status_request when calling updateNetworkClientSplashAuthorizationStatus'
            );
        }


        $resourcePath = '/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_client_splash_authorization_status_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_client_splash_authorization_status_request));
            } else {
                $httpBody = $update_network_client_splash_authorization_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkFirmwareUpgrades
     *
     * Update firmware upgrade information for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesRequest|null $update_network_firmware_upgrades_request update_network_firmware_upgrades_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgrades200Response
     */
    public function updateNetworkFirmwareUpgrades($network_id, $update_network_firmware_upgrades_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgrades'][0])
    {
        list($response) = $this->updateNetworkFirmwareUpgradesWithHttpInfo($network_id, $update_network_firmware_upgrades_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkFirmwareUpgradesWithHttpInfo
     *
     * Update firmware upgrade information for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesRequest|null $update_network_firmware_upgrades_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgrades200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkFirmwareUpgradesWithHttpInfo($network_id, $update_network_firmware_upgrades_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgrades'][0])
    {
        $request = $this->updateNetworkFirmwareUpgradesRequest($network_id, $update_network_firmware_upgrades_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgrades200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgrades200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgrades200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgrades200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgrades200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkFirmwareUpgradesAsync
     *
     * Update firmware upgrade information for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesRequest|null $update_network_firmware_upgrades_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFirmwareUpgradesAsync($network_id, $update_network_firmware_upgrades_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgrades'][0])
    {
        return $this->updateNetworkFirmwareUpgradesAsyncWithHttpInfo($network_id, $update_network_firmware_upgrades_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkFirmwareUpgradesAsyncWithHttpInfo
     *
     * Update firmware upgrade information for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesRequest|null $update_network_firmware_upgrades_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFirmwareUpgradesAsyncWithHttpInfo($network_id, $update_network_firmware_upgrades_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgrades'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgrades200Response';
        $request = $this->updateNetworkFirmwareUpgradesRequest($network_id, $update_network_firmware_upgrades_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkFirmwareUpgrades'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesRequest|null $update_network_firmware_upgrades_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkFirmwareUpgradesRequest($network_id, $update_network_firmware_upgrades_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgrades'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkFirmwareUpgrades'
            );
        }



        $resourcePath = '/networks/{networkId}/firmwareUpgrades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_firmware_upgrades_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_firmware_upgrades_request));
            } else {
                $httpBody = $update_network_firmware_upgrades_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedEvents
     *
     * Update the Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedEventsRequest $update_network_firmware_upgrades_staged_events_request update_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response
     */
    public function updateNetworkFirmwareUpgradesStagedEvents($network_id, $update_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'][0])
    {
        list($response) = $this->updateNetworkFirmwareUpgradesStagedEventsWithHttpInfo($network_id, $update_network_firmware_upgrades_staged_events_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedEventsWithHttpInfo
     *
     * Update the Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedEventsRequest $update_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkFirmwareUpgradesStagedEventsWithHttpInfo($network_id, $update_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'][0])
    {
        $request = $this->updateNetworkFirmwareUpgradesStagedEventsRequest($network_id, $update_network_firmware_upgrades_staged_events_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedEventsAsync
     *
     * Update the Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedEventsRequest $update_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFirmwareUpgradesStagedEventsAsync($network_id, $update_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'][0])
    {
        return $this->updateNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo($network_id, $update_network_firmware_upgrades_staged_events_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo
     *
     * Update the Staged Upgrade Event for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedEventsRequest $update_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFirmwareUpgradesStagedEventsAsyncWithHttpInfo($network_id, $update_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedEvents200Response';
        $request = $this->updateNetworkFirmwareUpgradesStagedEventsRequest($network_id, $update_network_firmware_upgrades_staged_events_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkFirmwareUpgradesStagedEvents'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedEventsRequest $update_network_firmware_upgrades_staged_events_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkFirmwareUpgradesStagedEventsRequest($network_id, $update_network_firmware_upgrades_staged_events_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedEvents'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkFirmwareUpgradesStagedEvents'
            );
        }

        // verify the required parameter 'update_network_firmware_upgrades_staged_events_request' is set
        if ($update_network_firmware_upgrades_staged_events_request === null || (is_array($update_network_firmware_upgrades_staged_events_request) && count($update_network_firmware_upgrades_staged_events_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_firmware_upgrades_staged_events_request when calling updateNetworkFirmwareUpgradesStagedEvents'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_firmware_upgrades_staged_events_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_firmware_upgrades_staged_events_request));
            } else {
                $httpBody = $update_network_firmware_upgrades_staged_events_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedGroup
     *
     * Update a Staged Upgrade Group for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner
     */
    public function updateNetworkFirmwareUpgradesStagedGroup($network_id, $group_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'][0])
    {
        list($response) = $this->updateNetworkFirmwareUpgradesStagedGroupWithHttpInfo($network_id, $group_id, $create_network_firmware_upgrades_staged_group_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedGroupWithHttpInfo
     *
     * Update a Staged Upgrade Group for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkFirmwareUpgradesStagedGroupWithHttpInfo($network_id, $group_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'][0])
    {
        $request = $this->updateNetworkFirmwareUpgradesStagedGroupRequest($network_id, $group_id, $create_network_firmware_upgrades_staged_group_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedGroupAsync
     *
     * Update a Staged Upgrade Group for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFirmwareUpgradesStagedGroupAsync($network_id, $group_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'][0])
    {
        return $this->updateNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo($network_id, $group_id, $create_network_firmware_upgrades_staged_group_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo
     *
     * Update a Staged Upgrade Group for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFirmwareUpgradesStagedGroupAsyncWithHttpInfo($network_id, $group_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedGroups200ResponseInner';
        $request = $this->updateNetworkFirmwareUpgradesStagedGroupRequest($network_id, $group_id, $create_network_firmware_upgrades_staged_group_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkFirmwareUpgradesStagedGroup'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_id Group ID (required)
     * @param  \Meraki\Model\CreateNetworkFirmwareUpgradesStagedGroupRequest $create_network_firmware_upgrades_staged_group_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkFirmwareUpgradesStagedGroupRequest($network_id, $group_id, $create_network_firmware_upgrades_staged_group_request, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedGroup'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkFirmwareUpgradesStagedGroup'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling updateNetworkFirmwareUpgradesStagedGroup'
            );
        }

        // verify the required parameter 'create_network_firmware_upgrades_staged_group_request' is set
        if ($create_network_firmware_upgrades_staged_group_request === null || (is_array($create_network_firmware_upgrades_staged_group_request) && count($create_network_firmware_upgrades_staged_group_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_firmware_upgrades_staged_group_request when calling updateNetworkFirmwareUpgradesStagedGroup'
            );
        }


        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_firmware_upgrades_staged_group_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_firmware_upgrades_staged_group_request));
            } else {
                $httpBody = $create_network_firmware_upgrades_staged_group_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedStages
     *
     * Assign Staged Upgrade Group order in the sequence.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedStagesRequest|null $update_network_firmware_upgrades_staged_stages_request update_network_firmware_upgrades_staged_stages_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]
     */
    public function updateNetworkFirmwareUpgradesStagedStages($network_id, $update_network_firmware_upgrades_staged_stages_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'][0])
    {
        list($response) = $this->updateNetworkFirmwareUpgradesStagedStagesWithHttpInfo($network_id, $update_network_firmware_upgrades_staged_stages_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedStagesWithHttpInfo
     *
     * Assign Staged Upgrade Group order in the sequence.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedStagesRequest|null $update_network_firmware_upgrades_staged_stages_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkFirmwareUpgradesStagedStagesWithHttpInfo($network_id, $update_network_firmware_upgrades_staged_stages_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'][0])
    {
        $request = $this->updateNetworkFirmwareUpgradesStagedStagesRequest($network_id, $update_network_firmware_upgrades_staged_stages_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedStagesAsync
     *
     * Assign Staged Upgrade Group order in the sequence.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedStagesRequest|null $update_network_firmware_upgrades_staged_stages_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFirmwareUpgradesStagedStagesAsync($network_id, $update_network_firmware_upgrades_staged_stages_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'][0])
    {
        return $this->updateNetworkFirmwareUpgradesStagedStagesAsyncWithHttpInfo($network_id, $update_network_firmware_upgrades_staged_stages_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkFirmwareUpgradesStagedStagesAsyncWithHttpInfo
     *
     * Assign Staged Upgrade Group order in the sequence.
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedStagesRequest|null $update_network_firmware_upgrades_staged_stages_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFirmwareUpgradesStagedStagesAsyncWithHttpInfo($network_id, $update_network_firmware_upgrades_staged_stages_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFirmwareUpgradesStagedStages200ResponseInner[]';
        $request = $this->updateNetworkFirmwareUpgradesStagedStagesRequest($network_id, $update_network_firmware_upgrades_staged_stages_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkFirmwareUpgradesStagedStages'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkFirmwareUpgradesStagedStagesRequest|null $update_network_firmware_upgrades_staged_stages_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkFirmwareUpgradesStagedStagesRequest($network_id, $update_network_firmware_upgrades_staged_stages_request = null, string $contentType = self::contentTypes['updateNetworkFirmwareUpgradesStagedStages'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkFirmwareUpgradesStagedStages'
            );
        }



        $resourcePath = '/networks/{networkId}/firmwareUpgrades/staged/stages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_firmware_upgrades_staged_stages_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_firmware_upgrades_staged_stages_request));
            } else {
                $httpBody = $update_network_firmware_upgrades_staged_stages_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkFloorPlan
     *
     * Update a floor plan&#39;s geolocation and other meta data
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  \Meraki\Model\UpdateNetworkFloorPlanRequest|null $update_network_floor_plan_request update_network_floor_plan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkFloorPlans200ResponseInner
     */
    public function updateNetworkFloorPlan($network_id, $floor_plan_id, $update_network_floor_plan_request = null, string $contentType = self::contentTypes['updateNetworkFloorPlan'][0])
    {
        list($response) = $this->updateNetworkFloorPlanWithHttpInfo($network_id, $floor_plan_id, $update_network_floor_plan_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkFloorPlanWithHttpInfo
     *
     * Update a floor plan&#39;s geolocation and other meta data
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  \Meraki\Model\UpdateNetworkFloorPlanRequest|null $update_network_floor_plan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkFloorPlans200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkFloorPlanWithHttpInfo($network_id, $floor_plan_id, $update_network_floor_plan_request = null, string $contentType = self::contentTypes['updateNetworkFloorPlan'][0])
    {
        $request = $this->updateNetworkFloorPlanRequest($network_id, $floor_plan_id, $update_network_floor_plan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkFloorPlans200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkFloorPlans200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkFloorPlans200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkFloorPlanAsync
     *
     * Update a floor plan&#39;s geolocation and other meta data
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  \Meraki\Model\UpdateNetworkFloorPlanRequest|null $update_network_floor_plan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFloorPlanAsync($network_id, $floor_plan_id, $update_network_floor_plan_request = null, string $contentType = self::contentTypes['updateNetworkFloorPlan'][0])
    {
        return $this->updateNetworkFloorPlanAsyncWithHttpInfo($network_id, $floor_plan_id, $update_network_floor_plan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkFloorPlanAsyncWithHttpInfo
     *
     * Update a floor plan&#39;s geolocation and other meta data
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  \Meraki\Model\UpdateNetworkFloorPlanRequest|null $update_network_floor_plan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkFloorPlanAsyncWithHttpInfo($network_id, $floor_plan_id, $update_network_floor_plan_request = null, string $contentType = self::contentTypes['updateNetworkFloorPlan'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkFloorPlans200ResponseInner';
        $request = $this->updateNetworkFloorPlanRequest($network_id, $floor_plan_id, $update_network_floor_plan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkFloorPlan'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $floor_plan_id Floor plan ID (required)
     * @param  \Meraki\Model\UpdateNetworkFloorPlanRequest|null $update_network_floor_plan_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkFloorPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkFloorPlanRequest($network_id, $floor_plan_id, $update_network_floor_plan_request = null, string $contentType = self::contentTypes['updateNetworkFloorPlan'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkFloorPlan'
            );
        }

        // verify the required parameter 'floor_plan_id' is set
        if ($floor_plan_id === null || (is_array($floor_plan_id) && count($floor_plan_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $floor_plan_id when calling updateNetworkFloorPlan'
            );
        }



        $resourcePath = '/networks/{networkId}/floorPlans/{floorPlanId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($floor_plan_id !== null) {
            $resourcePath = str_replace(
                '{' . 'floorPlanId' . '}',
                ObjectSerializer::toPathValue($floor_plan_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_floor_plan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_floor_plan_request));
            } else {
                $httpBody = $update_network_floor_plan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkGroupPolicy
     *
     * Update a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  \Meraki\Model\UpdateNetworkGroupPolicyRequest|null $update_network_group_policy_request update_network_group_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkGroupPolicies200ResponseInner
     */
    public function updateNetworkGroupPolicy($network_id, $group_policy_id, $update_network_group_policy_request = null, string $contentType = self::contentTypes['updateNetworkGroupPolicy'][0])
    {
        list($response) = $this->updateNetworkGroupPolicyWithHttpInfo($network_id, $group_policy_id, $update_network_group_policy_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkGroupPolicyWithHttpInfo
     *
     * Update a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  \Meraki\Model\UpdateNetworkGroupPolicyRequest|null $update_network_group_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkGroupPolicies200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkGroupPolicyWithHttpInfo($network_id, $group_policy_id, $update_network_group_policy_request = null, string $contentType = self::contentTypes['updateNetworkGroupPolicy'][0])
    {
        $request = $this->updateNetworkGroupPolicyRequest($network_id, $group_policy_id, $update_network_group_policy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkGroupPolicies200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkGroupPolicies200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkGroupPolicyAsync
     *
     * Update a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  \Meraki\Model\UpdateNetworkGroupPolicyRequest|null $update_network_group_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkGroupPolicyAsync($network_id, $group_policy_id, $update_network_group_policy_request = null, string $contentType = self::contentTypes['updateNetworkGroupPolicy'][0])
    {
        return $this->updateNetworkGroupPolicyAsyncWithHttpInfo($network_id, $group_policy_id, $update_network_group_policy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkGroupPolicyAsyncWithHttpInfo
     *
     * Update a group policy
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  \Meraki\Model\UpdateNetworkGroupPolicyRequest|null $update_network_group_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkGroupPolicyAsyncWithHttpInfo($network_id, $group_policy_id, $update_network_group_policy_request = null, string $contentType = self::contentTypes['updateNetworkGroupPolicy'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkGroupPolicies200ResponseInner';
        $request = $this->updateNetworkGroupPolicyRequest($network_id, $group_policy_id, $update_network_group_policy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkGroupPolicy'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $group_policy_id Group policy ID (required)
     * @param  \Meraki\Model\UpdateNetworkGroupPolicyRequest|null $update_network_group_policy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkGroupPolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkGroupPolicyRequest($network_id, $group_policy_id, $update_network_group_policy_request = null, string $contentType = self::contentTypes['updateNetworkGroupPolicy'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkGroupPolicy'
            );
        }

        // verify the required parameter 'group_policy_id' is set
        if ($group_policy_id === null || (is_array($group_policy_id) && count($group_policy_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_policy_id when calling updateNetworkGroupPolicy'
            );
        }



        $resourcePath = '/networks/{networkId}/groupPolicies/{groupPolicyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($group_policy_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupPolicyId' . '}',
                ObjectSerializer::toPathValue($group_policy_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_group_policy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_group_policy_request));
            } else {
                $httpBody = $update_network_group_policy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkMerakiAuthUser
     *
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner
     */
    public function updateNetworkMerakiAuthUser($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {
        list($response) = $this->updateNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkMerakiAuthUserWithHttpInfo
     *
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkMerakiAuthUserWithHttpInfo($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {
        $request = $this->updateNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkMerakiAuthUserAsync
     *
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkMerakiAuthUserAsync($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {
        return $this->updateNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkMerakiAuthUserAsyncWithHttpInfo
     *
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkMerakiAuthUserAsyncWithHttpInfo($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMerakiAuthUsers200ResponseInner';
        $request = $this->updateNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkMerakiAuthUser'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $meraki_auth_user_id Meraki auth user ID (required)
     * @param  \Meraki\Model\UpdateNetworkMerakiAuthUserRequest|null $update_network_meraki_auth_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMerakiAuthUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkMerakiAuthUserRequest($network_id, $meraki_auth_user_id, $update_network_meraki_auth_user_request = null, string $contentType = self::contentTypes['updateNetworkMerakiAuthUser'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkMerakiAuthUser'
            );
        }

        // verify the required parameter 'meraki_auth_user_id' is set
        if ($meraki_auth_user_id === null || (is_array($meraki_auth_user_id) && count($meraki_auth_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $meraki_auth_user_id when calling updateNetworkMerakiAuthUser'
            );
        }



        $resourcePath = '/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($meraki_auth_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merakiAuthUserId' . '}',
                ObjectSerializer::toPathValue($meraki_auth_user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_meraki_auth_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_meraki_auth_user_request));
            } else {
                $httpBody = $update_network_meraki_auth_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkMqttBroker
     *
     * Update an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  \Meraki\Model\UpdateNetworkMqttBrokerRequest|null $update_network_mqtt_broker_request update_network_mqtt_broker_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkMqttBrokers200ResponseInner
     */
    public function updateNetworkMqttBroker($network_id, $mqtt_broker_id, $update_network_mqtt_broker_request = null, string $contentType = self::contentTypes['updateNetworkMqttBroker'][0])
    {
        list($response) = $this->updateNetworkMqttBrokerWithHttpInfo($network_id, $mqtt_broker_id, $update_network_mqtt_broker_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkMqttBrokerWithHttpInfo
     *
     * Update an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  \Meraki\Model\UpdateNetworkMqttBrokerRequest|null $update_network_mqtt_broker_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkMqttBrokers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkMqttBrokerWithHttpInfo($network_id, $mqtt_broker_id, $update_network_mqtt_broker_request = null, string $contentType = self::contentTypes['updateNetworkMqttBroker'][0])
    {
        $request = $this->updateNetworkMqttBrokerRequest($network_id, $mqtt_broker_id, $update_network_mqtt_broker_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkMqttBrokers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkMqttBrokers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkMqttBrokerAsync
     *
     * Update an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  \Meraki\Model\UpdateNetworkMqttBrokerRequest|null $update_network_mqtt_broker_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkMqttBrokerAsync($network_id, $mqtt_broker_id, $update_network_mqtt_broker_request = null, string $contentType = self::contentTypes['updateNetworkMqttBroker'][0])
    {
        return $this->updateNetworkMqttBrokerAsyncWithHttpInfo($network_id, $mqtt_broker_id, $update_network_mqtt_broker_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkMqttBrokerAsyncWithHttpInfo
     *
     * Update an MQTT broker
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  \Meraki\Model\UpdateNetworkMqttBrokerRequest|null $update_network_mqtt_broker_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkMqttBrokerAsyncWithHttpInfo($network_id, $mqtt_broker_id, $update_network_mqtt_broker_request = null, string $contentType = self::contentTypes['updateNetworkMqttBroker'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkMqttBrokers200ResponseInner';
        $request = $this->updateNetworkMqttBrokerRequest($network_id, $mqtt_broker_id, $update_network_mqtt_broker_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkMqttBroker'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $mqtt_broker_id Mqtt broker ID (required)
     * @param  \Meraki\Model\UpdateNetworkMqttBrokerRequest|null $update_network_mqtt_broker_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkMqttBroker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkMqttBrokerRequest($network_id, $mqtt_broker_id, $update_network_mqtt_broker_request = null, string $contentType = self::contentTypes['updateNetworkMqttBroker'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkMqttBroker'
            );
        }

        // verify the required parameter 'mqtt_broker_id' is set
        if ($mqtt_broker_id === null || (is_array($mqtt_broker_id) && count($mqtt_broker_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mqtt_broker_id when calling updateNetworkMqttBroker'
            );
        }



        $resourcePath = '/networks/{networkId}/mqttBrokers/{mqttBrokerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($mqtt_broker_id !== null) {
            $resourcePath = str_replace(
                '{' . 'mqttBrokerId' . '}',
                ObjectSerializer::toPathValue($mqtt_broker_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_mqtt_broker_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_mqtt_broker_request));
            } else {
                $httpBody = $update_network_mqtt_broker_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkNetflow
     *
     * Update the NetFlow traffic reporting settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkNetflowRequest|null $update_network_netflow_request update_network_netflow_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkNetflow200Response
     */
    public function updateNetworkNetflow($network_id, $update_network_netflow_request = null, string $contentType = self::contentTypes['updateNetworkNetflow'][0])
    {
        list($response) = $this->updateNetworkNetflowWithHttpInfo($network_id, $update_network_netflow_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkNetflowWithHttpInfo
     *
     * Update the NetFlow traffic reporting settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkNetflowRequest|null $update_network_netflow_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkNetflow200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkNetflowWithHttpInfo($network_id, $update_network_netflow_request = null, string $contentType = self::contentTypes['updateNetworkNetflow'][0])
    {
        $request = $this->updateNetworkNetflowRequest($network_id, $update_network_netflow_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkNetflow200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkNetflow200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkNetflow200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkNetflow200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkNetflow200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkNetflowAsync
     *
     * Update the NetFlow traffic reporting settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkNetflowRequest|null $update_network_netflow_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkNetflowAsync($network_id, $update_network_netflow_request = null, string $contentType = self::contentTypes['updateNetworkNetflow'][0])
    {
        return $this->updateNetworkNetflowAsyncWithHttpInfo($network_id, $update_network_netflow_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkNetflowAsyncWithHttpInfo
     *
     * Update the NetFlow traffic reporting settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkNetflowRequest|null $update_network_netflow_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkNetflowAsyncWithHttpInfo($network_id, $update_network_netflow_request = null, string $contentType = self::contentTypes['updateNetworkNetflow'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkNetflow200Response';
        $request = $this->updateNetworkNetflowRequest($network_id, $update_network_netflow_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkNetflow'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkNetflowRequest|null $update_network_netflow_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkNetflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkNetflowRequest($network_id, $update_network_netflow_request = null, string $contentType = self::contentTypes['updateNetworkNetflow'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkNetflow'
            );
        }



        $resourcePath = '/networks/{networkId}/netflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_netflow_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_netflow_request));
            } else {
                $httpBody = $update_network_netflow_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkSettings
     *
     * Update the settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSettingsRequest|null $update_network_settings_request update_network_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSettings200Response
     */
    public function updateNetworkSettings($network_id, $update_network_settings_request = null, string $contentType = self::contentTypes['updateNetworkSettings'][0])
    {
        list($response) = $this->updateNetworkSettingsWithHttpInfo($network_id, $update_network_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkSettingsWithHttpInfo
     *
     * Update the settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSettingsRequest|null $update_network_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSettings'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkSettingsWithHttpInfo($network_id, $update_network_settings_request = null, string $contentType = self::contentTypes['updateNetworkSettings'][0])
    {
        $request = $this->updateNetworkSettingsRequest($network_id, $update_network_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkSettingsAsync
     *
     * Update the settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSettingsRequest|null $update_network_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSettingsAsync($network_id, $update_network_settings_request = null, string $contentType = self::contentTypes['updateNetworkSettings'][0])
    {
        return $this->updateNetworkSettingsAsyncWithHttpInfo($network_id, $update_network_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkSettingsAsyncWithHttpInfo
     *
     * Update the settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSettingsRequest|null $update_network_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSettingsAsyncWithHttpInfo($network_id, $update_network_settings_request = null, string $contentType = self::contentTypes['updateNetworkSettings'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSettings200Response';
        $request = $this->updateNetworkSettingsRequest($network_id, $update_network_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkSettings'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSettingsRequest|null $update_network_settings_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkSettingsRequest($network_id, $update_network_settings_request = null, string $contentType = self::contentTypes['updateNetworkSettings'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkSettings'
            );
        }



        $resourcePath = '/networks/{networkId}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_settings_request));
            } else {
                $httpBody = $update_network_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkSnmp
     *
     * Update the SNMP settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSnmpRequest|null $update_network_snmp_request update_network_snmp_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSnmp200Response
     */
    public function updateNetworkSnmp($network_id, $update_network_snmp_request = null, string $contentType = self::contentTypes['updateNetworkSnmp'][0])
    {
        list($response) = $this->updateNetworkSnmpWithHttpInfo($network_id, $update_network_snmp_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkSnmpWithHttpInfo
     *
     * Update the SNMP settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSnmpRequest|null $update_network_snmp_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSnmp200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkSnmpWithHttpInfo($network_id, $update_network_snmp_request = null, string $contentType = self::contentTypes['updateNetworkSnmp'][0])
    {
        $request = $this->updateNetworkSnmpRequest($network_id, $update_network_snmp_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSnmp200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSnmp200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSnmp200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSnmp200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSnmp200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkSnmpAsync
     *
     * Update the SNMP settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSnmpRequest|null $update_network_snmp_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSnmpAsync($network_id, $update_network_snmp_request = null, string $contentType = self::contentTypes['updateNetworkSnmp'][0])
    {
        return $this->updateNetworkSnmpAsyncWithHttpInfo($network_id, $update_network_snmp_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkSnmpAsyncWithHttpInfo
     *
     * Update the SNMP settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSnmpRequest|null $update_network_snmp_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSnmpAsyncWithHttpInfo($network_id, $update_network_snmp_request = null, string $contentType = self::contentTypes['updateNetworkSnmp'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSnmp200Response';
        $request = $this->updateNetworkSnmpRequest($network_id, $update_network_snmp_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkSnmp'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSnmpRequest|null $update_network_snmp_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSnmp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkSnmpRequest($network_id, $update_network_snmp_request = null, string $contentType = self::contentTypes['updateNetworkSnmp'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkSnmp'
            );
        }



        $resourcePath = '/networks/{networkId}/snmp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_snmp_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_snmp_request));
            } else {
                $httpBody = $update_network_snmp_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkSyslogServers
     *
     * Update the syslog servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSyslogServersRequest $update_network_syslog_servers_request update_network_syslog_servers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSyslogServers200Response
     */
    public function updateNetworkSyslogServers($network_id, $update_network_syslog_servers_request, string $contentType = self::contentTypes['updateNetworkSyslogServers'][0])
    {
        list($response) = $this->updateNetworkSyslogServersWithHttpInfo($network_id, $update_network_syslog_servers_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkSyslogServersWithHttpInfo
     *
     * Update the syslog servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSyslogServersRequest $update_network_syslog_servers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSyslogServers200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkSyslogServersWithHttpInfo($network_id, $update_network_syslog_servers_request, string $contentType = self::contentTypes['updateNetworkSyslogServers'][0])
    {
        $request = $this->updateNetworkSyslogServersRequest($network_id, $update_network_syslog_servers_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSyslogServers200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSyslogServers200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSyslogServers200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSyslogServers200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSyslogServers200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkSyslogServersAsync
     *
     * Update the syslog servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSyslogServersRequest $update_network_syslog_servers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSyslogServersAsync($network_id, $update_network_syslog_servers_request, string $contentType = self::contentTypes['updateNetworkSyslogServers'][0])
    {
        return $this->updateNetworkSyslogServersAsyncWithHttpInfo($network_id, $update_network_syslog_servers_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkSyslogServersAsyncWithHttpInfo
     *
     * Update the syslog servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSyslogServersRequest $update_network_syslog_servers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSyslogServersAsyncWithHttpInfo($network_id, $update_network_syslog_servers_request, string $contentType = self::contentTypes['updateNetworkSyslogServers'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSyslogServers200Response';
        $request = $this->updateNetworkSyslogServersRequest($network_id, $update_network_syslog_servers_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkSyslogServers'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSyslogServersRequest $update_network_syslog_servers_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSyslogServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkSyslogServersRequest($network_id, $update_network_syslog_servers_request, string $contentType = self::contentTypes['updateNetworkSyslogServers'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkSyslogServers'
            );
        }

        // verify the required parameter 'update_network_syslog_servers_request' is set
        if ($update_network_syslog_servers_request === null || (is_array($update_network_syslog_servers_request) && count($update_network_syslog_servers_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_syslog_servers_request when calling updateNetworkSyslogServers'
            );
        }


        $resourcePath = '/networks/{networkId}/syslogServers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_syslog_servers_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_syslog_servers_request));
            } else {
                $httpBody = $update_network_syslog_servers_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkTrafficAnalysis
     *
     * Update the traffic analysis settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkTrafficAnalysisRequest|null $update_network_traffic_analysis_request update_network_traffic_analysis_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkTrafficAnalysis200Response
     */
    public function updateNetworkTrafficAnalysis($network_id, $update_network_traffic_analysis_request = null, string $contentType = self::contentTypes['updateNetworkTrafficAnalysis'][0])
    {
        list($response) = $this->updateNetworkTrafficAnalysisWithHttpInfo($network_id, $update_network_traffic_analysis_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkTrafficAnalysisWithHttpInfo
     *
     * Update the traffic analysis settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkTrafficAnalysisRequest|null $update_network_traffic_analysis_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkTrafficAnalysis200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkTrafficAnalysisWithHttpInfo($network_id, $update_network_traffic_analysis_request = null, string $contentType = self::contentTypes['updateNetworkTrafficAnalysis'][0])
    {
        $request = $this->updateNetworkTrafficAnalysisRequest($network_id, $update_network_traffic_analysis_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkTrafficAnalysis200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkTrafficAnalysis200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkTrafficAnalysis200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkTrafficAnalysis200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkTrafficAnalysis200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkTrafficAnalysisAsync
     *
     * Update the traffic analysis settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkTrafficAnalysisRequest|null $update_network_traffic_analysis_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkTrafficAnalysisAsync($network_id, $update_network_traffic_analysis_request = null, string $contentType = self::contentTypes['updateNetworkTrafficAnalysis'][0])
    {
        return $this->updateNetworkTrafficAnalysisAsyncWithHttpInfo($network_id, $update_network_traffic_analysis_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkTrafficAnalysisAsyncWithHttpInfo
     *
     * Update the traffic analysis settings for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkTrafficAnalysisRequest|null $update_network_traffic_analysis_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkTrafficAnalysisAsyncWithHttpInfo($network_id, $update_network_traffic_analysis_request = null, string $contentType = self::contentTypes['updateNetworkTrafficAnalysis'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkTrafficAnalysis200Response';
        $request = $this->updateNetworkTrafficAnalysisRequest($network_id, $update_network_traffic_analysis_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkTrafficAnalysis'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkTrafficAnalysisRequest|null $update_network_traffic_analysis_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkTrafficAnalysis'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkTrafficAnalysisRequest($network_id, $update_network_traffic_analysis_request = null, string $contentType = self::contentTypes['updateNetworkTrafficAnalysis'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkTrafficAnalysis'
            );
        }



        $resourcePath = '/networks/{networkId}/trafficAnalysis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_traffic_analysis_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_traffic_analysis_request));
            } else {
                $httpBody = $update_network_traffic_analysis_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkVlanProfile
     *
     * Update an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkVlanProfiles200ResponseInner
     */
    public function updateNetworkVlanProfile($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {
        list($response) = $this->updateNetworkVlanProfileWithHttpInfo($network_id, $iname, $update_network_vlan_profile_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkVlanProfileWithHttpInfo
     *
     * Update an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkVlanProfiles200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkVlanProfileWithHttpInfo($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {
        $request = $this->updateNetworkVlanProfileRequest($network_id, $iname, $update_network_vlan_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkVlanProfiles200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkVlanProfileAsync
     *
     * Update an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkVlanProfileAsync($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {
        return $this->updateNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, $update_network_vlan_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkVlanProfileAsyncWithHttpInfo
     *
     * Update an existing VLAN profile of a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkVlanProfileAsyncWithHttpInfo($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkVlanProfiles200ResponseInner';
        $request = $this->updateNetworkVlanProfileRequest($network_id, $iname, $update_network_vlan_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkVlanProfile'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $iname Iname (required)
     * @param  \Meraki\Model\UpdateNetworkVlanProfileRequest $update_network_vlan_profile_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkVlanProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkVlanProfileRequest($network_id, $iname, $update_network_vlan_profile_request, string $contentType = self::contentTypes['updateNetworkVlanProfile'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkVlanProfile'
            );
        }

        // verify the required parameter 'iname' is set
        if ($iname === null || (is_array($iname) && count($iname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iname when calling updateNetworkVlanProfile'
            );
        }

        // verify the required parameter 'update_network_vlan_profile_request' is set
        if ($update_network_vlan_profile_request === null || (is_array($update_network_vlan_profile_request) && count($update_network_vlan_profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_vlan_profile_request when calling updateNetworkVlanProfile'
            );
        }


        $resourcePath = '/networks/{networkId}/vlanProfiles/{iname}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($iname !== null) {
            $resourcePath = str_replace(
                '{' . 'iname' . '}',
                ObjectSerializer::toPathValue($iname),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_vlan_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_vlan_profile_request));
            } else {
                $httpBody = $update_network_vlan_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWebhooksHttpServer
     *
     * Update an HTTP server
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner
     */
    public function updateNetworkWebhooksHttpServer($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {
        list($response) = $this->updateNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, $update_network_webhooks_http_server_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkWebhooksHttpServerWithHttpInfo
     *
     * Update an HTTP server
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {
        $request = $this->updateNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $update_network_webhooks_http_server_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWebhooksHttpServerAsync
     *
     * Update an HTTP server
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWebhooksHttpServerAsync($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {
        return $this->updateNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, $update_network_webhooks_http_server_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWebhooksHttpServerAsyncWithHttpInfo
     *
     * Update an HTTP server
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
        $request = $this->updateNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $update_network_webhooks_http_server_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWebhooksHttpServer'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWebhooksHttpServer'
            );
        }

        // verify the required parameter 'http_server_id' is set
        if ($http_server_id === null || (is_array($http_server_id) && count($http_server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_server_id when calling updateNetworkWebhooksHttpServer'
            );
        }



        $resourcePath = '/networks/{networkId}/webhooks/httpServers/{httpServerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($http_server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'httpServerId' . '}',
                ObjectSerializer::toPathValue($http_server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_webhooks_http_server_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_webhooks_http_server_request));
            } else {
                $httpBody = $update_network_webhooks_http_server_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWebhooksPayloadTemplate
     *
     * Update a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner
     */
    public function updateNetworkWebhooksPayloadTemplate($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {
        list($response) = $this->updateNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, $update_network_webhooks_payload_template_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkWebhooksPayloadTemplateWithHttpInfo
     *
     * Update a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {
        $request = $this->updateNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $update_network_webhooks_payload_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWebhooksPayloadTemplateAsync
     *
     * Update a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWebhooksPayloadTemplateAsync($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {
        return $this->updateNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, $update_network_webhooks_payload_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWebhooksPayloadTemplateAsyncWithHttpInfo
     *
     * Update a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
        $request = $this->updateNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $update_network_webhooks_payload_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWebhooksPayloadTemplate'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWebhooksPayloadTemplate'
            );
        }

        // verify the required parameter 'payload_template_id' is set
        if ($payload_template_id === null || (is_array($payload_template_id) && count($payload_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payload_template_id when calling updateNetworkWebhooksPayloadTemplate'
            );
        }



        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($payload_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'payloadTemplateId' . '}',
                ObjectSerializer::toPathValue($payload_template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_webhooks_payload_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_webhooks_payload_template_request));
            } else {
                $httpBody = $update_network_webhooks_payload_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vmxNetworkDevicesClaim
     *
     * Claim a vMX into a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\VmxNetworkDevicesClaim200Response
     */
    public function vmxNetworkDevicesClaim($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {
        list($response) = $this->vmxNetworkDevicesClaimWithHttpInfo($network_id, $vmx_network_devices_claim_request, $contentType);
        return $response;
    }

    /**
     * Operation vmxNetworkDevicesClaimWithHttpInfo
     *
     * Claim a vMX into a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\VmxNetworkDevicesClaim200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function vmxNetworkDevicesClaimWithHttpInfo($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {
        $request = $this->vmxNetworkDevicesClaimRequest($network_id, $vmx_network_devices_claim_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\VmxNetworkDevicesClaim200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\VmxNetworkDevicesClaim200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\VmxNetworkDevicesClaim200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\VmxNetworkDevicesClaim200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\VmxNetworkDevicesClaim200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vmxNetworkDevicesClaimAsync
     *
     * Claim a vMX into a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vmxNetworkDevicesClaimAsync($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {
        return $this->vmxNetworkDevicesClaimAsyncWithHttpInfo($network_id, $vmx_network_devices_claim_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vmxNetworkDevicesClaimAsyncWithHttpInfo
     *
     * Claim a vMX into a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vmxNetworkDevicesClaimAsyncWithHttpInfo($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {
        $returnType = '\Meraki\Model\VmxNetworkDevicesClaim200Response';
        $request = $this->vmxNetworkDevicesClaimRequest($network_id, $vmx_network_devices_claim_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vmxNetworkDevicesClaim'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vmxNetworkDevicesClaimRequest($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling vmxNetworkDevicesClaim'
            );
        }

        // verify the required parameter 'vmx_network_devices_claim_request' is set
        if ($vmx_network_devices_claim_request === null || (is_array($vmx_network_devices_claim_request) && count($vmx_network_devices_claim_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vmx_network_devices_claim_request when calling vmxNetworkDevicesClaim'
            );
        }


        $resourcePath = '/networks/{networkId}/devices/claim/vmx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vmx_network_devices_claim_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vmx_network_devices_claim_request));
            } else {
                $httpBody = $vmx_network_devices_claim_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
