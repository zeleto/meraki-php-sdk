<?php
/**
 * DevicesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Meraki\ApiException;
use Meraki\Configuration;
use Meraki\HeaderSelector;
use Meraki\ObjectSerializer;

/**
 * DevicesApi Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DevicesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'batchNetworkFloorPlansDevicesUpdate' => [
            'application/json',
        ],
        'blinkDeviceLeds' => [
            'application/json',
        ],
        'bulkUpdateOrganizationDevicesDetails' => [
            'application/json',
        ],
        'checkinNetworkSmDevices' => [
            'application/json',
        ],
        'claimNetworkDevices' => [
            'application/json',
        ],
        'cloneOrganizationSwitchDevices' => [
            'application/json',
        ],
        'createDeviceLiveToolsArpTable' => [
            'application/json',
        ],
        'createDeviceLiveToolsCableTest' => [
            'application/json',
        ],
        'createDeviceLiveToolsLedsBlink' => [
            'application/json',
        ],
        'createDeviceLiveToolsPing' => [
            'application/json',
        ],
        'createDeviceLiveToolsPingDevice' => [
            'application/json',
        ],
        'createDeviceLiveToolsThroughputTest' => [
            'application/json',
        ],
        'createDeviceLiveToolsWakeOnLan' => [
            'application/json',
        ],
        'createOrganizationDevicesControllerMigration' => [
            'application/json',
        ],
        'createOrganizationInventoryDevicesSwapsBulk' => [
            'application/json',
        ],
        'getDevice' => [
            'application/json',
        ],
        'getDeviceCellularSims' => [
            'application/json',
        ],
        'getDeviceClients' => [
            'application/json',
        ],
        'getDeviceLiveToolsArpTable' => [
            'application/json',
        ],
        'getDeviceLiveToolsCableTest' => [
            'application/json',
        ],
        'getDeviceLiveToolsLedsBlink' => [
            'application/json',
        ],
        'getDeviceLiveToolsPing' => [
            'application/json',
        ],
        'getDeviceLiveToolsPingDevice' => [
            'application/json',
        ],
        'getDeviceLiveToolsThroughputTest' => [
            'application/json',
        ],
        'getDeviceLiveToolsWakeOnLan' => [
            'application/json',
        ],
        'getDeviceLldpCdp' => [
            'application/json',
        ],
        'getDeviceLossAndLatencyHistory' => [
            'application/json',
        ],
        'getDeviceManagementInterface' => [
            'application/json',
        ],
        'getNetworkDevices' => [
            'application/json',
        ],
        'getNetworkSmDeviceCellularUsageHistory' => [
            'application/json',
        ],
        'getNetworkSmDeviceCerts' => [
            'application/json',
        ],
        'getNetworkSmDeviceConnectivity' => [
            'application/json',
        ],
        'getNetworkSmDeviceDesktopLogs' => [
            'application/json',
        ],
        'getNetworkSmDeviceDeviceCommandLogs' => [
            'application/json',
        ],
        'getNetworkSmDeviceDeviceProfiles' => [
            'application/json',
        ],
        'getNetworkSmDeviceNetworkAdapters' => [
            'application/json',
        ],
        'getNetworkSmDevicePerformanceHistory' => [
            'application/json',
        ],
        'getNetworkSmDeviceRestrictions' => [
            'application/json',
        ],
        'getNetworkSmDeviceSecurityCenters' => [
            'application/json',
        ],
        'getNetworkSmDeviceSoftwares' => [
            'application/json',
        ],
        'getNetworkSmDeviceWlanLists' => [
            'application/json',
        ],
        'getNetworkSmDevices' => [
            'application/json',
        ],
        'getNetworkWirelessDevicesConnectionStats' => [
            'application/json',
        ],
        'getNetworkWirelessDevicesLatencyStats' => [
            'application/json',
        ],
        'getOrganizationDevices' => [
            'application/json',
        ],
        'getOrganizationDevicesAvailabilities' => [
            'application/json',
        ],
        'getOrganizationDevicesAvailabilitiesChangeHistory' => [
            'application/json',
        ],
        'getOrganizationDevicesControllerMigrations' => [
            'application/json',
        ],
        'getOrganizationDevicesOverviewByModel' => [
            'application/json',
        ],
        'getOrganizationDevicesPowerModulesStatusesByDevice' => [
            'application/json',
        ],
        'getOrganizationDevicesProvisioningStatuses' => [
            'application/json',
        ],
        'getOrganizationDevicesStatuses' => [
            'application/json',
        ],
        'getOrganizationDevicesStatusesOverview' => [
            'application/json',
        ],
        'getOrganizationDevicesSystemMemoryUsageHistoryByInterval' => [
            'application/json',
        ],
        'getOrganizationDevicesUplinksAddressesByDevice' => [
            'application/json',
        ],
        'getOrganizationDevicesUplinksLossAndLatency' => [
            'application/json',
        ],
        'getOrganizationFloorPlansAutoLocateDevices' => [
            'application/json',
        ],
        'getOrganizationInventoryDevice' => [
            'application/json',
        ],
        'getOrganizationInventoryDevices' => [
            'application/json',
        ],
        'getOrganizationInventoryDevicesSwapsBulk' => [
            'application/json',
        ],
        'getOrganizationSummaryTopDevicesByUsage' => [
            'application/json',
        ],
        'getOrganizationSummaryTopDevicesModelsByUsage' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesInterfacesL2ByDevice' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesInterfacesL3ByDevice' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesRedundancyFailoverHistory' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesRedundancyStatuses' => [
            'application/json',
        ],
        'getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesChannelUtilizationByDevice' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesChannelUtilizationByNetwork' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesEthernetStatuses' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesPacketLossByClient' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesPacketLossByDevice' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesPacketLossByNetwork' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesPowerModeHistory' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesSystemCpuLoadHistory' => [
            'application/json',
        ],
        'getOrganizationWirelessDevicesWirelessControllersByDevice' => [
            'application/json',
        ],
        'installNetworkSmDeviceApps' => [
            'application/json',
        ],
        'lockNetworkSmDevices' => [
            'application/json',
        ],
        'modifyNetworkSmDevicesTags' => [
            'application/json',
        ],
        'moveNetworkSmDevices' => [
            'application/json',
        ],
        'rebootDevice' => [
            'application/json',
        ],
        'rebootNetworkSmDevices' => [
            'application/json',
        ],
        'refreshNetworkSmDeviceDetails' => [
            'application/json',
        ],
        'removeNetworkDevices' => [
            'application/json',
        ],
        'shutdownNetworkSmDevices' => [
            'application/json',
        ],
        'unenrollNetworkSmDevice' => [
            'application/json',
        ],
        'uninstallNetworkSmDeviceApps' => [
            'application/json',
        ],
        'updateDevice' => [
            'application/json',
        ],
        'updateDeviceCellularSims' => [
            'application/json',
        ],
        'updateDeviceManagementInterface' => [
            'application/json',
        ],
        'updateNetworkSmDevicesFields' => [
            'application/json',
        ],
        'vmxNetworkDevicesClaim' => [
            'application/json',
        ],
        'wipeNetworkSmDevices' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation batchNetworkFloorPlansDevicesUpdate
     *
     * Update floorplan assignments for a batch of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response
     */
    public function batchNetworkFloorPlansDevicesUpdate($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {
        list($response) = $this->batchNetworkFloorPlansDevicesUpdateWithHttpInfo($network_id, $batch_network_floor_plans_devices_update_request, $contentType);
        return $response;
    }

    /**
     * Operation batchNetworkFloorPlansDevicesUpdateWithHttpInfo
     *
     * Update floorplan assignments for a batch of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function batchNetworkFloorPlansDevicesUpdateWithHttpInfo($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {
        $request = $this->batchNetworkFloorPlansDevicesUpdateRequest($network_id, $batch_network_floor_plans_devices_update_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation batchNetworkFloorPlansDevicesUpdateAsync
     *
     * Update floorplan assignments for a batch of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchNetworkFloorPlansDevicesUpdateAsync($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {
        return $this->batchNetworkFloorPlansDevicesUpdateAsyncWithHttpInfo($network_id, $batch_network_floor_plans_devices_update_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchNetworkFloorPlansDevicesUpdateAsyncWithHttpInfo
     *
     * Update floorplan assignments for a batch of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchNetworkFloorPlansDevicesUpdateAsyncWithHttpInfo($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {
        $returnType = '\Meraki\Model\BatchNetworkFloorPlansDevicesUpdate200Response';
        $request = $this->batchNetworkFloorPlansDevicesUpdateRequest($network_id, $batch_network_floor_plans_devices_update_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batchNetworkFloorPlansDevicesUpdate'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\BatchNetworkFloorPlansDevicesUpdateRequest $batch_network_floor_plans_devices_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['batchNetworkFloorPlansDevicesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function batchNetworkFloorPlansDevicesUpdateRequest($network_id, $batch_network_floor_plans_devices_update_request, string $contentType = self::contentTypes['batchNetworkFloorPlansDevicesUpdate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling batchNetworkFloorPlansDevicesUpdate'
            );
        }

        // verify the required parameter 'batch_network_floor_plans_devices_update_request' is set
        if ($batch_network_floor_plans_devices_update_request === null || (is_array($batch_network_floor_plans_devices_update_request) && count($batch_network_floor_plans_devices_update_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch_network_floor_plans_devices_update_request when calling batchNetworkFloorPlansDevicesUpdate'
            );
        }


        $resourcePath = '/networks/{networkId}/floorPlans/devices/batchUpdate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_network_floor_plans_devices_update_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_network_floor_plans_devices_update_request));
            } else {
                $httpBody = $batch_network_floor_plans_devices_update_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation blinkDeviceLeds
     *
     * Blink the LEDs on a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\BlinkDeviceLedsRequest|null $blink_device_leds_request blink_device_leds_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blinkDeviceLeds'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\BlinkDeviceLeds202Response
     * @deprecated
     */
    public function blinkDeviceLeds($serial, $blink_device_leds_request = null, string $contentType = self::contentTypes['blinkDeviceLeds'][0])
    {
        list($response) = $this->blinkDeviceLedsWithHttpInfo($serial, $blink_device_leds_request, $contentType);
        return $response;
    }

    /**
     * Operation blinkDeviceLedsWithHttpInfo
     *
     * Blink the LEDs on a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\BlinkDeviceLedsRequest|null $blink_device_leds_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blinkDeviceLeds'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\BlinkDeviceLeds202Response, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function blinkDeviceLedsWithHttpInfo($serial, $blink_device_leds_request = null, string $contentType = self::contentTypes['blinkDeviceLeds'][0])
    {
        $request = $this->blinkDeviceLedsRequest($serial, $blink_device_leds_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\Meraki\Model\BlinkDeviceLeds202Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\BlinkDeviceLeds202Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\BlinkDeviceLeds202Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\BlinkDeviceLeds202Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\BlinkDeviceLeds202Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation blinkDeviceLedsAsync
     *
     * Blink the LEDs on a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\BlinkDeviceLedsRequest|null $blink_device_leds_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blinkDeviceLeds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function blinkDeviceLedsAsync($serial, $blink_device_leds_request = null, string $contentType = self::contentTypes['blinkDeviceLeds'][0])
    {
        return $this->blinkDeviceLedsAsyncWithHttpInfo($serial, $blink_device_leds_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation blinkDeviceLedsAsyncWithHttpInfo
     *
     * Blink the LEDs on a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\BlinkDeviceLedsRequest|null $blink_device_leds_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blinkDeviceLeds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function blinkDeviceLedsAsyncWithHttpInfo($serial, $blink_device_leds_request = null, string $contentType = self::contentTypes['blinkDeviceLeds'][0])
    {
        $returnType = '\Meraki\Model\BlinkDeviceLeds202Response';
        $request = $this->blinkDeviceLedsRequest($serial, $blink_device_leds_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'blinkDeviceLeds'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\BlinkDeviceLedsRequest|null $blink_device_leds_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blinkDeviceLeds'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function blinkDeviceLedsRequest($serial, $blink_device_leds_request = null, string $contentType = self::contentTypes['blinkDeviceLeds'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling blinkDeviceLeds'
            );
        }



        $resourcePath = '/devices/{serial}/blinkLeds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($blink_device_leds_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($blink_device_leds_request));
            } else {
                $httpBody = $blink_device_leds_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkUpdateOrganizationDevicesDetails
     *
     * Updating device details (currently only used for Catalyst devices)
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkUpdateOrganizationDevicesDetailsRequest $bulk_update_organization_devices_details_request bulk_update_organization_devices_details_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateOrganizationDevicesDetails'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\BulkUpdateOrganizationDevicesDetails200Response
     */
    public function bulkUpdateOrganizationDevicesDetails($organization_id, $bulk_update_organization_devices_details_request, string $contentType = self::contentTypes['bulkUpdateOrganizationDevicesDetails'][0])
    {
        list($response) = $this->bulkUpdateOrganizationDevicesDetailsWithHttpInfo($organization_id, $bulk_update_organization_devices_details_request, $contentType);
        return $response;
    }

    /**
     * Operation bulkUpdateOrganizationDevicesDetailsWithHttpInfo
     *
     * Updating device details (currently only used for Catalyst devices)
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkUpdateOrganizationDevicesDetailsRequest $bulk_update_organization_devices_details_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateOrganizationDevicesDetails'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\BulkUpdateOrganizationDevicesDetails200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkUpdateOrganizationDevicesDetailsWithHttpInfo($organization_id, $bulk_update_organization_devices_details_request, string $contentType = self::contentTypes['bulkUpdateOrganizationDevicesDetails'][0])
    {
        $request = $this->bulkUpdateOrganizationDevicesDetailsRequest($organization_id, $bulk_update_organization_devices_details_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\BulkUpdateOrganizationDevicesDetails200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\BulkUpdateOrganizationDevicesDetails200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\BulkUpdateOrganizationDevicesDetails200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\BulkUpdateOrganizationDevicesDetails200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\BulkUpdateOrganizationDevicesDetails200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkUpdateOrganizationDevicesDetailsAsync
     *
     * Updating device details (currently only used for Catalyst devices)
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkUpdateOrganizationDevicesDetailsRequest $bulk_update_organization_devices_details_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateOrganizationDevicesDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkUpdateOrganizationDevicesDetailsAsync($organization_id, $bulk_update_organization_devices_details_request, string $contentType = self::contentTypes['bulkUpdateOrganizationDevicesDetails'][0])
    {
        return $this->bulkUpdateOrganizationDevicesDetailsAsyncWithHttpInfo($organization_id, $bulk_update_organization_devices_details_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkUpdateOrganizationDevicesDetailsAsyncWithHttpInfo
     *
     * Updating device details (currently only used for Catalyst devices)
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkUpdateOrganizationDevicesDetailsRequest $bulk_update_organization_devices_details_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateOrganizationDevicesDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkUpdateOrganizationDevicesDetailsAsyncWithHttpInfo($organization_id, $bulk_update_organization_devices_details_request, string $contentType = self::contentTypes['bulkUpdateOrganizationDevicesDetails'][0])
    {
        $returnType = '\Meraki\Model\BulkUpdateOrganizationDevicesDetails200Response';
        $request = $this->bulkUpdateOrganizationDevicesDetailsRequest($organization_id, $bulk_update_organization_devices_details_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkUpdateOrganizationDevicesDetails'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\BulkUpdateOrganizationDevicesDetailsRequest $bulk_update_organization_devices_details_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateOrganizationDevicesDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkUpdateOrganizationDevicesDetailsRequest($organization_id, $bulk_update_organization_devices_details_request, string $contentType = self::contentTypes['bulkUpdateOrganizationDevicesDetails'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling bulkUpdateOrganizationDevicesDetails'
            );
        }

        // verify the required parameter 'bulk_update_organization_devices_details_request' is set
        if ($bulk_update_organization_devices_details_request === null || (is_array($bulk_update_organization_devices_details_request) && count($bulk_update_organization_devices_details_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulk_update_organization_devices_details_request when calling bulkUpdateOrganizationDevicesDetails'
            );
        }


        $resourcePath = '/organizations/{organizationId}/devices/details/bulkUpdate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_update_organization_devices_details_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_update_organization_devices_details_request));
            } else {
                $httpBody = $bulk_update_organization_devices_details_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkinNetworkSmDevices
     *
     * Force check-in a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CheckinNetworkSmDevicesRequest|null $checkin_network_sm_devices_request checkin_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkinNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CheckinNetworkSmDevices200Response
     */
    public function checkinNetworkSmDevices($network_id, $checkin_network_sm_devices_request = null, string $contentType = self::contentTypes['checkinNetworkSmDevices'][0])
    {
        list($response) = $this->checkinNetworkSmDevicesWithHttpInfo($network_id, $checkin_network_sm_devices_request, $contentType);
        return $response;
    }

    /**
     * Operation checkinNetworkSmDevicesWithHttpInfo
     *
     * Force check-in a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CheckinNetworkSmDevicesRequest|null $checkin_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkinNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CheckinNetworkSmDevices200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkinNetworkSmDevicesWithHttpInfo($network_id, $checkin_network_sm_devices_request = null, string $contentType = self::contentTypes['checkinNetworkSmDevices'][0])
    {
        $request = $this->checkinNetworkSmDevicesRequest($network_id, $checkin_network_sm_devices_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CheckinNetworkSmDevices200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CheckinNetworkSmDevices200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CheckinNetworkSmDevices200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CheckinNetworkSmDevices200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CheckinNetworkSmDevices200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkinNetworkSmDevicesAsync
     *
     * Force check-in a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CheckinNetworkSmDevicesRequest|null $checkin_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkinNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkinNetworkSmDevicesAsync($network_id, $checkin_network_sm_devices_request = null, string $contentType = self::contentTypes['checkinNetworkSmDevices'][0])
    {
        return $this->checkinNetworkSmDevicesAsyncWithHttpInfo($network_id, $checkin_network_sm_devices_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkinNetworkSmDevicesAsyncWithHttpInfo
     *
     * Force check-in a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CheckinNetworkSmDevicesRequest|null $checkin_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkinNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkinNetworkSmDevicesAsyncWithHttpInfo($network_id, $checkin_network_sm_devices_request = null, string $contentType = self::contentTypes['checkinNetworkSmDevices'][0])
    {
        $returnType = '\Meraki\Model\CheckinNetworkSmDevices200Response';
        $request = $this->checkinNetworkSmDevicesRequest($network_id, $checkin_network_sm_devices_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkinNetworkSmDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CheckinNetworkSmDevicesRequest|null $checkin_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkinNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkinNetworkSmDevicesRequest($network_id, $checkin_network_sm_devices_request = null, string $contentType = self::contentTypes['checkinNetworkSmDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling checkinNetworkSmDevices'
            );
        }



        $resourcePath = '/networks/{networkId}/sm/devices/checkin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($checkin_network_sm_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($checkin_network_sm_devices_request));
            } else {
                $httpBody = $checkin_network_sm_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation claimNetworkDevices
     *
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\ClaimNetworkDevices200Response
     */
    public function claimNetworkDevices($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {
        list($response) = $this->claimNetworkDevicesWithHttpInfo($network_id, $claim_network_devices_request, $add_atomically, $contentType);
        return $response;
    }

    /**
     * Operation claimNetworkDevicesWithHttpInfo
     *
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\ClaimNetworkDevices200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function claimNetworkDevicesWithHttpInfo($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {
        $request = $this->claimNetworkDevicesRequest($network_id, $claim_network_devices_request, $add_atomically, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\ClaimNetworkDevices200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\ClaimNetworkDevices200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\ClaimNetworkDevices200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\ClaimNetworkDevices200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\ClaimNetworkDevices200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation claimNetworkDevicesAsync
     *
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function claimNetworkDevicesAsync($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {
        return $this->claimNetworkDevicesAsyncWithHttpInfo($network_id, $claim_network_devices_request, $add_atomically, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation claimNetworkDevicesAsyncWithHttpInfo
     *
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requests against that device to succeed)
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function claimNetworkDevicesAsyncWithHttpInfo($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {
        $returnType = '\Meraki\Model\ClaimNetworkDevices200Response';
        $request = $this->claimNetworkDevicesRequest($network_id, $claim_network_devices_request, $add_atomically, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'claimNetworkDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ClaimNetworkDevicesRequest $claim_network_devices_request (required)
     * @param  bool|null $add_atomically Whether to claim devices atomically. If true, all devices will be claimed or none will be claimed. Default is true. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['claimNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function claimNetworkDevicesRequest($network_id, $claim_network_devices_request, $add_atomically = null, string $contentType = self::contentTypes['claimNetworkDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling claimNetworkDevices'
            );
        }

        // verify the required parameter 'claim_network_devices_request' is set
        if ($claim_network_devices_request === null || (is_array($claim_network_devices_request) && count($claim_network_devices_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $claim_network_devices_request when calling claimNetworkDevices'
            );
        }



        $resourcePath = '/networks/{networkId}/devices/claim';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_atomically,
            'addAtomically', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($claim_network_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($claim_network_devices_request));
            } else {
                $httpBody = $claim_network_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloneOrganizationSwitchDevices
     *
     * Clone port-level and some switch-level configuration settings from a source switch to one or more target switches
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CloneOrganizationSwitchDevicesRequest $clone_organization_switch_devices_request clone_organization_switch_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneOrganizationSwitchDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CloneOrganizationSwitchDevices200Response
     */
    public function cloneOrganizationSwitchDevices($organization_id, $clone_organization_switch_devices_request, string $contentType = self::contentTypes['cloneOrganizationSwitchDevices'][0])
    {
        list($response) = $this->cloneOrganizationSwitchDevicesWithHttpInfo($organization_id, $clone_organization_switch_devices_request, $contentType);
        return $response;
    }

    /**
     * Operation cloneOrganizationSwitchDevicesWithHttpInfo
     *
     * Clone port-level and some switch-level configuration settings from a source switch to one or more target switches
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CloneOrganizationSwitchDevicesRequest $clone_organization_switch_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneOrganizationSwitchDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CloneOrganizationSwitchDevices200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloneOrganizationSwitchDevicesWithHttpInfo($organization_id, $clone_organization_switch_devices_request, string $contentType = self::contentTypes['cloneOrganizationSwitchDevices'][0])
    {
        $request = $this->cloneOrganizationSwitchDevicesRequest($organization_id, $clone_organization_switch_devices_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CloneOrganizationSwitchDevices200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CloneOrganizationSwitchDevices200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CloneOrganizationSwitchDevices200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CloneOrganizationSwitchDevices200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CloneOrganizationSwitchDevices200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloneOrganizationSwitchDevicesAsync
     *
     * Clone port-level and some switch-level configuration settings from a source switch to one or more target switches
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CloneOrganizationSwitchDevicesRequest $clone_organization_switch_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneOrganizationSwitchDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneOrganizationSwitchDevicesAsync($organization_id, $clone_organization_switch_devices_request, string $contentType = self::contentTypes['cloneOrganizationSwitchDevices'][0])
    {
        return $this->cloneOrganizationSwitchDevicesAsyncWithHttpInfo($organization_id, $clone_organization_switch_devices_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloneOrganizationSwitchDevicesAsyncWithHttpInfo
     *
     * Clone port-level and some switch-level configuration settings from a source switch to one or more target switches
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CloneOrganizationSwitchDevicesRequest $clone_organization_switch_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneOrganizationSwitchDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneOrganizationSwitchDevicesAsyncWithHttpInfo($organization_id, $clone_organization_switch_devices_request, string $contentType = self::contentTypes['cloneOrganizationSwitchDevices'][0])
    {
        $returnType = '\Meraki\Model\CloneOrganizationSwitchDevices200Response';
        $request = $this->cloneOrganizationSwitchDevicesRequest($organization_id, $clone_organization_switch_devices_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloneOrganizationSwitchDevices'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CloneOrganizationSwitchDevicesRequest $clone_organization_switch_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloneOrganizationSwitchDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloneOrganizationSwitchDevicesRequest($organization_id, $clone_organization_switch_devices_request, string $contentType = self::contentTypes['cloneOrganizationSwitchDevices'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling cloneOrganizationSwitchDevices'
            );
        }

        // verify the required parameter 'clone_organization_switch_devices_request' is set
        if ($clone_organization_switch_devices_request === null || (is_array($clone_organization_switch_devices_request) && count($clone_organization_switch_devices_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clone_organization_switch_devices_request when calling cloneOrganizationSwitchDevices'
            );
        }


        $resourcePath = '/organizations/{organizationId}/switch/devices/clone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($clone_organization_switch_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($clone_organization_switch_devices_request));
            } else {
                $httpBody = $clone_organization_switch_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDeviceLiveToolsArpTable
     *
     * Enqueue a job to perform a ARP table request for the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateDeviceLiveToolsArpTable201Response
     */
    public function createDeviceLiveToolsArpTable($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsArpTable'][0])
    {
        list($response) = $this->createDeviceLiveToolsArpTableWithHttpInfo($serial, $create_device_live_tools_arp_table_request, $contentType);
        return $response;
    }

    /**
     * Operation createDeviceLiveToolsArpTableWithHttpInfo
     *
     * Enqueue a job to perform a ARP table request for the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateDeviceLiveToolsArpTable201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeviceLiveToolsArpTableWithHttpInfo($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsArpTable'][0])
    {
        $request = $this->createDeviceLiveToolsArpTableRequest($serial, $create_device_live_tools_arp_table_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateDeviceLiveToolsArpTable201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateDeviceLiveToolsArpTable201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateDeviceLiveToolsArpTable201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateDeviceLiveToolsArpTable201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateDeviceLiveToolsArpTable201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeviceLiveToolsArpTableAsync
     *
     * Enqueue a job to perform a ARP table request for the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsArpTableAsync($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsArpTable'][0])
    {
        return $this->createDeviceLiveToolsArpTableAsyncWithHttpInfo($serial, $create_device_live_tools_arp_table_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeviceLiveToolsArpTableAsyncWithHttpInfo
     *
     * Enqueue a job to perform a ARP table request for the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsArpTableAsyncWithHttpInfo($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsArpTable'][0])
    {
        $returnType = '\Meraki\Model\CreateDeviceLiveToolsArpTable201Response';
        $request = $this->createDeviceLiveToolsArpTableRequest($serial, $create_device_live_tools_arp_table_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeviceLiveToolsArpTable'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDeviceLiveToolsArpTableRequest($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsArpTable'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling createDeviceLiveToolsArpTable'
            );
        }



        $resourcePath = '/devices/{serial}/liveTools/arpTable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_device_live_tools_arp_table_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_device_live_tools_arp_table_request));
            } else {
                $httpBody = $create_device_live_tools_arp_table_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDeviceLiveToolsCableTest
     *
     * Enqueue a job to perform a cable test for the device on the specified ports
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsCableTestRequest $create_device_live_tools_cable_test_request create_device_live_tools_cable_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateDeviceLiveToolsCableTest201Response
     */
    public function createDeviceLiveToolsCableTest($serial, $create_device_live_tools_cable_test_request, string $contentType = self::contentTypes['createDeviceLiveToolsCableTest'][0])
    {
        list($response) = $this->createDeviceLiveToolsCableTestWithHttpInfo($serial, $create_device_live_tools_cable_test_request, $contentType);
        return $response;
    }

    /**
     * Operation createDeviceLiveToolsCableTestWithHttpInfo
     *
     * Enqueue a job to perform a cable test for the device on the specified ports
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsCableTestRequest $create_device_live_tools_cable_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateDeviceLiveToolsCableTest201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeviceLiveToolsCableTestWithHttpInfo($serial, $create_device_live_tools_cable_test_request, string $contentType = self::contentTypes['createDeviceLiveToolsCableTest'][0])
    {
        $request = $this->createDeviceLiveToolsCableTestRequest($serial, $create_device_live_tools_cable_test_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateDeviceLiveToolsCableTest201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateDeviceLiveToolsCableTest201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateDeviceLiveToolsCableTest201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateDeviceLiveToolsCableTest201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateDeviceLiveToolsCableTest201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeviceLiveToolsCableTestAsync
     *
     * Enqueue a job to perform a cable test for the device on the specified ports
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsCableTestRequest $create_device_live_tools_cable_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsCableTestAsync($serial, $create_device_live_tools_cable_test_request, string $contentType = self::contentTypes['createDeviceLiveToolsCableTest'][0])
    {
        return $this->createDeviceLiveToolsCableTestAsyncWithHttpInfo($serial, $create_device_live_tools_cable_test_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeviceLiveToolsCableTestAsyncWithHttpInfo
     *
     * Enqueue a job to perform a cable test for the device on the specified ports
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsCableTestRequest $create_device_live_tools_cable_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsCableTestAsyncWithHttpInfo($serial, $create_device_live_tools_cable_test_request, string $contentType = self::contentTypes['createDeviceLiveToolsCableTest'][0])
    {
        $returnType = '\Meraki\Model\CreateDeviceLiveToolsCableTest201Response';
        $request = $this->createDeviceLiveToolsCableTestRequest($serial, $create_device_live_tools_cable_test_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeviceLiveToolsCableTest'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsCableTestRequest $create_device_live_tools_cable_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDeviceLiveToolsCableTestRequest($serial, $create_device_live_tools_cable_test_request, string $contentType = self::contentTypes['createDeviceLiveToolsCableTest'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling createDeviceLiveToolsCableTest'
            );
        }

        // verify the required parameter 'create_device_live_tools_cable_test_request' is set
        if ($create_device_live_tools_cable_test_request === null || (is_array($create_device_live_tools_cable_test_request) && count($create_device_live_tools_cable_test_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_device_live_tools_cable_test_request when calling createDeviceLiveToolsCableTest'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/cableTest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_device_live_tools_cable_test_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_device_live_tools_cable_test_request));
            } else {
                $httpBody = $create_device_live_tools_cable_test_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDeviceLiveToolsLedsBlink
     *
     * Enqueue a job to blink LEDs on a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsLedsBlinkRequest $create_device_live_tools_leds_blink_request create_device_live_tools_leds_blink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateDeviceLiveToolsLedsBlink201Response
     */
    public function createDeviceLiveToolsLedsBlink($serial, $create_device_live_tools_leds_blink_request, string $contentType = self::contentTypes['createDeviceLiveToolsLedsBlink'][0])
    {
        list($response) = $this->createDeviceLiveToolsLedsBlinkWithHttpInfo($serial, $create_device_live_tools_leds_blink_request, $contentType);
        return $response;
    }

    /**
     * Operation createDeviceLiveToolsLedsBlinkWithHttpInfo
     *
     * Enqueue a job to blink LEDs on a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsLedsBlinkRequest $create_device_live_tools_leds_blink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateDeviceLiveToolsLedsBlink201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeviceLiveToolsLedsBlinkWithHttpInfo($serial, $create_device_live_tools_leds_blink_request, string $contentType = self::contentTypes['createDeviceLiveToolsLedsBlink'][0])
    {
        $request = $this->createDeviceLiveToolsLedsBlinkRequest($serial, $create_device_live_tools_leds_blink_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateDeviceLiveToolsLedsBlink201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateDeviceLiveToolsLedsBlink201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateDeviceLiveToolsLedsBlink201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateDeviceLiveToolsLedsBlink201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateDeviceLiveToolsLedsBlink201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeviceLiveToolsLedsBlinkAsync
     *
     * Enqueue a job to blink LEDs on a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsLedsBlinkRequest $create_device_live_tools_leds_blink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsLedsBlinkAsync($serial, $create_device_live_tools_leds_blink_request, string $contentType = self::contentTypes['createDeviceLiveToolsLedsBlink'][0])
    {
        return $this->createDeviceLiveToolsLedsBlinkAsyncWithHttpInfo($serial, $create_device_live_tools_leds_blink_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeviceLiveToolsLedsBlinkAsyncWithHttpInfo
     *
     * Enqueue a job to blink LEDs on a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsLedsBlinkRequest $create_device_live_tools_leds_blink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsLedsBlinkAsyncWithHttpInfo($serial, $create_device_live_tools_leds_blink_request, string $contentType = self::contentTypes['createDeviceLiveToolsLedsBlink'][0])
    {
        $returnType = '\Meraki\Model\CreateDeviceLiveToolsLedsBlink201Response';
        $request = $this->createDeviceLiveToolsLedsBlinkRequest($serial, $create_device_live_tools_leds_blink_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeviceLiveToolsLedsBlink'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsLedsBlinkRequest $create_device_live_tools_leds_blink_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDeviceLiveToolsLedsBlinkRequest($serial, $create_device_live_tools_leds_blink_request, string $contentType = self::contentTypes['createDeviceLiveToolsLedsBlink'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling createDeviceLiveToolsLedsBlink'
            );
        }

        // verify the required parameter 'create_device_live_tools_leds_blink_request' is set
        if ($create_device_live_tools_leds_blink_request === null || (is_array($create_device_live_tools_leds_blink_request) && count($create_device_live_tools_leds_blink_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_device_live_tools_leds_blink_request when calling createDeviceLiveToolsLedsBlink'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/leds/blink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_device_live_tools_leds_blink_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_device_live_tools_leds_blink_request));
            } else {
                $httpBody = $create_device_live_tools_leds_blink_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDeviceLiveToolsPing
     *
     * Enqueue a job to ping a target host from the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingRequest $create_device_live_tools_ping_request create_device_live_tools_ping_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateDeviceLiveToolsPing201Response
     */
    public function createDeviceLiveToolsPing($serial, $create_device_live_tools_ping_request, string $contentType = self::contentTypes['createDeviceLiveToolsPing'][0])
    {
        list($response) = $this->createDeviceLiveToolsPingWithHttpInfo($serial, $create_device_live_tools_ping_request, $contentType);
        return $response;
    }

    /**
     * Operation createDeviceLiveToolsPingWithHttpInfo
     *
     * Enqueue a job to ping a target host from the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingRequest $create_device_live_tools_ping_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateDeviceLiveToolsPing201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeviceLiveToolsPingWithHttpInfo($serial, $create_device_live_tools_ping_request, string $contentType = self::contentTypes['createDeviceLiveToolsPing'][0])
    {
        $request = $this->createDeviceLiveToolsPingRequest($serial, $create_device_live_tools_ping_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateDeviceLiveToolsPing201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateDeviceLiveToolsPing201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateDeviceLiveToolsPing201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateDeviceLiveToolsPing201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateDeviceLiveToolsPing201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeviceLiveToolsPingAsync
     *
     * Enqueue a job to ping a target host from the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingRequest $create_device_live_tools_ping_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsPingAsync($serial, $create_device_live_tools_ping_request, string $contentType = self::contentTypes['createDeviceLiveToolsPing'][0])
    {
        return $this->createDeviceLiveToolsPingAsyncWithHttpInfo($serial, $create_device_live_tools_ping_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeviceLiveToolsPingAsyncWithHttpInfo
     *
     * Enqueue a job to ping a target host from the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingRequest $create_device_live_tools_ping_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsPingAsyncWithHttpInfo($serial, $create_device_live_tools_ping_request, string $contentType = self::contentTypes['createDeviceLiveToolsPing'][0])
    {
        $returnType = '\Meraki\Model\CreateDeviceLiveToolsPing201Response';
        $request = $this->createDeviceLiveToolsPingRequest($serial, $create_device_live_tools_ping_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeviceLiveToolsPing'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingRequest $create_device_live_tools_ping_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDeviceLiveToolsPingRequest($serial, $create_device_live_tools_ping_request, string $contentType = self::contentTypes['createDeviceLiveToolsPing'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling createDeviceLiveToolsPing'
            );
        }

        // verify the required parameter 'create_device_live_tools_ping_request' is set
        if ($create_device_live_tools_ping_request === null || (is_array($create_device_live_tools_ping_request) && count($create_device_live_tools_ping_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_device_live_tools_ping_request when calling createDeviceLiveToolsPing'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/ping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_device_live_tools_ping_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_device_live_tools_ping_request));
            } else {
                $httpBody = $create_device_live_tools_ping_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDeviceLiveToolsPingDevice
     *
     * Enqueue a job to check connectivity status to the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingDeviceRequest|null $create_device_live_tools_ping_device_request create_device_live_tools_ping_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateDeviceLiveToolsPingDevice201Response
     */
    public function createDeviceLiveToolsPingDevice($serial, $create_device_live_tools_ping_device_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsPingDevice'][0])
    {
        list($response) = $this->createDeviceLiveToolsPingDeviceWithHttpInfo($serial, $create_device_live_tools_ping_device_request, $contentType);
        return $response;
    }

    /**
     * Operation createDeviceLiveToolsPingDeviceWithHttpInfo
     *
     * Enqueue a job to check connectivity status to the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingDeviceRequest|null $create_device_live_tools_ping_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateDeviceLiveToolsPingDevice201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeviceLiveToolsPingDeviceWithHttpInfo($serial, $create_device_live_tools_ping_device_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsPingDevice'][0])
    {
        $request = $this->createDeviceLiveToolsPingDeviceRequest($serial, $create_device_live_tools_ping_device_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateDeviceLiveToolsPingDevice201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateDeviceLiveToolsPingDevice201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateDeviceLiveToolsPingDevice201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateDeviceLiveToolsPingDevice201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateDeviceLiveToolsPingDevice201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeviceLiveToolsPingDeviceAsync
     *
     * Enqueue a job to check connectivity status to the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingDeviceRequest|null $create_device_live_tools_ping_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsPingDeviceAsync($serial, $create_device_live_tools_ping_device_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsPingDevice'][0])
    {
        return $this->createDeviceLiveToolsPingDeviceAsyncWithHttpInfo($serial, $create_device_live_tools_ping_device_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeviceLiveToolsPingDeviceAsyncWithHttpInfo
     *
     * Enqueue a job to check connectivity status to the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingDeviceRequest|null $create_device_live_tools_ping_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsPingDeviceAsyncWithHttpInfo($serial, $create_device_live_tools_ping_device_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsPingDevice'][0])
    {
        $returnType = '\Meraki\Model\CreateDeviceLiveToolsPingDevice201Response';
        $request = $this->createDeviceLiveToolsPingDeviceRequest($serial, $create_device_live_tools_ping_device_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeviceLiveToolsPingDevice'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsPingDeviceRequest|null $create_device_live_tools_ping_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDeviceLiveToolsPingDeviceRequest($serial, $create_device_live_tools_ping_device_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsPingDevice'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling createDeviceLiveToolsPingDevice'
            );
        }



        $resourcePath = '/devices/{serial}/liveTools/pingDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_device_live_tools_ping_device_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_device_live_tools_ping_device_request));
            } else {
                $httpBody = $create_device_live_tools_ping_device_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDeviceLiveToolsThroughputTest
     *
     * Enqueue a job to test a device throughput, the test will run for 10 secs to test throughput
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateDeviceLiveToolsThroughputTest201Response
     */
    public function createDeviceLiveToolsThroughputTest($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsThroughputTest'][0])
    {
        list($response) = $this->createDeviceLiveToolsThroughputTestWithHttpInfo($serial, $create_device_live_tools_arp_table_request, $contentType);
        return $response;
    }

    /**
     * Operation createDeviceLiveToolsThroughputTestWithHttpInfo
     *
     * Enqueue a job to test a device throughput, the test will run for 10 secs to test throughput
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateDeviceLiveToolsThroughputTest201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeviceLiveToolsThroughputTestWithHttpInfo($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsThroughputTest'][0])
    {
        $request = $this->createDeviceLiveToolsThroughputTestRequest($serial, $create_device_live_tools_arp_table_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateDeviceLiveToolsThroughputTest201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateDeviceLiveToolsThroughputTest201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateDeviceLiveToolsThroughputTest201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateDeviceLiveToolsThroughputTest201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateDeviceLiveToolsThroughputTest201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeviceLiveToolsThroughputTestAsync
     *
     * Enqueue a job to test a device throughput, the test will run for 10 secs to test throughput
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsThroughputTestAsync($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsThroughputTest'][0])
    {
        return $this->createDeviceLiveToolsThroughputTestAsyncWithHttpInfo($serial, $create_device_live_tools_arp_table_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeviceLiveToolsThroughputTestAsyncWithHttpInfo
     *
     * Enqueue a job to test a device throughput, the test will run for 10 secs to test throughput
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsThroughputTestAsyncWithHttpInfo($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsThroughputTest'][0])
    {
        $returnType = '\Meraki\Model\CreateDeviceLiveToolsThroughputTest201Response';
        $request = $this->createDeviceLiveToolsThroughputTestRequest($serial, $create_device_live_tools_arp_table_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeviceLiveToolsThroughputTest'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsArpTableRequest|null $create_device_live_tools_arp_table_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDeviceLiveToolsThroughputTestRequest($serial, $create_device_live_tools_arp_table_request = null, string $contentType = self::contentTypes['createDeviceLiveToolsThroughputTest'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling createDeviceLiveToolsThroughputTest'
            );
        }



        $resourcePath = '/devices/{serial}/liveTools/throughputTest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_device_live_tools_arp_table_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_device_live_tools_arp_table_request));
            } else {
                $httpBody = $create_device_live_tools_arp_table_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDeviceLiveToolsWakeOnLan
     *
     * Enqueue a job to send a Wake-on-LAN packet from the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsWakeOnLanRequest $create_device_live_tools_wake_on_lan_request create_device_live_tools_wake_on_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateDeviceLiveToolsWakeOnLan201Response
     */
    public function createDeviceLiveToolsWakeOnLan($serial, $create_device_live_tools_wake_on_lan_request, string $contentType = self::contentTypes['createDeviceLiveToolsWakeOnLan'][0])
    {
        list($response) = $this->createDeviceLiveToolsWakeOnLanWithHttpInfo($serial, $create_device_live_tools_wake_on_lan_request, $contentType);
        return $response;
    }

    /**
     * Operation createDeviceLiveToolsWakeOnLanWithHttpInfo
     *
     * Enqueue a job to send a Wake-on-LAN packet from the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsWakeOnLanRequest $create_device_live_tools_wake_on_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateDeviceLiveToolsWakeOnLan201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeviceLiveToolsWakeOnLanWithHttpInfo($serial, $create_device_live_tools_wake_on_lan_request, string $contentType = self::contentTypes['createDeviceLiveToolsWakeOnLan'][0])
    {
        $request = $this->createDeviceLiveToolsWakeOnLanRequest($serial, $create_device_live_tools_wake_on_lan_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateDeviceLiveToolsWakeOnLan201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateDeviceLiveToolsWakeOnLan201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateDeviceLiveToolsWakeOnLan201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateDeviceLiveToolsWakeOnLan201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateDeviceLiveToolsWakeOnLan201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeviceLiveToolsWakeOnLanAsync
     *
     * Enqueue a job to send a Wake-on-LAN packet from the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsWakeOnLanRequest $create_device_live_tools_wake_on_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsWakeOnLanAsync($serial, $create_device_live_tools_wake_on_lan_request, string $contentType = self::contentTypes['createDeviceLiveToolsWakeOnLan'][0])
    {
        return $this->createDeviceLiveToolsWakeOnLanAsyncWithHttpInfo($serial, $create_device_live_tools_wake_on_lan_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeviceLiveToolsWakeOnLanAsyncWithHttpInfo
     *
     * Enqueue a job to send a Wake-on-LAN packet from the device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsWakeOnLanRequest $create_device_live_tools_wake_on_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeviceLiveToolsWakeOnLanAsyncWithHttpInfo($serial, $create_device_live_tools_wake_on_lan_request, string $contentType = self::contentTypes['createDeviceLiveToolsWakeOnLan'][0])
    {
        $returnType = '\Meraki\Model\CreateDeviceLiveToolsWakeOnLan201Response';
        $request = $this->createDeviceLiveToolsWakeOnLanRequest($serial, $create_device_live_tools_wake_on_lan_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeviceLiveToolsWakeOnLan'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\CreateDeviceLiveToolsWakeOnLanRequest $create_device_live_tools_wake_on_lan_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDeviceLiveToolsWakeOnLanRequest($serial, $create_device_live_tools_wake_on_lan_request, string $contentType = self::contentTypes['createDeviceLiveToolsWakeOnLan'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling createDeviceLiveToolsWakeOnLan'
            );
        }

        // verify the required parameter 'create_device_live_tools_wake_on_lan_request' is set
        if ($create_device_live_tools_wake_on_lan_request === null || (is_array($create_device_live_tools_wake_on_lan_request) && count($create_device_live_tools_wake_on_lan_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_device_live_tools_wake_on_lan_request when calling createDeviceLiveToolsWakeOnLan'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/wakeOnLan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_device_live_tools_wake_on_lan_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_device_live_tools_wake_on_lan_request));
            } else {
                $httpBody = $create_device_live_tools_wake_on_lan_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationDevicesControllerMigration
     *
     * Migrate devices to another controller or management mode
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationDevicesControllerMigrationRequest $create_organization_devices_controller_migration_request create_organization_devices_controller_migration_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationDevicesControllerMigration'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesControllerMigrations200ResponseItemsInner[]
     */
    public function createOrganizationDevicesControllerMigration($organization_id, $create_organization_devices_controller_migration_request, string $contentType = self::contentTypes['createOrganizationDevicesControllerMigration'][0])
    {
        list($response) = $this->createOrganizationDevicesControllerMigrationWithHttpInfo($organization_id, $create_organization_devices_controller_migration_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationDevicesControllerMigrationWithHttpInfo
     *
     * Migrate devices to another controller or management mode
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationDevicesControllerMigrationRequest $create_organization_devices_controller_migration_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationDevicesControllerMigration'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesControllerMigrations200ResponseItemsInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationDevicesControllerMigrationWithHttpInfo($organization_id, $create_organization_devices_controller_migration_request, string $contentType = self::contentTypes['createOrganizationDevicesControllerMigration'][0])
    {
        $request = $this->createOrganizationDevicesControllerMigrationRequest($organization_id, $create_organization_devices_controller_migration_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetOrganizationDevicesControllerMigrations200ResponseItemsInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesControllerMigrations200ResponseItemsInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesControllerMigrations200ResponseItemsInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesControllerMigrations200ResponseItemsInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesControllerMigrations200ResponseItemsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationDevicesControllerMigrationAsync
     *
     * Migrate devices to another controller or management mode
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationDevicesControllerMigrationRequest $create_organization_devices_controller_migration_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationDevicesControllerMigration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationDevicesControllerMigrationAsync($organization_id, $create_organization_devices_controller_migration_request, string $contentType = self::contentTypes['createOrganizationDevicesControllerMigration'][0])
    {
        return $this->createOrganizationDevicesControllerMigrationAsyncWithHttpInfo($organization_id, $create_organization_devices_controller_migration_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationDevicesControllerMigrationAsyncWithHttpInfo
     *
     * Migrate devices to another controller or management mode
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationDevicesControllerMigrationRequest $create_organization_devices_controller_migration_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationDevicesControllerMigration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationDevicesControllerMigrationAsyncWithHttpInfo($organization_id, $create_organization_devices_controller_migration_request, string $contentType = self::contentTypes['createOrganizationDevicesControllerMigration'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesControllerMigrations200ResponseItemsInner[]';
        $request = $this->createOrganizationDevicesControllerMigrationRequest($organization_id, $create_organization_devices_controller_migration_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationDevicesControllerMigration'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationDevicesControllerMigrationRequest $create_organization_devices_controller_migration_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationDevicesControllerMigration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationDevicesControllerMigrationRequest($organization_id, $create_organization_devices_controller_migration_request, string $contentType = self::contentTypes['createOrganizationDevicesControllerMigration'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationDevicesControllerMigration'
            );
        }

        // verify the required parameter 'create_organization_devices_controller_migration_request' is set
        if ($create_organization_devices_controller_migration_request === null || (is_array($create_organization_devices_controller_migration_request) && count($create_organization_devices_controller_migration_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_devices_controller_migration_request when calling createOrganizationDevicesControllerMigration'
            );
        }


        $resourcePath = '/organizations/{organizationId}/devices/controller/migrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_devices_controller_migration_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_devices_controller_migration_request));
            } else {
                $httpBody = $create_organization_devices_controller_migration_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createOrganizationInventoryDevicesSwapsBulk
     *
     * Swap the devices identified by devices.old with a devices.new, then perform the :afterAction on the devices.old.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulkRequest $create_organization_inventory_devices_swaps_bulk_request create_organization_inventory_devices_swaps_bulk_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response
     */
    public function createOrganizationInventoryDevicesSwapsBulk($organization_id, $create_organization_inventory_devices_swaps_bulk_request, string $contentType = self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'][0])
    {
        list($response) = $this->createOrganizationInventoryDevicesSwapsBulkWithHttpInfo($organization_id, $create_organization_inventory_devices_swaps_bulk_request, $contentType);
        return $response;
    }

    /**
     * Operation createOrganizationInventoryDevicesSwapsBulkWithHttpInfo
     *
     * Swap the devices identified by devices.old with a devices.new, then perform the :afterAction on the devices.old.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulkRequest $create_organization_inventory_devices_swaps_bulk_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createOrganizationInventoryDevicesSwapsBulkWithHttpInfo($organization_id, $create_organization_inventory_devices_swaps_bulk_request, string $contentType = self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'][0])
    {
        $request = $this->createOrganizationInventoryDevicesSwapsBulkRequest($organization_id, $create_organization_inventory_devices_swaps_bulk_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 207:
                    if ('\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 207:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createOrganizationInventoryDevicesSwapsBulkAsync
     *
     * Swap the devices identified by devices.old with a devices.new, then perform the :afterAction on the devices.old.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulkRequest $create_organization_inventory_devices_swaps_bulk_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationInventoryDevicesSwapsBulkAsync($organization_id, $create_organization_inventory_devices_swaps_bulk_request, string $contentType = self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'][0])
    {
        return $this->createOrganizationInventoryDevicesSwapsBulkAsyncWithHttpInfo($organization_id, $create_organization_inventory_devices_swaps_bulk_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createOrganizationInventoryDevicesSwapsBulkAsyncWithHttpInfo
     *
     * Swap the devices identified by devices.old with a devices.new, then perform the :afterAction on the devices.old.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulkRequest $create_organization_inventory_devices_swaps_bulk_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrganizationInventoryDevicesSwapsBulkAsyncWithHttpInfo($organization_id, $create_organization_inventory_devices_swaps_bulk_request, string $contentType = self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'][0])
    {
        $returnType = '\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response';
        $request = $this->createOrganizationInventoryDevicesSwapsBulkRequest($organization_id, $create_organization_inventory_devices_swaps_bulk_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createOrganizationInventoryDevicesSwapsBulk'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  \Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulkRequest $create_organization_inventory_devices_swaps_bulk_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createOrganizationInventoryDevicesSwapsBulkRequest($organization_id, $create_organization_inventory_devices_swaps_bulk_request, string $contentType = self::contentTypes['createOrganizationInventoryDevicesSwapsBulk'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createOrganizationInventoryDevicesSwapsBulk'
            );
        }

        // verify the required parameter 'create_organization_inventory_devices_swaps_bulk_request' is set
        if ($create_organization_inventory_devices_swaps_bulk_request === null || (is_array($create_organization_inventory_devices_swaps_bulk_request) && count($create_organization_inventory_devices_swaps_bulk_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_organization_inventory_devices_swaps_bulk_request when calling createOrganizationInventoryDevicesSwapsBulk'
            );
        }


        $resourcePath = '/organizations/{organizationId}/inventory/devices/swaps/bulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_organization_inventory_devices_swaps_bulk_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_organization_inventory_devices_swaps_bulk_request));
            } else {
                $httpBody = $create_organization_inventory_devices_swaps_bulk_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDevice
     *
     * Return a single device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDevice200Response
     */
    public function getDevice($serial, string $contentType = self::contentTypes['getDevice'][0])
    {
        list($response) = $this->getDeviceWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceWithHttpInfo
     *
     * Return a single device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceWithHttpInfo($serial, string $contentType = self::contentTypes['getDevice'][0])
    {
        $request = $this->getDeviceRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceAsync
     *
     * Return a single device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAsync($serial, string $contentType = self::contentTypes['getDevice'][0])
    {
        return $this->getDeviceAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceAsyncWithHttpInfo
     *
     * Return a single device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDevice'][0])
    {
        $returnType = '\Meraki\Model\GetDevice200Response';
        $request = $this->getDeviceRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDevice'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceRequest($serial, string $contentType = self::contentTypes['getDevice'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDevice'
            );
        }


        $resourcePath = '/devices/{serial}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceCellularSims
     *
     * Return the SIM and APN configurations for a cellular device.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceCellularSims200Response
     */
    public function getDeviceCellularSims($serial, string $contentType = self::contentTypes['getDeviceCellularSims'][0])
    {
        list($response) = $this->getDeviceCellularSimsWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceCellularSimsWithHttpInfo
     *
     * Return the SIM and APN configurations for a cellular device.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceCellularSims200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceCellularSimsWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceCellularSims'][0])
    {
        $request = $this->getDeviceCellularSimsRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceCellularSims200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceCellularSims200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceCellularSims200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceCellularSims200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceCellularSims200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceCellularSimsAsync
     *
     * Return the SIM and APN configurations for a cellular device.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCellularSimsAsync($serial, string $contentType = self::contentTypes['getDeviceCellularSims'][0])
    {
        return $this->getDeviceCellularSimsAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceCellularSimsAsyncWithHttpInfo
     *
     * Return the SIM and APN configurations for a cellular device.
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCellularSimsAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceCellularSims'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceCellularSims200Response';
        $request = $this->getDeviceCellularSimsRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceCellularSims'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceCellularSimsRequest($serial, string $contentType = self::contentTypes['getDeviceCellularSims'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceCellularSims'
            );
        }


        $resourcePath = '/devices/{serial}/cellular/sims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceClients
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceClients200ResponseInner[]
     */
    public function getDeviceClients($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {
        list($response) = $this->getDeviceClientsWithHttpInfo($serial, $t0, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceClientsWithHttpInfo
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceClients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceClientsWithHttpInfo($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {
        $request = $this->getDeviceClientsRequest($serial, $t0, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceClients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceClients200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceClients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceClients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceClients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceClientsAsync
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceClientsAsync($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {
        return $this->getDeviceClientsAsyncWithHttpInfo($serial, $t0, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceClientsAsyncWithHttpInfo
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceClientsAsyncWithHttpInfo($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceClients200ResponseInner[]';
        $request = $this->getDeviceClientsRequest($serial, $t0, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceClients'
     *
     * @param  string $serial Serial (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceClients'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceClientsRequest($serial, $t0 = null, $timespan = null, string $contentType = self::contentTypes['getDeviceClients'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceClients'
            );
        }


        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getDeviceClients, must be smaller than or equal to 2678400.');
        }
        

        $resourcePath = '/devices/{serial}/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLiveToolsArpTable
     *
     * Return an ARP table live tool job.
     *
     * @param  string $serial Serial (required)
     * @param  string $arp_table_id Arp table ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\DevicesSerialLiveToolsArpTablePostRequestMessage
     */
    public function getDeviceLiveToolsArpTable($serial, $arp_table_id, string $contentType = self::contentTypes['getDeviceLiveToolsArpTable'][0])
    {
        list($response) = $this->getDeviceLiveToolsArpTableWithHttpInfo($serial, $arp_table_id, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLiveToolsArpTableWithHttpInfo
     *
     * Return an ARP table live tool job.
     *
     * @param  string $serial Serial (required)
     * @param  string $arp_table_id Arp table ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\DevicesSerialLiveToolsArpTablePostRequestMessage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLiveToolsArpTableWithHttpInfo($serial, $arp_table_id, string $contentType = self::contentTypes['getDeviceLiveToolsArpTable'][0])
    {
        $request = $this->getDeviceLiveToolsArpTableRequest($serial, $arp_table_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\DevicesSerialLiveToolsArpTablePostRequestMessage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\DevicesSerialLiveToolsArpTablePostRequestMessage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\DevicesSerialLiveToolsArpTablePostRequestMessage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\DevicesSerialLiveToolsArpTablePostRequestMessage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\DevicesSerialLiveToolsArpTablePostRequestMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLiveToolsArpTableAsync
     *
     * Return an ARP table live tool job.
     *
     * @param  string $serial Serial (required)
     * @param  string $arp_table_id Arp table ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsArpTableAsync($serial, $arp_table_id, string $contentType = self::contentTypes['getDeviceLiveToolsArpTable'][0])
    {
        return $this->getDeviceLiveToolsArpTableAsyncWithHttpInfo($serial, $arp_table_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLiveToolsArpTableAsyncWithHttpInfo
     *
     * Return an ARP table live tool job.
     *
     * @param  string $serial Serial (required)
     * @param  string $arp_table_id Arp table ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsArpTableAsyncWithHttpInfo($serial, $arp_table_id, string $contentType = self::contentTypes['getDeviceLiveToolsArpTable'][0])
    {
        $returnType = '\Meraki\Model\DevicesSerialLiveToolsArpTablePostRequestMessage';
        $request = $this->getDeviceLiveToolsArpTableRequest($serial, $arp_table_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLiveToolsArpTable'
     *
     * @param  string $serial Serial (required)
     * @param  string $arp_table_id Arp table ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsArpTable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLiveToolsArpTableRequest($serial, $arp_table_id, string $contentType = self::contentTypes['getDeviceLiveToolsArpTable'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLiveToolsArpTable'
            );
        }

        // verify the required parameter 'arp_table_id' is set
        if ($arp_table_id === null || (is_array($arp_table_id) && count($arp_table_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $arp_table_id when calling getDeviceLiveToolsArpTable'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/arpTable/{arpTableId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }
        // path params
        if ($arp_table_id !== null) {
            $resourcePath = str_replace(
                '{' . 'arpTableId' . '}',
                ObjectSerializer::toPathValue($arp_table_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLiveToolsCableTest
     *
     * Return a cable test live tool job.
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\DevicesSerialLiveToolsCableTestPostRequestMessage
     */
    public function getDeviceLiveToolsCableTest($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsCableTest'][0])
    {
        list($response) = $this->getDeviceLiveToolsCableTestWithHttpInfo($serial, $id, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLiveToolsCableTestWithHttpInfo
     *
     * Return a cable test live tool job.
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\DevicesSerialLiveToolsCableTestPostRequestMessage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLiveToolsCableTestWithHttpInfo($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsCableTest'][0])
    {
        $request = $this->getDeviceLiveToolsCableTestRequest($serial, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\DevicesSerialLiveToolsCableTestPostRequestMessage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\DevicesSerialLiveToolsCableTestPostRequestMessage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\DevicesSerialLiveToolsCableTestPostRequestMessage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\DevicesSerialLiveToolsCableTestPostRequestMessage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\DevicesSerialLiveToolsCableTestPostRequestMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLiveToolsCableTestAsync
     *
     * Return a cable test live tool job.
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsCableTestAsync($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsCableTest'][0])
    {
        return $this->getDeviceLiveToolsCableTestAsyncWithHttpInfo($serial, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLiveToolsCableTestAsyncWithHttpInfo
     *
     * Return a cable test live tool job.
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsCableTestAsyncWithHttpInfo($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsCableTest'][0])
    {
        $returnType = '\Meraki\Model\DevicesSerialLiveToolsCableTestPostRequestMessage';
        $request = $this->getDeviceLiveToolsCableTestRequest($serial, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLiveToolsCableTest'
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsCableTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLiveToolsCableTestRequest($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsCableTest'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLiveToolsCableTest'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeviceLiveToolsCableTest'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/cableTest/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLiveToolsLedsBlink
     *
     * Return a blink LEDs job
     *
     * @param  string $serial Serial (required)
     * @param  string $leds_blink_id Leds blink ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\DevicesSerialLiveToolsLedsBlinkPostRequestMessage
     */
    public function getDeviceLiveToolsLedsBlink($serial, $leds_blink_id, string $contentType = self::contentTypes['getDeviceLiveToolsLedsBlink'][0])
    {
        list($response) = $this->getDeviceLiveToolsLedsBlinkWithHttpInfo($serial, $leds_blink_id, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLiveToolsLedsBlinkWithHttpInfo
     *
     * Return a blink LEDs job
     *
     * @param  string $serial Serial (required)
     * @param  string $leds_blink_id Leds blink ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\DevicesSerialLiveToolsLedsBlinkPostRequestMessage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLiveToolsLedsBlinkWithHttpInfo($serial, $leds_blink_id, string $contentType = self::contentTypes['getDeviceLiveToolsLedsBlink'][0])
    {
        $request = $this->getDeviceLiveToolsLedsBlinkRequest($serial, $leds_blink_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\DevicesSerialLiveToolsLedsBlinkPostRequestMessage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\DevicesSerialLiveToolsLedsBlinkPostRequestMessage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\DevicesSerialLiveToolsLedsBlinkPostRequestMessage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\DevicesSerialLiveToolsLedsBlinkPostRequestMessage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\DevicesSerialLiveToolsLedsBlinkPostRequestMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLiveToolsLedsBlinkAsync
     *
     * Return a blink LEDs job
     *
     * @param  string $serial Serial (required)
     * @param  string $leds_blink_id Leds blink ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsLedsBlinkAsync($serial, $leds_blink_id, string $contentType = self::contentTypes['getDeviceLiveToolsLedsBlink'][0])
    {
        return $this->getDeviceLiveToolsLedsBlinkAsyncWithHttpInfo($serial, $leds_blink_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLiveToolsLedsBlinkAsyncWithHttpInfo
     *
     * Return a blink LEDs job
     *
     * @param  string $serial Serial (required)
     * @param  string $leds_blink_id Leds blink ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsLedsBlinkAsyncWithHttpInfo($serial, $leds_blink_id, string $contentType = self::contentTypes['getDeviceLiveToolsLedsBlink'][0])
    {
        $returnType = '\Meraki\Model\DevicesSerialLiveToolsLedsBlinkPostRequestMessage';
        $request = $this->getDeviceLiveToolsLedsBlinkRequest($serial, $leds_blink_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLiveToolsLedsBlink'
     *
     * @param  string $serial Serial (required)
     * @param  string $leds_blink_id Leds blink ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsLedsBlink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLiveToolsLedsBlinkRequest($serial, $leds_blink_id, string $contentType = self::contentTypes['getDeviceLiveToolsLedsBlink'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLiveToolsLedsBlink'
            );
        }

        // verify the required parameter 'leds_blink_id' is set
        if ($leds_blink_id === null || (is_array($leds_blink_id) && count($leds_blink_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $leds_blink_id when calling getDeviceLiveToolsLedsBlink'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/leds/blink/{ledsBlinkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }
        // path params
        if ($leds_blink_id !== null) {
            $resourcePath = str_replace(
                '{' . 'ledsBlinkId' . '}',
                ObjectSerializer::toPathValue($leds_blink_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLiveToolsPing
     *
     * Return a ping job
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\DevicesSerialLiveToolsPingPostRequestMessage
     */
    public function getDeviceLiveToolsPing($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPing'][0])
    {
        list($response) = $this->getDeviceLiveToolsPingWithHttpInfo($serial, $id, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLiveToolsPingWithHttpInfo
     *
     * Return a ping job
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\DevicesSerialLiveToolsPingPostRequestMessage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLiveToolsPingWithHttpInfo($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPing'][0])
    {
        $request = $this->getDeviceLiveToolsPingRequest($serial, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\DevicesSerialLiveToolsPingPostRequestMessage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\DevicesSerialLiveToolsPingPostRequestMessage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\DevicesSerialLiveToolsPingPostRequestMessage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\DevicesSerialLiveToolsPingPostRequestMessage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\DevicesSerialLiveToolsPingPostRequestMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLiveToolsPingAsync
     *
     * Return a ping job
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsPingAsync($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPing'][0])
    {
        return $this->getDeviceLiveToolsPingAsyncWithHttpInfo($serial, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLiveToolsPingAsyncWithHttpInfo
     *
     * Return a ping job
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsPingAsyncWithHttpInfo($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPing'][0])
    {
        $returnType = '\Meraki\Model\DevicesSerialLiveToolsPingPostRequestMessage';
        $request = $this->getDeviceLiveToolsPingRequest($serial, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLiveToolsPing'
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLiveToolsPingRequest($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPing'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLiveToolsPing'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeviceLiveToolsPing'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/ping/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLiveToolsPingDevice
     *
     * Return a ping device job
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceLiveToolsPingDevice200Response
     */
    public function getDeviceLiveToolsPingDevice($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPingDevice'][0])
    {
        list($response) = $this->getDeviceLiveToolsPingDeviceWithHttpInfo($serial, $id, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLiveToolsPingDeviceWithHttpInfo
     *
     * Return a ping device job
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceLiveToolsPingDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLiveToolsPingDeviceWithHttpInfo($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPingDevice'][0])
    {
        $request = $this->getDeviceLiveToolsPingDeviceRequest($serial, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceLiveToolsPingDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceLiveToolsPingDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceLiveToolsPingDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceLiveToolsPingDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceLiveToolsPingDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLiveToolsPingDeviceAsync
     *
     * Return a ping device job
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsPingDeviceAsync($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPingDevice'][0])
    {
        return $this->getDeviceLiveToolsPingDeviceAsyncWithHttpInfo($serial, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLiveToolsPingDeviceAsyncWithHttpInfo
     *
     * Return a ping device job
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsPingDeviceAsyncWithHttpInfo($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPingDevice'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceLiveToolsPingDevice200Response';
        $request = $this->getDeviceLiveToolsPingDeviceRequest($serial, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLiveToolsPingDevice'
     *
     * @param  string $serial Serial (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsPingDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLiveToolsPingDeviceRequest($serial, $id, string $contentType = self::contentTypes['getDeviceLiveToolsPingDevice'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLiveToolsPingDevice'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeviceLiveToolsPingDevice'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/pingDevice/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLiveToolsThroughputTest
     *
     * Return a throughput test job
     *
     * @param  string $serial Serial (required)
     * @param  string $throughput_test_id Throughput test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\DevicesSerialLiveToolsThroughputTestPostRequestMessage
     */
    public function getDeviceLiveToolsThroughputTest($serial, $throughput_test_id, string $contentType = self::contentTypes['getDeviceLiveToolsThroughputTest'][0])
    {
        list($response) = $this->getDeviceLiveToolsThroughputTestWithHttpInfo($serial, $throughput_test_id, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLiveToolsThroughputTestWithHttpInfo
     *
     * Return a throughput test job
     *
     * @param  string $serial Serial (required)
     * @param  string $throughput_test_id Throughput test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\DevicesSerialLiveToolsThroughputTestPostRequestMessage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLiveToolsThroughputTestWithHttpInfo($serial, $throughput_test_id, string $contentType = self::contentTypes['getDeviceLiveToolsThroughputTest'][0])
    {
        $request = $this->getDeviceLiveToolsThroughputTestRequest($serial, $throughput_test_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\DevicesSerialLiveToolsThroughputTestPostRequestMessage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\DevicesSerialLiveToolsThroughputTestPostRequestMessage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\DevicesSerialLiveToolsThroughputTestPostRequestMessage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\DevicesSerialLiveToolsThroughputTestPostRequestMessage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\DevicesSerialLiveToolsThroughputTestPostRequestMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLiveToolsThroughputTestAsync
     *
     * Return a throughput test job
     *
     * @param  string $serial Serial (required)
     * @param  string $throughput_test_id Throughput test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsThroughputTestAsync($serial, $throughput_test_id, string $contentType = self::contentTypes['getDeviceLiveToolsThroughputTest'][0])
    {
        return $this->getDeviceLiveToolsThroughputTestAsyncWithHttpInfo($serial, $throughput_test_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLiveToolsThroughputTestAsyncWithHttpInfo
     *
     * Return a throughput test job
     *
     * @param  string $serial Serial (required)
     * @param  string $throughput_test_id Throughput test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsThroughputTestAsyncWithHttpInfo($serial, $throughput_test_id, string $contentType = self::contentTypes['getDeviceLiveToolsThroughputTest'][0])
    {
        $returnType = '\Meraki\Model\DevicesSerialLiveToolsThroughputTestPostRequestMessage';
        $request = $this->getDeviceLiveToolsThroughputTestRequest($serial, $throughput_test_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLiveToolsThroughputTest'
     *
     * @param  string $serial Serial (required)
     * @param  string $throughput_test_id Throughput test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsThroughputTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLiveToolsThroughputTestRequest($serial, $throughput_test_id, string $contentType = self::contentTypes['getDeviceLiveToolsThroughputTest'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLiveToolsThroughputTest'
            );
        }

        // verify the required parameter 'throughput_test_id' is set
        if ($throughput_test_id === null || (is_array($throughput_test_id) && count($throughput_test_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $throughput_test_id when calling getDeviceLiveToolsThroughputTest'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/throughputTest/{throughputTestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }
        // path params
        if ($throughput_test_id !== null) {
            $resourcePath = str_replace(
                '{' . 'throughputTestId' . '}',
                ObjectSerializer::toPathValue($throughput_test_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLiveToolsWakeOnLan
     *
     * Return a Wake-on-LAN job
     *
     * @param  string $serial Serial (required)
     * @param  string $wake_on_lan_id Wake on lan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\DevicesSerialLiveToolsWakeOnLanPostRequestMessage
     */
    public function getDeviceLiveToolsWakeOnLan($serial, $wake_on_lan_id, string $contentType = self::contentTypes['getDeviceLiveToolsWakeOnLan'][0])
    {
        list($response) = $this->getDeviceLiveToolsWakeOnLanWithHttpInfo($serial, $wake_on_lan_id, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLiveToolsWakeOnLanWithHttpInfo
     *
     * Return a Wake-on-LAN job
     *
     * @param  string $serial Serial (required)
     * @param  string $wake_on_lan_id Wake on lan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\DevicesSerialLiveToolsWakeOnLanPostRequestMessage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLiveToolsWakeOnLanWithHttpInfo($serial, $wake_on_lan_id, string $contentType = self::contentTypes['getDeviceLiveToolsWakeOnLan'][0])
    {
        $request = $this->getDeviceLiveToolsWakeOnLanRequest($serial, $wake_on_lan_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\DevicesSerialLiveToolsWakeOnLanPostRequestMessage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\DevicesSerialLiveToolsWakeOnLanPostRequestMessage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\DevicesSerialLiveToolsWakeOnLanPostRequestMessage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\DevicesSerialLiveToolsWakeOnLanPostRequestMessage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\DevicesSerialLiveToolsWakeOnLanPostRequestMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLiveToolsWakeOnLanAsync
     *
     * Return a Wake-on-LAN job
     *
     * @param  string $serial Serial (required)
     * @param  string $wake_on_lan_id Wake on lan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsWakeOnLanAsync($serial, $wake_on_lan_id, string $contentType = self::contentTypes['getDeviceLiveToolsWakeOnLan'][0])
    {
        return $this->getDeviceLiveToolsWakeOnLanAsyncWithHttpInfo($serial, $wake_on_lan_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLiveToolsWakeOnLanAsyncWithHttpInfo
     *
     * Return a Wake-on-LAN job
     *
     * @param  string $serial Serial (required)
     * @param  string $wake_on_lan_id Wake on lan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLiveToolsWakeOnLanAsyncWithHttpInfo($serial, $wake_on_lan_id, string $contentType = self::contentTypes['getDeviceLiveToolsWakeOnLan'][0])
    {
        $returnType = '\Meraki\Model\DevicesSerialLiveToolsWakeOnLanPostRequestMessage';
        $request = $this->getDeviceLiveToolsWakeOnLanRequest($serial, $wake_on_lan_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLiveToolsWakeOnLan'
     *
     * @param  string $serial Serial (required)
     * @param  string $wake_on_lan_id Wake on lan ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLiveToolsWakeOnLan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLiveToolsWakeOnLanRequest($serial, $wake_on_lan_id, string $contentType = self::contentTypes['getDeviceLiveToolsWakeOnLan'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLiveToolsWakeOnLan'
            );
        }

        // verify the required parameter 'wake_on_lan_id' is set
        if ($wake_on_lan_id === null || (is_array($wake_on_lan_id) && count($wake_on_lan_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wake_on_lan_id when calling getDeviceLiveToolsWakeOnLan'
            );
        }


        $resourcePath = '/devices/{serial}/liveTools/wakeOnLan/{wakeOnLanId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }
        // path params
        if ($wake_on_lan_id !== null) {
            $resourcePath = str_replace(
                '{' . 'wakeOnLanId' . '}',
                ObjectSerializer::toPathValue($wake_on_lan_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLldpCdp
     *
     * List LLDP and CDP information for a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLldpCdp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceLldpCdp200Response
     */
    public function getDeviceLldpCdp($serial, string $contentType = self::contentTypes['getDeviceLldpCdp'][0])
    {
        list($response) = $this->getDeviceLldpCdpWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLldpCdpWithHttpInfo
     *
     * List LLDP and CDP information for a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLldpCdp'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceLldpCdp200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLldpCdpWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceLldpCdp'][0])
    {
        $request = $this->getDeviceLldpCdpRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceLldpCdp200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceLldpCdp200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceLldpCdp200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceLldpCdp200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceLldpCdp200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLldpCdpAsync
     *
     * List LLDP and CDP information for a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLldpCdp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLldpCdpAsync($serial, string $contentType = self::contentTypes['getDeviceLldpCdp'][0])
    {
        return $this->getDeviceLldpCdpAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLldpCdpAsyncWithHttpInfo
     *
     * List LLDP and CDP information for a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLldpCdp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLldpCdpAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceLldpCdp'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceLldpCdp200Response';
        $request = $this->getDeviceLldpCdpRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLldpCdp'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLldpCdp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLldpCdpRequest($serial, string $contentType = self::contentTypes['getDeviceLldpCdp'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLldpCdp'
            );
        }


        $resourcePath = '/devices/{serial}/lldpCdp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLossAndLatencyHistory
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for MX, MG and Z devices.
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]
     */
    public function getDeviceLossAndLatencyHistory($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {
        list($response) = $this->getDeviceLossAndLatencyHistoryWithHttpInfo($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceLossAndLatencyHistoryWithHttpInfo
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for MX, MG and Z devices.
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLossAndLatencyHistoryWithHttpInfo($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {
        $request = $this->getDeviceLossAndLatencyHistoryRequest($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLossAndLatencyHistoryAsync
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for MX, MG and Z devices.
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLossAndLatencyHistoryAsync($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {
        return $this->getDeviceLossAndLatencyHistoryAsyncWithHttpInfo($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLossAndLatencyHistoryAsyncWithHttpInfo
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for MX, MG and Z devices.
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLossAndLatencyHistoryAsyncWithHttpInfo($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceLossAndLatencyHistory200ResponseInner[]';
        $request = $this->getDeviceLossAndLatencyHistoryRequest($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLossAndLatencyHistory'
     *
     * @param  string $serial Serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string|null $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, wan3, cellular. The default is wan1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceLossAndLatencyHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceLossAndLatencyHistoryRequest($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null, string $contentType = self::contentTypes['getDeviceLossAndLatencyHistory'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLossAndLatencyHistory'
            );
        }

        // verify the required parameter 'ip' is set
        if ($ip === null || (is_array($ip) && count($ip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip when calling getDeviceLossAndLatencyHistory'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getDeviceLossAndLatencyHistory, must be smaller than or equal to 2678400.');
        }
        



        $resourcePath = '/devices/{serial}/lossAndLatencyHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uplink,
            'uplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip,
            'ip', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceManagementInterface
     *
     * Return the management interface settings for a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceManagementInterface200Response
     */
    public function getDeviceManagementInterface($serial, string $contentType = self::contentTypes['getDeviceManagementInterface'][0])
    {
        list($response) = $this->getDeviceManagementInterfaceWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation getDeviceManagementInterfaceWithHttpInfo
     *
     * Return the management interface settings for a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceManagementInterface200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceManagementInterfaceWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceManagementInterface'][0])
    {
        $request = $this->getDeviceManagementInterfaceRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceManagementInterface200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceManagementInterface200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceManagementInterface200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceManagementInterface200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceManagementInterface200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceManagementInterfaceAsync
     *
     * Return the management interface settings for a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceManagementInterfaceAsync($serial, string $contentType = self::contentTypes['getDeviceManagementInterface'][0])
    {
        return $this->getDeviceManagementInterfaceAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceManagementInterfaceAsyncWithHttpInfo
     *
     * Return the management interface settings for a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceManagementInterfaceAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['getDeviceManagementInterface'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceManagementInterface200Response';
        $request = $this->getDeviceManagementInterfaceRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceManagementInterface'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeviceManagementInterfaceRequest($serial, string $contentType = self::contentTypes['getDeviceManagementInterface'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceManagementInterface'
            );
        }


        $resourcePath = '/devices/{serial}/managementInterface';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkDevices
     *
     * List the devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDevice200Response[]
     * @deprecated
     */
    public function getNetworkDevices($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {
        list($response) = $this->getNetworkDevicesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkDevicesWithHttpInfo
     *
     * List the devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDevice200Response[], HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getNetworkDevicesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {
        $request = $this->getNetworkDevicesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDevice200Response[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDevice200Response[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDevice200Response[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDevice200Response[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDevice200Response[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkDevicesAsync
     *
     * List the devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getNetworkDevicesAsync($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {
        return $this->getNetworkDevicesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkDevicesAsyncWithHttpInfo
     *
     * List the devices in a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getNetworkDevicesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {
        $returnType = '\Meraki\Model\GetDevice200Response[]';
        $request = $this->getNetworkDevicesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getNetworkDevicesRequest($network_id, string $contentType = self::contentTypes['getNetworkDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkDevices'
            );
        }


        $resourcePath = '/networks/{networkId}/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceCellularUsageHistory
     *
     * Return the client&#39;s daily cellular data usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCellularUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceCellularUsageHistory200ResponseInner[]
     */
    public function getNetworkSmDeviceCellularUsageHistory($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCellularUsageHistory'][0])
    {
        list($response) = $this->getNetworkSmDeviceCellularUsageHistoryWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceCellularUsageHistoryWithHttpInfo
     *
     * Return the client&#39;s daily cellular data usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCellularUsageHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceCellularUsageHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceCellularUsageHistoryWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCellularUsageHistory'][0])
    {
        $request = $this->getNetworkSmDeviceCellularUsageHistoryRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceCellularUsageHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceCellularUsageHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceCellularUsageHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceCellularUsageHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceCellularUsageHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceCellularUsageHistoryAsync
     *
     * Return the client&#39;s daily cellular data usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCellularUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceCellularUsageHistoryAsync($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCellularUsageHistory'][0])
    {
        return $this->getNetworkSmDeviceCellularUsageHistoryAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceCellularUsageHistoryAsyncWithHttpInfo
     *
     * Return the client&#39;s daily cellular data usage history
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCellularUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceCellularUsageHistoryAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCellularUsageHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceCellularUsageHistory200ResponseInner[]';
        $request = $this->getNetworkSmDeviceCellularUsageHistoryRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceCellularUsageHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCellularUsageHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceCellularUsageHistoryRequest($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCellularUsageHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceCellularUsageHistory'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceCellularUsageHistory'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/cellularUsageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceCerts
     *
     * List the certs on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceCerts200ResponseInner[]
     */
    public function getNetworkSmDeviceCerts($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCerts'][0])
    {
        list($response) = $this->getNetworkSmDeviceCertsWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceCertsWithHttpInfo
     *
     * List the certs on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCerts'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceCerts200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceCertsWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCerts'][0])
    {
        $request = $this->getNetworkSmDeviceCertsRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceCerts200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceCerts200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceCerts200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceCerts200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceCerts200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceCertsAsync
     *
     * List the certs on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceCertsAsync($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCerts'][0])
    {
        return $this->getNetworkSmDeviceCertsAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceCertsAsyncWithHttpInfo
     *
     * List the certs on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceCertsAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCerts'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceCerts200ResponseInner[]';
        $request = $this->getNetworkSmDeviceCertsRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceCerts'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceCerts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceCertsRequest($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceCerts'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceCerts'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceCerts'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/certs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceConnectivity
     *
     * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceConnectivity'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceConnectivity200ResponseInner[]
     */
    public function getNetworkSmDeviceConnectivity($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceConnectivity'][0])
    {
        list($response) = $this->getNetworkSmDeviceConnectivityWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceConnectivityWithHttpInfo
     *
     * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceConnectivity'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceConnectivity200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceConnectivityWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceConnectivity'][0])
    {
        $request = $this->getNetworkSmDeviceConnectivityRequest($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceConnectivity200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceConnectivity200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceConnectivity200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceConnectivity200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceConnectivity200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceConnectivityAsync
     *
     * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceConnectivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceConnectivityAsync($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceConnectivity'][0])
    {
        return $this->getNetworkSmDeviceConnectivityAsyncWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceConnectivityAsyncWithHttpInfo
     *
     * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceConnectivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceConnectivityAsyncWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceConnectivity'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceConnectivity200ResponseInner[]';
        $request = $this->getNetworkSmDeviceConnectivityRequest($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceConnectivity'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceConnectivity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceConnectivityRequest($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceConnectivity'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceConnectivity'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceConnectivity'
            );
        }





        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/connectivity';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceDesktopLogs
     *
     * Return historical records of various Systems Manager network connection details for desktop devices.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDesktopLogs'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceDesktopLogs200ResponseInner[]
     */
    public function getNetworkSmDeviceDesktopLogs($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDesktopLogs'][0])
    {
        list($response) = $this->getNetworkSmDeviceDesktopLogsWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceDesktopLogsWithHttpInfo
     *
     * Return historical records of various Systems Manager network connection details for desktop devices.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDesktopLogs'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceDesktopLogs200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceDesktopLogsWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDesktopLogs'][0])
    {
        $request = $this->getNetworkSmDeviceDesktopLogsRequest($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceDesktopLogs200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceDesktopLogs200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceDesktopLogs200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceDesktopLogs200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceDesktopLogs200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceDesktopLogsAsync
     *
     * Return historical records of various Systems Manager network connection details for desktop devices.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDesktopLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDesktopLogsAsync($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDesktopLogs'][0])
    {
        return $this->getNetworkSmDeviceDesktopLogsAsyncWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceDesktopLogsAsyncWithHttpInfo
     *
     * Return historical records of various Systems Manager network connection details for desktop devices.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDesktopLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDesktopLogsAsyncWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDesktopLogs'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceDesktopLogs200ResponseInner[]';
        $request = $this->getNetworkSmDeviceDesktopLogsRequest($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceDesktopLogs'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDesktopLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceDesktopLogsRequest($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDesktopLogs'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceDesktopLogs'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceDesktopLogs'
            );
        }





        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/desktopLogs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceDeviceCommandLogs
     *
     * Return historical records of commands sent to Systems Manager devices
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceDeviceCommandLogs200ResponseInner[]
     */
    public function getNetworkSmDeviceDeviceCommandLogs($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'][0])
    {
        list($response) = $this->getNetworkSmDeviceDeviceCommandLogsWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceDeviceCommandLogsWithHttpInfo
     *
     * Return historical records of commands sent to Systems Manager devices
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceDeviceCommandLogs200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceDeviceCommandLogsWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'][0])
    {
        $request = $this->getNetworkSmDeviceDeviceCommandLogsRequest($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceDeviceCommandLogs200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceDeviceCommandLogs200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceDeviceCommandLogs200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceDeviceCommandLogs200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceDeviceCommandLogs200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceDeviceCommandLogsAsync
     *
     * Return historical records of commands sent to Systems Manager devices
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDeviceCommandLogsAsync($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'][0])
    {
        return $this->getNetworkSmDeviceDeviceCommandLogsAsyncWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceDeviceCommandLogsAsyncWithHttpInfo
     *
     * Return historical records of commands sent to Systems Manager devices
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDeviceCommandLogsAsyncWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceDeviceCommandLogs200ResponseInner[]';
        $request = $this->getNetworkSmDeviceDeviceCommandLogsRequest($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceDeviceCommandLogs'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceDeviceCommandLogsRequest($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceCommandLogs'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceDeviceCommandLogs'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceDeviceCommandLogs'
            );
        }





        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/deviceCommandLogs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceDeviceProfiles
     *
     * Get the installed profiles associated with a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceDeviceProfiles200ResponseInner[]
     */
    public function getNetworkSmDeviceDeviceProfiles($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceProfiles'][0])
    {
        list($response) = $this->getNetworkSmDeviceDeviceProfilesWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceDeviceProfilesWithHttpInfo
     *
     * Get the installed profiles associated with a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceProfiles'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceDeviceProfiles200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceDeviceProfilesWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceProfiles'][0])
    {
        $request = $this->getNetworkSmDeviceDeviceProfilesRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceDeviceProfiles200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceDeviceProfiles200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceDeviceProfiles200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceDeviceProfiles200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceDeviceProfiles200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceDeviceProfilesAsync
     *
     * Get the installed profiles associated with a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDeviceProfilesAsync($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceProfiles'][0])
    {
        return $this->getNetworkSmDeviceDeviceProfilesAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceDeviceProfilesAsyncWithHttpInfo
     *
     * Get the installed profiles associated with a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDeviceProfilesAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceProfiles'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceDeviceProfiles200ResponseInner[]';
        $request = $this->getNetworkSmDeviceDeviceProfilesRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceDeviceProfiles'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceDeviceProfiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceDeviceProfilesRequest($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceDeviceProfiles'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceDeviceProfiles'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceDeviceProfiles'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/deviceProfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceNetworkAdapters
     *
     * List the network adapters of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceNetworkAdapters'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceNetworkAdapters200ResponseInner[]
     */
    public function getNetworkSmDeviceNetworkAdapters($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceNetworkAdapters'][0])
    {
        list($response) = $this->getNetworkSmDeviceNetworkAdaptersWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceNetworkAdaptersWithHttpInfo
     *
     * List the network adapters of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceNetworkAdapters'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceNetworkAdapters200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceNetworkAdaptersWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceNetworkAdapters'][0])
    {
        $request = $this->getNetworkSmDeviceNetworkAdaptersRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceNetworkAdapters200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceNetworkAdapters200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceNetworkAdapters200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceNetworkAdapters200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceNetworkAdapters200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceNetworkAdaptersAsync
     *
     * List the network adapters of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceNetworkAdapters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceNetworkAdaptersAsync($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceNetworkAdapters'][0])
    {
        return $this->getNetworkSmDeviceNetworkAdaptersAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceNetworkAdaptersAsyncWithHttpInfo
     *
     * List the network adapters of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceNetworkAdapters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceNetworkAdaptersAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceNetworkAdapters'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceNetworkAdapters200ResponseInner[]';
        $request = $this->getNetworkSmDeviceNetworkAdaptersRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceNetworkAdapters'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceNetworkAdapters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceNetworkAdaptersRequest($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceNetworkAdapters'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceNetworkAdapters'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceNetworkAdapters'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/networkAdapters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDevicePerformanceHistory
     *
     * Return historical records of various Systems Manager client metrics for desktop devices.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevicePerformanceHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDevicePerformanceHistory200ResponseInner[]
     */
    public function getNetworkSmDevicePerformanceHistory($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevicePerformanceHistory'][0])
    {
        list($response) = $this->getNetworkSmDevicePerformanceHistoryWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDevicePerformanceHistoryWithHttpInfo
     *
     * Return historical records of various Systems Manager client metrics for desktop devices.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevicePerformanceHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDevicePerformanceHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDevicePerformanceHistoryWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevicePerformanceHistory'][0])
    {
        $request = $this->getNetworkSmDevicePerformanceHistoryRequest($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDevicePerformanceHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDevicePerformanceHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDevicePerformanceHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDevicePerformanceHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDevicePerformanceHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDevicePerformanceHistoryAsync
     *
     * Return historical records of various Systems Manager client metrics for desktop devices.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevicePerformanceHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDevicePerformanceHistoryAsync($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevicePerformanceHistory'][0])
    {
        return $this->getNetworkSmDevicePerformanceHistoryAsyncWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDevicePerformanceHistoryAsyncWithHttpInfo
     *
     * Return historical records of various Systems Manager client metrics for desktop devices.
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevicePerformanceHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDevicePerformanceHistoryAsyncWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevicePerformanceHistory'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDevicePerformanceHistory200ResponseInner[]';
        $request = $this->getNetworkSmDevicePerformanceHistoryRequest($network_id, $device_id, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDevicePerformanceHistory'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevicePerformanceHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDevicePerformanceHistoryRequest($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevicePerformanceHistory'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDevicePerformanceHistory'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDevicePerformanceHistory'
            );
        }





        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/performanceHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceRestrictions
     *
     * List the restrictions on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceRestrictions'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceRestrictions200Response
     */
    public function getNetworkSmDeviceRestrictions($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceRestrictions'][0])
    {
        list($response) = $this->getNetworkSmDeviceRestrictionsWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceRestrictionsWithHttpInfo
     *
     * List the restrictions on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceRestrictions'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceRestrictions200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceRestrictionsWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceRestrictions'][0])
    {
        $request = $this->getNetworkSmDeviceRestrictionsRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceRestrictions200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceRestrictions200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceRestrictions200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceRestrictions200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceRestrictions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceRestrictionsAsync
     *
     * List the restrictions on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceRestrictions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceRestrictionsAsync($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceRestrictions'][0])
    {
        return $this->getNetworkSmDeviceRestrictionsAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceRestrictionsAsyncWithHttpInfo
     *
     * List the restrictions on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceRestrictions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceRestrictionsAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceRestrictions'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceRestrictions200Response';
        $request = $this->getNetworkSmDeviceRestrictionsRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceRestrictions'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceRestrictions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceRestrictionsRequest($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceRestrictions'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceRestrictions'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceRestrictions'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/restrictions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceSecurityCenters
     *
     * List the security centers on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSecurityCenters'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceSecurityCenters200ResponseInner[]
     */
    public function getNetworkSmDeviceSecurityCenters($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSecurityCenters'][0])
    {
        list($response) = $this->getNetworkSmDeviceSecurityCentersWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceSecurityCentersWithHttpInfo
     *
     * List the security centers on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSecurityCenters'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceSecurityCenters200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceSecurityCentersWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSecurityCenters'][0])
    {
        $request = $this->getNetworkSmDeviceSecurityCentersRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceSecurityCenters200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceSecurityCenters200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceSecurityCenters200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceSecurityCenters200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceSecurityCenters200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceSecurityCentersAsync
     *
     * List the security centers on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSecurityCenters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceSecurityCentersAsync($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSecurityCenters'][0])
    {
        return $this->getNetworkSmDeviceSecurityCentersAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceSecurityCentersAsyncWithHttpInfo
     *
     * List the security centers on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSecurityCenters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceSecurityCentersAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSecurityCenters'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceSecurityCenters200ResponseInner[]';
        $request = $this->getNetworkSmDeviceSecurityCentersRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceSecurityCenters'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSecurityCenters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceSecurityCentersRequest($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSecurityCenters'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceSecurityCenters'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceSecurityCenters'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/securityCenters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceSoftwares
     *
     * Get a list of softwares associated with a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSoftwares'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceSoftwares200ResponseInner[]
     */
    public function getNetworkSmDeviceSoftwares($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSoftwares'][0])
    {
        list($response) = $this->getNetworkSmDeviceSoftwaresWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceSoftwaresWithHttpInfo
     *
     * Get a list of softwares associated with a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSoftwares'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceSoftwares200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceSoftwaresWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSoftwares'][0])
    {
        $request = $this->getNetworkSmDeviceSoftwaresRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceSoftwares200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceSoftwares200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceSoftwares200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceSoftwares200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceSoftwares200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceSoftwaresAsync
     *
     * Get a list of softwares associated with a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSoftwares'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceSoftwaresAsync($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSoftwares'][0])
    {
        return $this->getNetworkSmDeviceSoftwaresAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceSoftwaresAsyncWithHttpInfo
     *
     * Get a list of softwares associated with a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSoftwares'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceSoftwaresAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSoftwares'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceSoftwares200ResponseInner[]';
        $request = $this->getNetworkSmDeviceSoftwaresRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceSoftwares'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceSoftwares'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceSoftwaresRequest($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceSoftwares'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceSoftwares'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceSoftwares'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/softwares';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceWlanLists
     *
     * List the saved SSID names on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceWlanLists'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDeviceWlanLists200ResponseInner[]
     */
    public function getNetworkSmDeviceWlanLists($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceWlanLists'][0])
    {
        list($response) = $this->getNetworkSmDeviceWlanListsWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceWlanListsWithHttpInfo
     *
     * List the saved SSID names on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceWlanLists'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDeviceWlanLists200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceWlanListsWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceWlanLists'][0])
    {
        $request = $this->getNetworkSmDeviceWlanListsRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDeviceWlanLists200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDeviceWlanLists200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDeviceWlanLists200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDeviceWlanLists200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDeviceWlanLists200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceWlanListsAsync
     *
     * List the saved SSID names on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceWlanLists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceWlanListsAsync($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceWlanLists'][0])
    {
        return $this->getNetworkSmDeviceWlanListsAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceWlanListsAsyncWithHttpInfo
     *
     * List the saved SSID names on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceWlanLists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceWlanListsAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceWlanLists'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDeviceWlanLists200ResponseInner[]';
        $request = $this->getNetworkSmDeviceWlanListsRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceWlanLists'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDeviceWlanLists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDeviceWlanListsRequest($network_id, $device_id, string $contentType = self::contentTypes['getNetworkSmDeviceWlanLists'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceWlanLists'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceWlanLists'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/wlanLists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDevices
     *
     * List the devices enrolled in an SM network with various specified fields and filters
     *
     * @param  string $network_id Network ID (required)
     * @param  string[]|null $fields Additional fields that will be displayed for each device.     The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,     systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,     ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,     simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,     isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,     hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, androidSecurityPatchVersion, cellular, and url. (optional)
     * @param  string[]|null $wifi_macs Filter devices by wifi mac(s). (optional)
     * @param  string[]|null $serials Filter devices by serial(s). (optional)
     * @param  string[]|null $ids Filter devices by id(s). (optional)
     * @param  string[]|null $uuids Filter devices by uuid(s). (optional)
     * @param  string[]|null $system_types Filter devices by system type(s). (optional)
     * @param  string[]|null $scope Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkSmDevices200ResponseInner[]
     */
    public function getNetworkSmDevices($network_id, $fields = null, $wifi_macs = null, $serials = null, $ids = null, $uuids = null, $system_types = null, $scope = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevices'][0])
    {
        list($response) = $this->getNetworkSmDevicesWithHttpInfo($network_id, $fields, $wifi_macs, $serials, $ids, $uuids, $system_types, $scope, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkSmDevicesWithHttpInfo
     *
     * List the devices enrolled in an SM network with various specified fields and filters
     *
     * @param  string $network_id Network ID (required)
     * @param  string[]|null $fields Additional fields that will be displayed for each device.     The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,     systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,     ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,     simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,     isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,     hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, androidSecurityPatchVersion, cellular, and url. (optional)
     * @param  string[]|null $wifi_macs Filter devices by wifi mac(s). (optional)
     * @param  string[]|null $serials Filter devices by serial(s). (optional)
     * @param  string[]|null $ids Filter devices by id(s). (optional)
     * @param  string[]|null $uuids Filter devices by uuid(s). (optional)
     * @param  string[]|null $system_types Filter devices by system type(s). (optional)
     * @param  string[]|null $scope Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkSmDevices200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDevicesWithHttpInfo($network_id, $fields = null, $wifi_macs = null, $serials = null, $ids = null, $uuids = null, $system_types = null, $scope = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevices'][0])
    {
        $request = $this->getNetworkSmDevicesRequest($network_id, $fields, $wifi_macs, $serials, $ids, $uuids, $system_types, $scope, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkSmDevices200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkSmDevices200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkSmDevices200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkSmDevices200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkSmDevices200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDevicesAsync
     *
     * List the devices enrolled in an SM network with various specified fields and filters
     *
     * @param  string $network_id Network ID (required)
     * @param  string[]|null $fields Additional fields that will be displayed for each device.     The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,     systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,     ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,     simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,     isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,     hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, androidSecurityPatchVersion, cellular, and url. (optional)
     * @param  string[]|null $wifi_macs Filter devices by wifi mac(s). (optional)
     * @param  string[]|null $serials Filter devices by serial(s). (optional)
     * @param  string[]|null $ids Filter devices by id(s). (optional)
     * @param  string[]|null $uuids Filter devices by uuid(s). (optional)
     * @param  string[]|null $system_types Filter devices by system type(s). (optional)
     * @param  string[]|null $scope Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDevicesAsync($network_id, $fields = null, $wifi_macs = null, $serials = null, $ids = null, $uuids = null, $system_types = null, $scope = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevices'][0])
    {
        return $this->getNetworkSmDevicesAsyncWithHttpInfo($network_id, $fields, $wifi_macs, $serials, $ids, $uuids, $system_types, $scope, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDevicesAsyncWithHttpInfo
     *
     * List the devices enrolled in an SM network with various specified fields and filters
     *
     * @param  string $network_id Network ID (required)
     * @param  string[]|null $fields Additional fields that will be displayed for each device.     The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,     systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,     ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,     simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,     isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,     hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, androidSecurityPatchVersion, cellular, and url. (optional)
     * @param  string[]|null $wifi_macs Filter devices by wifi mac(s). (optional)
     * @param  string[]|null $serials Filter devices by serial(s). (optional)
     * @param  string[]|null $ids Filter devices by id(s). (optional)
     * @param  string[]|null $uuids Filter devices by uuid(s). (optional)
     * @param  string[]|null $system_types Filter devices by system type(s). (optional)
     * @param  string[]|null $scope Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDevicesAsyncWithHttpInfo($network_id, $fields = null, $wifi_macs = null, $serials = null, $ids = null, $uuids = null, $system_types = null, $scope = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevices'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkSmDevices200ResponseInner[]';
        $request = $this->getNetworkSmDevicesRequest($network_id, $fields, $wifi_macs, $serials, $ids, $uuids, $system_types, $scope, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  string[]|null $fields Additional fields that will be displayed for each device.     The default fields are: id, name, tags, ssid, wifiMac, osName, systemModel, uuid, and serialNumber. The additional fields are: ip,     systemType, availableDeviceCapacity, kioskAppName, biosVersion, lastConnected, missingAppsCount, userSuppliedAddress, location, lastUser,     ownerEmail, ownerUsername, osBuild, publicIp, phoneNumber, diskInfoJson, deviceCapacity, isManaged, hadMdm, isSupervised, meid, imei, iccid,     simCarrierNetwork, cellularDataUsed, isHotspotEnabled, createdAt, batteryEstCharge, quarantined, avName, avRunning, asName, fwName,     isRooted, loginRequired, screenLockEnabled, screenLockDelay, autoLoginDisabled, autoTags, hasMdm, hasDesktopAgent, diskEncryptionEnabled,     hardwareEncryptionCaps, passCodeLock, usesHardwareKeystore, androidSecurityPatchVersion, cellular, and url. (optional)
     * @param  string[]|null $wifi_macs Filter devices by wifi mac(s). (optional)
     * @param  string[]|null $serials Filter devices by serial(s). (optional)
     * @param  string[]|null $ids Filter devices by id(s). (optional)
     * @param  string[]|null $uuids Filter devices by uuid(s). (optional)
     * @param  string[]|null $system_types Filter devices by system type(s). (optional)
     * @param  string[]|null $scope Specify a scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkSmDevicesRequest($network_id, $fields = null, $wifi_macs = null, $serials = null, $ids = null, $uuids = null, $system_types = null, $scope = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getNetworkSmDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDevices'
            );
        }












        $resourcePath = '/networks/{networkId}/sm/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $wifi_macs,
            'wifiMacs', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuids,
            'uuids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $system_types,
            'systemTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStats
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesConnectionStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceWirelessConnectionStats200Response[]
     */
    public function getNetworkWirelessDevicesConnectionStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesConnectionStats'][0])
    {
        list($response) = $this->getNetworkWirelessDevicesConnectionStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesConnectionStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceWirelessConnectionStats200Response[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessDevicesConnectionStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesConnectionStats'][0])
    {
        $request = $this->getNetworkWirelessDevicesConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceWirelessConnectionStats200Response[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceWirelessConnectionStats200Response[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceWirelessConnectionStats200Response[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceWirelessConnectionStats200Response[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceWirelessConnectionStats200Response[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStatsAsync
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesConnectionStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesConnectionStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesConnectionStats'][0])
    {
        return $this->getNetworkWirelessDevicesConnectionStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesConnectionStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesConnectionStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesConnectionStats'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceWirelessConnectionStats200Response[]';
        $request = $this->getNetworkWirelessDevicesConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessDevicesConnectionStats'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesConnectionStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWirelessDevicesConnectionStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesConnectionStats'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessDevicesConnectionStats'
            );
        }



        if ($timespan !== null && $timespan > 604800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getNetworkWirelessDevicesConnectionStats, must be smaller than or equal to 604800.');
        }
        





        $resourcePath = '/networks/{networkId}/wireless/devices/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $band,
            'band', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid,
            'ssid', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan,
            'vlan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ap_tag,
            'apTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStats
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesLatencyStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function getNetworkWirelessDevicesLatencyStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesLatencyStats'][0])
    {
        list($response) = $this->getNetworkWirelessDevicesLatencyStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesLatencyStats'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessDevicesLatencyStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesLatencyStats'][0])
    {
        $request = $this->getNetworkWirelessDevicesLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStatsAsync
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesLatencyStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesLatencyStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesLatencyStats'][0])
    {
        return $this->getNetworkWirelessDevicesLatencyStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesLatencyStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesLatencyStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesLatencyStats'][0])
    {
        $returnType = 'object[]';
        $request = $this->getNetworkWirelessDevicesLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessDevicesLatencyStats'
     *
     * @param  string $network_id Network ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string|null $band Filter results by band (either &#39;2.4&#39;, &#39;5&#39; or &#39;6&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int|null $ssid Filter results by SSID (optional)
     * @param  int|null $vlan Filter results by VLAN (optional)
     * @param  string|null $ap_tag Filter results by AP Tag (optional)
     * @param  string|null $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWirelessDevicesLatencyStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWirelessDevicesLatencyStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null, string $contentType = self::contentTypes['getNetworkWirelessDevicesLatencyStats'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessDevicesLatencyStats'
            );
        }



        if ($timespan !== null && $timespan > 604800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getNetworkWirelessDevicesLatencyStats, must be smaller than or equal to 604800.');
        }
        






        $resourcePath = '/networks/{networkId}/wireless/devices/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $band,
            'band', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid,
            'ssid', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vlan,
            'vlan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ap_tag,
            'apTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevices
     *
     * List the devices in an organization that have been assigned to a network.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $configuration_updated_after Filter results by whether or not the device&#39;s configuration has been updated after the given timestamp (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $tags Optional parameter to filter devices by tags. (optional)
     * @param  string|null $tags_filter_type Optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string|null $name Optional parameter to filter devices by name. All returned devices will have a name that contains the search term or is an exact match. (optional)
     * @param  string|null $mac Optional parameter to filter devices by MAC address. All returned devices will have a MAC address that contains the search term or is an exact match. (optional)
     * @param  string|null $serial Optional parameter to filter devices by serial number. All returned devices will have a serial number that contains the search term or is an exact match. (optional)
     * @param  string|null $model Optional parameter to filter devices by model. All returned devices will have a model that contains the search term or is an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter devices by one or more MAC addresses. All returned devices will have a MAC address that is an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by one or more serial numbers. All returned devices will have a serial number that is an exact match. (optional)
     * @param  string[]|null $sensor_metrics Optional parameter to filter devices by the metrics that they provide. Only applies to sensor devices. (optional)
     * @param  string[]|null $sensor_alert_profile_ids Optional parameter to filter devices by the alert profiles that are bound to them. Only applies to sensor devices. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\VmxNetworkDevicesClaim200Response[]
     */
    public function getOrganizationDevices($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $network_ids = null, $product_types = null, $tags = null, $tags_filter_type = null, $name = null, $mac = null, $serial = null, $model = null, $macs = null, $serials = null, $sensor_metrics = null, $sensor_alert_profile_ids = null, $models = null, string $contentType = self::contentTypes['getOrganizationDevices'][0])
    {
        list($response) = $this->getOrganizationDevicesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $configuration_updated_after, $network_ids, $product_types, $tags, $tags_filter_type, $name, $mac, $serial, $model, $macs, $serials, $sensor_metrics, $sensor_alert_profile_ids, $models, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesWithHttpInfo
     *
     * List the devices in an organization that have been assigned to a network.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $configuration_updated_after Filter results by whether or not the device&#39;s configuration has been updated after the given timestamp (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $tags Optional parameter to filter devices by tags. (optional)
     * @param  string|null $tags_filter_type Optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string|null $name Optional parameter to filter devices by name. All returned devices will have a name that contains the search term or is an exact match. (optional)
     * @param  string|null $mac Optional parameter to filter devices by MAC address. All returned devices will have a MAC address that contains the search term or is an exact match. (optional)
     * @param  string|null $serial Optional parameter to filter devices by serial number. All returned devices will have a serial number that contains the search term or is an exact match. (optional)
     * @param  string|null $model Optional parameter to filter devices by model. All returned devices will have a model that contains the search term or is an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter devices by one or more MAC addresses. All returned devices will have a MAC address that is an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by one or more serial numbers. All returned devices will have a serial number that is an exact match. (optional)
     * @param  string[]|null $sensor_metrics Optional parameter to filter devices by the metrics that they provide. Only applies to sensor devices. (optional)
     * @param  string[]|null $sensor_alert_profile_ids Optional parameter to filter devices by the alert profiles that are bound to them. Only applies to sensor devices. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\VmxNetworkDevicesClaim200Response[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $network_ids = null, $product_types = null, $tags = null, $tags_filter_type = null, $name = null, $mac = null, $serial = null, $model = null, $macs = null, $serials = null, $sensor_metrics = null, $sensor_alert_profile_ids = null, $models = null, string $contentType = self::contentTypes['getOrganizationDevices'][0])
    {
        $request = $this->getOrganizationDevicesRequest($organization_id, $per_page, $starting_after, $ending_before, $configuration_updated_after, $network_ids, $product_types, $tags, $tags_filter_type, $name, $mac, $serial, $model, $macs, $serials, $sensor_metrics, $sensor_alert_profile_ids, $models, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\VmxNetworkDevicesClaim200Response[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\VmxNetworkDevicesClaim200Response[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\VmxNetworkDevicesClaim200Response[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\VmxNetworkDevicesClaim200Response[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\VmxNetworkDevicesClaim200Response[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesAsync
     *
     * List the devices in an organization that have been assigned to a network.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $configuration_updated_after Filter results by whether or not the device&#39;s configuration has been updated after the given timestamp (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $tags Optional parameter to filter devices by tags. (optional)
     * @param  string|null $tags_filter_type Optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string|null $name Optional parameter to filter devices by name. All returned devices will have a name that contains the search term or is an exact match. (optional)
     * @param  string|null $mac Optional parameter to filter devices by MAC address. All returned devices will have a MAC address that contains the search term or is an exact match. (optional)
     * @param  string|null $serial Optional parameter to filter devices by serial number. All returned devices will have a serial number that contains the search term or is an exact match. (optional)
     * @param  string|null $model Optional parameter to filter devices by model. All returned devices will have a model that contains the search term or is an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter devices by one or more MAC addresses. All returned devices will have a MAC address that is an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by one or more serial numbers. All returned devices will have a serial number that is an exact match. (optional)
     * @param  string[]|null $sensor_metrics Optional parameter to filter devices by the metrics that they provide. Only applies to sensor devices. (optional)
     * @param  string[]|null $sensor_alert_profile_ids Optional parameter to filter devices by the alert profiles that are bound to them. Only applies to sensor devices. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $network_ids = null, $product_types = null, $tags = null, $tags_filter_type = null, $name = null, $mac = null, $serial = null, $model = null, $macs = null, $serials = null, $sensor_metrics = null, $sensor_alert_profile_ids = null, $models = null, string $contentType = self::contentTypes['getOrganizationDevices'][0])
    {
        return $this->getOrganizationDevicesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $configuration_updated_after, $network_ids, $product_types, $tags, $tags_filter_type, $name, $mac, $serial, $model, $macs, $serials, $sensor_metrics, $sensor_alert_profile_ids, $models, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesAsyncWithHttpInfo
     *
     * List the devices in an organization that have been assigned to a network.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $configuration_updated_after Filter results by whether or not the device&#39;s configuration has been updated after the given timestamp (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $tags Optional parameter to filter devices by tags. (optional)
     * @param  string|null $tags_filter_type Optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string|null $name Optional parameter to filter devices by name. All returned devices will have a name that contains the search term or is an exact match. (optional)
     * @param  string|null $mac Optional parameter to filter devices by MAC address. All returned devices will have a MAC address that contains the search term or is an exact match. (optional)
     * @param  string|null $serial Optional parameter to filter devices by serial number. All returned devices will have a serial number that contains the search term or is an exact match. (optional)
     * @param  string|null $model Optional parameter to filter devices by model. All returned devices will have a model that contains the search term or is an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter devices by one or more MAC addresses. All returned devices will have a MAC address that is an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by one or more serial numbers. All returned devices will have a serial number that is an exact match. (optional)
     * @param  string[]|null $sensor_metrics Optional parameter to filter devices by the metrics that they provide. Only applies to sensor devices. (optional)
     * @param  string[]|null $sensor_alert_profile_ids Optional parameter to filter devices by the alert profiles that are bound to them. Only applies to sensor devices. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $network_ids = null, $product_types = null, $tags = null, $tags_filter_type = null, $name = null, $mac = null, $serial = null, $model = null, $macs = null, $serials = null, $sensor_metrics = null, $sensor_alert_profile_ids = null, $models = null, string $contentType = self::contentTypes['getOrganizationDevices'][0])
    {
        $returnType = '\Meraki\Model\VmxNetworkDevicesClaim200Response[]';
        $request = $this->getOrganizationDevicesRequest($organization_id, $per_page, $starting_after, $ending_before, $configuration_updated_after, $network_ids, $product_types, $tags, $tags_filter_type, $name, $mac, $serial, $model, $macs, $serials, $sensor_metrics, $sensor_alert_profile_ids, $models, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevices'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $configuration_updated_after Filter results by whether or not the device&#39;s configuration has been updated after the given timestamp (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network. (optional)
     * @param  string[]|null $product_types Optional parameter to filter devices by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $tags Optional parameter to filter devices by tags. (optional)
     * @param  string|null $tags_filter_type Optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return networks which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string|null $name Optional parameter to filter devices by name. All returned devices will have a name that contains the search term or is an exact match. (optional)
     * @param  string|null $mac Optional parameter to filter devices by MAC address. All returned devices will have a MAC address that contains the search term or is an exact match. (optional)
     * @param  string|null $serial Optional parameter to filter devices by serial number. All returned devices will have a serial number that contains the search term or is an exact match. (optional)
     * @param  string|null $model Optional parameter to filter devices by model. All returned devices will have a model that contains the search term or is an exact match. (optional)
     * @param  string[]|null $macs Optional parameter to filter devices by one or more MAC addresses. All returned devices will have a MAC address that is an exact match. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by one or more serial numbers. All returned devices will have a serial number that is an exact match. (optional)
     * @param  string[]|null $sensor_metrics Optional parameter to filter devices by the metrics that they provide. Only applies to sensor devices. (optional)
     * @param  string[]|null $sensor_alert_profile_ids Optional parameter to filter devices by the alert profiles that are bound to them. Only applies to sensor devices. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $configuration_updated_after = null, $network_ids = null, $product_types = null, $tags = null, $tags_filter_type = null, $name = null, $mac = null, $serial = null, $model = null, $macs = null, $serials = null, $sensor_metrics = null, $sensor_alert_profile_ids = null, $models = null, string $contentType = self::contentTypes['getOrganizationDevices'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevices'
            );
        }



















        $resourcePath = '/organizations/{organizationId}/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $configuration_updated_after,
            'configurationUpdatedAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags_filter_type,
            'tagsFilterType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mac,
            'mac', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serial,
            'serial', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $model,
            'model', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $macs,
            'macs', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sensor_metrics,
            'sensorMetrics', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sensor_alert_profile_ids,
            'sensorAlertProfileIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $models,
            'models', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesAvailabilities
     *
     * List the availability information for devices in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. Valid types are wireless, appliance, switch, camera, cellularGateway, sensor, wirelessController, and campusGateway (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities by device status. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilities'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesAvailabilities200ResponseInner[]
     */
    public function getOrganizationDevicesAvailabilities($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilities'][0])
    {
        list($response) = $this->getOrganizationDevicesAvailabilitiesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $statuses, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesAvailabilitiesWithHttpInfo
     *
     * List the availability information for devices in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. Valid types are wireless, appliance, switch, camera, cellularGateway, sensor, wirelessController, and campusGateway (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities by device status. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilities'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesAvailabilities200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesAvailabilitiesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilities'][0])
    {
        $request = $this->getOrganizationDevicesAvailabilitiesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $statuses, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesAvailabilities200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesAvailabilities200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesAvailabilities200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesAvailabilities200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesAvailabilities200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesAvailabilitiesAsync
     *
     * List the availability information for devices in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. Valid types are wireless, appliance, switch, camera, cellularGateway, sensor, wirelessController, and campusGateway (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities by device status. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesAvailabilitiesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilities'][0])
    {
        return $this->getOrganizationDevicesAvailabilitiesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $statuses, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesAvailabilitiesAsyncWithHttpInfo
     *
     * List the availability information for devices in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. Valid types are wireless, appliance, switch, camera, cellularGateway, sensor, wirelessController, and campusGateway (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities by device status. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesAvailabilitiesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilities'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesAvailabilities200ResponseInner[]';
        $request = $this->getOrganizationDevicesAvailabilitiesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $statuses, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesAvailabilities'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. Valid types are wireless, appliance, switch, camera, cellularGateway, sensor, wirelessController, and campusGateway (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities by device status. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesAvailabilitiesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilities'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesAvailabilities'
            );
        }











        $resourcePath = '/organizations/{organizationId}/devices/availabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags_filter_type,
            'tagsFilterType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $statuses,
            'statuses', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesAvailabilitiesChangeHistory
     *
     * List the availability history information for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities history by device product types (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities history by network IDs (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities history by device statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesAvailabilitiesChangeHistory200ResponseInner[]
     */
    public function getOrganizationDevicesAvailabilitiesChangeHistory($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $serials = null, $product_types = null, $network_ids = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'][0])
    {
        list($response) = $this->getOrganizationDevicesAvailabilitiesChangeHistoryWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $serials, $product_types, $network_ids, $statuses, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesAvailabilitiesChangeHistoryWithHttpInfo
     *
     * List the availability history information for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities history by device product types (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities history by network IDs (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities history by device statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesAvailabilitiesChangeHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesAvailabilitiesChangeHistoryWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $serials = null, $product_types = null, $network_ids = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'][0])
    {
        $request = $this->getOrganizationDevicesAvailabilitiesChangeHistoryRequest($organization_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $serials, $product_types, $network_ids, $statuses, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesAvailabilitiesChangeHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesAvailabilitiesChangeHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesAvailabilitiesChangeHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesAvailabilitiesChangeHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesAvailabilitiesChangeHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesAvailabilitiesChangeHistoryAsync
     *
     * List the availability history information for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities history by device product types (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities history by network IDs (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities history by device statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesAvailabilitiesChangeHistoryAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $serials = null, $product_types = null, $network_ids = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'][0])
    {
        return $this->getOrganizationDevicesAvailabilitiesChangeHistoryAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $serials, $product_types, $network_ids, $statuses, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesAvailabilitiesChangeHistoryAsyncWithHttpInfo
     *
     * List the availability history information for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities history by device product types (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities history by network IDs (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities history by device statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesAvailabilitiesChangeHistoryAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $serials = null, $product_types = null, $network_ids = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesAvailabilitiesChangeHistory200ResponseInner[]';
        $request = $this->getOrganizationDevicesAvailabilitiesChangeHistoryRequest($organization_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $serials, $product_types, $network_ids, $statuses, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesAvailabilitiesChangeHistory'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities history by device product types (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities history by network IDs (optional)
     * @param  string[]|null $statuses Optional parameter to filter device availabilities history by device statuses (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesAvailabilitiesChangeHistoryRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $serials = null, $product_types = null, $network_ids = null, $statuses = null, string $contentType = self::contentTypes['getOrganizationDevicesAvailabilitiesChangeHistory'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesAvailabilitiesChangeHistory'
            );
        }






        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationDevicesAvailabilitiesChangeHistory, must be smaller than or equal to 2678400.');
        }
        





        $resourcePath = '/organizations/{organizationId}/devices/availabilities/changeHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $statuses,
            'statuses', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesControllerMigrations
     *
     * Retrieve device migration statuses in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials A list of Meraki Serials for which to retrieve migrations (optional)
     * @param  string[]|null $network_ids Filter device migrations by network IDs (optional)
     * @param  string|null $target Filter device migrations by target destination (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesControllerMigrations'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesControllerMigrations200Response
     */
    public function getOrganizationDevicesControllerMigrations($organization_id, $serials = null, $network_ids = null, $target = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationDevicesControllerMigrations'][0])
    {
        list($response) = $this->getOrganizationDevicesControllerMigrationsWithHttpInfo($organization_id, $serials, $network_ids, $target, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesControllerMigrationsWithHttpInfo
     *
     * Retrieve device migration statuses in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials A list of Meraki Serials for which to retrieve migrations (optional)
     * @param  string[]|null $network_ids Filter device migrations by network IDs (optional)
     * @param  string|null $target Filter device migrations by target destination (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesControllerMigrations'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesControllerMigrations200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesControllerMigrationsWithHttpInfo($organization_id, $serials = null, $network_ids = null, $target = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationDevicesControllerMigrations'][0])
    {
        $request = $this->getOrganizationDevicesControllerMigrationsRequest($organization_id, $serials, $network_ids, $target, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesControllerMigrations200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesControllerMigrations200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesControllerMigrations200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesControllerMigrations200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesControllerMigrations200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesControllerMigrationsAsync
     *
     * Retrieve device migration statuses in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials A list of Meraki Serials for which to retrieve migrations (optional)
     * @param  string[]|null $network_ids Filter device migrations by network IDs (optional)
     * @param  string|null $target Filter device migrations by target destination (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesControllerMigrations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesControllerMigrationsAsync($organization_id, $serials = null, $network_ids = null, $target = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationDevicesControllerMigrations'][0])
    {
        return $this->getOrganizationDevicesControllerMigrationsAsyncWithHttpInfo($organization_id, $serials, $network_ids, $target, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesControllerMigrationsAsyncWithHttpInfo
     *
     * Retrieve device migration statuses in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials A list of Meraki Serials for which to retrieve migrations (optional)
     * @param  string[]|null $network_ids Filter device migrations by network IDs (optional)
     * @param  string|null $target Filter device migrations by target destination (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesControllerMigrations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesControllerMigrationsAsyncWithHttpInfo($organization_id, $serials = null, $network_ids = null, $target = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationDevicesControllerMigrations'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesControllerMigrations200Response';
        $request = $this->getOrganizationDevicesControllerMigrationsRequest($organization_id, $serials, $network_ids, $target, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesControllerMigrations'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials A list of Meraki Serials for which to retrieve migrations (optional)
     * @param  string[]|null $network_ids Filter device migrations by network IDs (optional)
     * @param  string|null $target Filter device migrations by target destination (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesControllerMigrations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesControllerMigrationsRequest($organization_id, $serials = null, $network_ids = null, $target = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationDevicesControllerMigrations'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesControllerMigrations'
            );
        }








        $resourcePath = '/organizations/{organizationId}/devices/controller/migrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesOverviewByModel
     *
     * Lists the count for each device model
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by networkId. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesOverviewByModel'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesOverviewByModel200Response
     */
    public function getOrganizationDevicesOverviewByModel($organization_id, $models = null, $network_ids = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesOverviewByModel'][0])
    {
        list($response) = $this->getOrganizationDevicesOverviewByModelWithHttpInfo($organization_id, $models, $network_ids, $product_types, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesOverviewByModelWithHttpInfo
     *
     * Lists the count for each device model
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by networkId. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesOverviewByModel'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesOverviewByModel200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesOverviewByModelWithHttpInfo($organization_id, $models = null, $network_ids = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesOverviewByModel'][0])
    {
        $request = $this->getOrganizationDevicesOverviewByModelRequest($organization_id, $models, $network_ids, $product_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesOverviewByModel200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesOverviewByModel200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesOverviewByModel200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesOverviewByModel200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesOverviewByModel200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesOverviewByModelAsync
     *
     * Lists the count for each device model
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by networkId. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesOverviewByModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesOverviewByModelAsync($organization_id, $models = null, $network_ids = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesOverviewByModel'][0])
    {
        return $this->getOrganizationDevicesOverviewByModelAsyncWithHttpInfo($organization_id, $models, $network_ids, $product_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesOverviewByModelAsyncWithHttpInfo
     *
     * Lists the count for each device model
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by networkId. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesOverviewByModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesOverviewByModelAsyncWithHttpInfo($organization_id, $models = null, $network_ids = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesOverviewByModel'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesOverviewByModel200Response';
        $request = $this->getOrganizationDevicesOverviewByModelRequest($organization_id, $models, $network_ids, $product_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesOverviewByModel'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $models Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by networkId. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesOverviewByModel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesOverviewByModelRequest($organization_id, $models = null, $network_ids = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesOverviewByModel'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesOverviewByModel'
            );
        }





        $resourcePath = '/organizations/{organizationId}/devices/overview/byModel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $models,
            'models', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesPowerModulesStatusesByDevice
     *
     * List the most recent status information for power modules in rackmount MX and MS devices that support them
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesPowerModulesStatusesByDevice200ResponseInner[]
     */
    public function getOrganizationDevicesPowerModulesStatusesByDevice($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'][0])
    {
        list($response) = $this->getOrganizationDevicesPowerModulesStatusesByDeviceWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesPowerModulesStatusesByDeviceWithHttpInfo
     *
     * List the most recent status information for power modules in rackmount MX and MS devices that support them
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesPowerModulesStatusesByDevice200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesPowerModulesStatusesByDeviceWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'][0])
    {
        $request = $this->getOrganizationDevicesPowerModulesStatusesByDeviceRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesPowerModulesStatusesByDevice200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesPowerModulesStatusesByDevice200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesPowerModulesStatusesByDevice200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesPowerModulesStatusesByDevice200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesPowerModulesStatusesByDevice200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesPowerModulesStatusesByDeviceAsync
     *
     * List the most recent status information for power modules in rackmount MX and MS devices that support them
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesPowerModulesStatusesByDeviceAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'][0])
    {
        return $this->getOrganizationDevicesPowerModulesStatusesByDeviceAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesPowerModulesStatusesByDeviceAsyncWithHttpInfo
     *
     * List the most recent status information for power modules in rackmount MX and MS devices that support them
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesPowerModulesStatusesByDeviceAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesPowerModulesStatusesByDevice200ResponseInner[]';
        $request = $this->getOrganizationDevicesPowerModulesStatusesByDeviceRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesPowerModulesStatusesByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device availabilities by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device availabilities by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesPowerModulesStatusesByDeviceRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesPowerModulesStatusesByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesPowerModulesStatusesByDevice'
            );
        }










        $resourcePath = '/organizations/{organizationId}/devices/powerModules/statuses/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags_filter_type,
            'tagsFilterType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesProvisioningStatuses
     *
     * List the provisioning statuses information for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string|null $status An optional parameter to filter devices by the provisioning status. Accepted statuses: unprovisioned, incomplete, complete. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesProvisioningStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesProvisioningStatuses200ResponseInner[]
     */
    public function getOrganizationDevicesProvisioningStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $status = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesProvisioningStatuses'][0])
    {
        list($response) = $this->getOrganizationDevicesProvisioningStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $status, $tags, $tags_filter_type, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesProvisioningStatusesWithHttpInfo
     *
     * List the provisioning statuses information for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string|null $status An optional parameter to filter devices by the provisioning status. Accepted statuses: unprovisioned, incomplete, complete. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesProvisioningStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesProvisioningStatuses200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesProvisioningStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $status = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesProvisioningStatuses'][0])
    {
        $request = $this->getOrganizationDevicesProvisioningStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $status, $tags, $tags_filter_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesProvisioningStatuses200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesProvisioningStatuses200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesProvisioningStatuses200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesProvisioningStatuses200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesProvisioningStatuses200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesProvisioningStatusesAsync
     *
     * List the provisioning statuses information for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string|null $status An optional parameter to filter devices by the provisioning status. Accepted statuses: unprovisioned, incomplete, complete. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesProvisioningStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesProvisioningStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $status = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesProvisioningStatuses'][0])
    {
        return $this->getOrganizationDevicesProvisioningStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $status, $tags, $tags_filter_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesProvisioningStatusesAsyncWithHttpInfo
     *
     * List the provisioning statuses information for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string|null $status An optional parameter to filter devices by the provisioning status. Accepted statuses: unprovisioned, incomplete, complete. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesProvisioningStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesProvisioningStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $status = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesProvisioningStatuses'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesProvisioningStatuses200ResponseInner[]';
        $request = $this->getOrganizationDevicesProvisioningStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $status, $tags, $tags_filter_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesProvisioningStatuses'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string|null $status An optional parameter to filter devices by the provisioning status. Accepted statuses: unprovisioned, incomplete, complete. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesProvisioningStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesProvisioningStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $status = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesProvisioningStatuses'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesProvisioningStatuses'
            );
        }











        $resourcePath = '/organizations/{organizationId}/devices/provisioning/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags_filter_type,
            'tagsFilterType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesStatuses
     *
     * List the status of every Meraki device in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network ids. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. (optional)
     * @param  string[]|null $statuses Optional parameter to filter devices by statuses. Valid statuses are [\&quot;online\&quot;, \&quot;alerting\&quot;, \&quot;offline\&quot;, \&quot;dormant\&quot;]. (optional)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by models. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesStatuses200ResponseInner[]
     * @deprecated
     */
    public function getOrganizationDevicesStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $statuses = null, $product_types = null, $models = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesStatuses'][0])
    {
        list($response) = $this->getOrganizationDevicesStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $statuses, $product_types, $models, $tags, $tags_filter_type, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesStatusesWithHttpInfo
     *
     * List the status of every Meraki device in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network ids. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. (optional)
     * @param  string[]|null $statuses Optional parameter to filter devices by statuses. Valid statuses are [\&quot;online\&quot;, \&quot;alerting\&quot;, \&quot;offline\&quot;, \&quot;dormant\&quot;]. (optional)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by models. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesStatuses200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getOrganizationDevicesStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $statuses = null, $product_types = null, $models = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesStatuses'][0])
    {
        $request = $this->getOrganizationDevicesStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $statuses, $product_types, $models, $tags, $tags_filter_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesStatuses200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesStatuses200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesStatuses200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesStatuses200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesStatuses200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesStatusesAsync
     *
     * List the status of every Meraki device in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network ids. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. (optional)
     * @param  string[]|null $statuses Optional parameter to filter devices by statuses. Valid statuses are [\&quot;online\&quot;, \&quot;alerting\&quot;, \&quot;offline\&quot;, \&quot;dormant\&quot;]. (optional)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by models. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getOrganizationDevicesStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $statuses = null, $product_types = null, $models = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesStatuses'][0])
    {
        return $this->getOrganizationDevicesStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $statuses, $product_types, $models, $tags, $tags_filter_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesStatusesAsyncWithHttpInfo
     *
     * List the status of every Meraki device in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network ids. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. (optional)
     * @param  string[]|null $statuses Optional parameter to filter devices by statuses. Valid statuses are [\&quot;online\&quot;, \&quot;alerting\&quot;, \&quot;offline\&quot;, \&quot;dormant\&quot;]. (optional)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by models. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getOrganizationDevicesStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $statuses = null, $product_types = null, $models = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesStatuses'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesStatuses200ResponseInner[]';
        $request = $this->getOrganizationDevicesStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $statuses, $product_types, $models, $tags, $tags_filter_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesStatuses'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by network ids. (optional)
     * @param  string[]|null $serials Optional parameter to filter devices by serials. (optional)
     * @param  string[]|null $statuses Optional parameter to filter devices by statuses. Valid statuses are [\&quot;online\&quot;, \&quot;alerting\&quot;, \&quot;offline\&quot;, \&quot;dormant\&quot;]. (optional)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $models Optional parameter to filter devices by models. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getOrganizationDevicesStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $statuses = null, $product_types = null, $models = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesStatuses'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesStatuses'
            );
        }












        $resourcePath = '/organizations/{organizationId}/devices/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $statuses,
            'statuses', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $models,
            'models', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags_filter_type,
            'tagsFilterType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesStatusesOverview
     *
     * Return an overview of current device statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $network_ids An optional parameter to filter device statuses by network. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatusesOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesStatusesOverview200Response
     */
    public function getOrganizationDevicesStatusesOverview($organization_id, $product_types = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationDevicesStatusesOverview'][0])
    {
        list($response) = $this->getOrganizationDevicesStatusesOverviewWithHttpInfo($organization_id, $product_types, $network_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesStatusesOverviewWithHttpInfo
     *
     * Return an overview of current device statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $network_ids An optional parameter to filter device statuses by network. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatusesOverview'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesStatusesOverview200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesStatusesOverviewWithHttpInfo($organization_id, $product_types = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationDevicesStatusesOverview'][0])
    {
        $request = $this->getOrganizationDevicesStatusesOverviewRequest($organization_id, $product_types, $network_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesStatusesOverview200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesStatusesOverview200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesStatusesOverview200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesStatusesOverview200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesStatusesOverview200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesStatusesOverviewAsync
     *
     * Return an overview of current device statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $network_ids An optional parameter to filter device statuses by network. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatusesOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesStatusesOverviewAsync($organization_id, $product_types = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationDevicesStatusesOverview'][0])
    {
        return $this->getOrganizationDevicesStatusesOverviewAsyncWithHttpInfo($organization_id, $product_types, $network_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesStatusesOverviewAsyncWithHttpInfo
     *
     * Return an overview of current device statuses
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $network_ids An optional parameter to filter device statuses by network. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatusesOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesStatusesOverviewAsyncWithHttpInfo($organization_id, $product_types = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationDevicesStatusesOverview'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesStatusesOverview200Response';
        $request = $this->getOrganizationDevicesStatusesOverviewRequest($organization_id, $product_types, $network_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesStatusesOverview'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $product_types An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string[]|null $network_ids An optional parameter to filter device statuses by network. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesStatusesOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesStatusesOverviewRequest($organization_id, $product_types = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationDevicesStatusesOverview'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesStatusesOverview'
            );
        }




        $resourcePath = '/organizations/{organizationId}/devices/statuses/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesSystemMemoryUsageHistoryByInterval
     *
     * Return the memory utilization history in kB for devices in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 2 hours. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 1200, 3600, 14400. The default is 300. Interval is calculated if time params are provided. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesSystemMemoryUsageHistoryByInterval200Response
     */
    public function getOrganizationDevicesSystemMemoryUsageHistoryByInterval($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, $network_ids = null, $serials = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'][0])
    {
        list($response) = $this->getOrganizationDevicesSystemMemoryUsageHistoryByIntervalWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $network_ids, $serials, $product_types, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesSystemMemoryUsageHistoryByIntervalWithHttpInfo
     *
     * Return the memory utilization history in kB for devices in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 2 hours. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 1200, 3600, 14400. The default is 300. Interval is calculated if time params are provided. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesSystemMemoryUsageHistoryByInterval200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesSystemMemoryUsageHistoryByIntervalWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, $network_ids = null, $serials = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'][0])
    {
        $request = $this->getOrganizationDevicesSystemMemoryUsageHistoryByIntervalRequest($organization_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $network_ids, $serials, $product_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesSystemMemoryUsageHistoryByInterval200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesSystemMemoryUsageHistoryByInterval200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesSystemMemoryUsageHistoryByInterval200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesSystemMemoryUsageHistoryByInterval200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesSystemMemoryUsageHistoryByInterval200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesSystemMemoryUsageHistoryByIntervalAsync
     *
     * Return the memory utilization history in kB for devices in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 2 hours. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 1200, 3600, 14400. The default is 300. Interval is calculated if time params are provided. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesSystemMemoryUsageHistoryByIntervalAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, $network_ids = null, $serials = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'][0])
    {
        return $this->getOrganizationDevicesSystemMemoryUsageHistoryByIntervalAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $network_ids, $serials, $product_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesSystemMemoryUsageHistoryByIntervalAsyncWithHttpInfo
     *
     * Return the memory utilization history in kB for devices in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 2 hours. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 1200, 3600, 14400. The default is 300. Interval is calculated if time params are provided. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesSystemMemoryUsageHistoryByIntervalAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, $network_ids = null, $serials = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesSystemMemoryUsageHistoryByInterval200Response';
        $request = $this->getOrganizationDevicesSystemMemoryUsageHistoryByIntervalRequest($organization_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $network_ids, $serials, $product_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesSystemMemoryUsageHistoryByInterval'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 2 hours. If interval is provided, the timespan will be autocalculated. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 1200, 3600, 14400. The default is 300. Interval is calculated if time params are provided. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string[]|null $product_types Optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, and secureConnect. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesSystemMemoryUsageHistoryByIntervalRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, $network_ids = null, $serials = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationDevicesSystemMemoryUsageHistoryByInterval'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesSystemMemoryUsageHistoryByInterval'
            );
        }






        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationDevicesSystemMemoryUsageHistoryByInterval, must be smaller than or equal to 2678400.');
        }
        





        $resourcePath = '/organizations/{organizationId}/devices/system/memory/usage/history/byInterval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesUplinksAddressesByDevice
     *
     * List the current uplink addresses for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]
     */
    public function getOrganizationDevicesUplinksAddressesByDevice($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {
        list($response) = $this->getOrganizationDevicesUplinksAddressesByDeviceWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesUplinksAddressesByDeviceWithHttpInfo
     *
     * List the current uplink addresses for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesUplinksAddressesByDeviceWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {
        $request = $this->getOrganizationDevicesUplinksAddressesByDeviceRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesUplinksAddressesByDeviceAsync
     *
     * List the current uplink addresses for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksAddressesByDeviceAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {
        return $this->getOrganizationDevicesUplinksAddressesByDeviceAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesUplinksAddressesByDeviceAsyncWithHttpInfo
     *
     * List the current uplink addresses for devices in an organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksAddressesByDeviceAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesUplinksAddressesByDevice200ResponseInner[]';
        $request = $this->getOrganizationDevicesUplinksAddressesByDeviceRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $product_types, $serials, $tags, $tags_filter_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesUplinksAddressesByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter device uplinks by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $product_types Optional parameter to filter device uplinks by device product types. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities by device serial numbers. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $tags An optional parameter to filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). This filter uses multiple exact matches. (optional)
     * @param  string|null $tags_filter_type An optional parameter of value &#39;withAnyTags&#39; or &#39;withAllTags&#39; to indicate whether to return devices which contain ANY or ALL of the included tags. If no type is included, &#39;withAnyTags&#39; will be selected. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesUplinksAddressesByDeviceRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $product_types = null, $serials = null, $tags = null, $tags_filter_type = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksAddressesByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesUplinksAddressesByDevice'
            );
        }










        $resourcePath = '/organizations/{organizationId}/devices/uplinks/addresses/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags_filter_type,
            'tagsFilterType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatency
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]
     */
    public function getOrganizationDevicesUplinksLossAndLatency($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {
        list($response) = $this->getOrganizationDevicesUplinksLossAndLatencyWithHttpInfo($organization_id, $t0, $t1, $timespan, $uplink, $ip, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatencyWithHttpInfo
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesUplinksLossAndLatencyWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {
        $request = $this->getOrganizationDevicesUplinksLossAndLatencyRequest($organization_id, $t0, $t1, $timespan, $uplink, $ip, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatencyAsync
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksLossAndLatencyAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {
        return $this->getOrganizationDevicesUplinksLossAndLatencyAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $uplink, $ip, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatencyAsyncWithHttpInfo
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksLossAndLatencyAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationDevicesUplinksLossAndLatency200ResponseInner[]';
        $request = $this->getOrganizationDevicesUplinksLossAndLatencyRequest($organization_id, $t0, $t1, $timespan, $uplink, $ip, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesUplinksLossAndLatency'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 60 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string|null $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, wan3, cellular. Default will return all uplinks. (optional)
     * @param  string|null $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationDevicesUplinksLossAndLatencyRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null, string $contentType = self::contentTypes['getOrganizationDevicesUplinksLossAndLatency'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesUplinksLossAndLatency'
            );
        }



        if ($timespan !== null && $timespan > 300) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationDevicesUplinksLossAndLatency, must be smaller than or equal to 300.');
        }
        



        $resourcePath = '/organizations/{organizationId}/devices/uplinksLossAndLatency';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uplink,
            'uplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip,
            'ip', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationFloorPlansAutoLocateDevices
     *
     * List auto locate details for each device in your organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 10000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by one or more network IDs (optional)
     * @param  string[]|null $floor_plan_ids Optional parameter to filter devices by one or more floorplan IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationFloorPlansAutoLocateDevices200ResponseInner[]
     */
    public function getOrganizationFloorPlansAutoLocateDevices($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $floor_plan_ids = null, string $contentType = self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'][0])
    {
        list($response) = $this->getOrganizationFloorPlansAutoLocateDevicesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $floor_plan_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationFloorPlansAutoLocateDevicesWithHttpInfo
     *
     * List auto locate details for each device in your organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 10000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by one or more network IDs (optional)
     * @param  string[]|null $floor_plan_ids Optional parameter to filter devices by one or more floorplan IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationFloorPlansAutoLocateDevices200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationFloorPlansAutoLocateDevicesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $floor_plan_ids = null, string $contentType = self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'][0])
    {
        $request = $this->getOrganizationFloorPlansAutoLocateDevicesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $floor_plan_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationFloorPlansAutoLocateDevices200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationFloorPlansAutoLocateDevices200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationFloorPlansAutoLocateDevices200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationFloorPlansAutoLocateDevices200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationFloorPlansAutoLocateDevices200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationFloorPlansAutoLocateDevicesAsync
     *
     * List auto locate details for each device in your organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 10000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by one or more network IDs (optional)
     * @param  string[]|null $floor_plan_ids Optional parameter to filter devices by one or more floorplan IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationFloorPlansAutoLocateDevicesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $floor_plan_ids = null, string $contentType = self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'][0])
    {
        return $this->getOrganizationFloorPlansAutoLocateDevicesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $floor_plan_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationFloorPlansAutoLocateDevicesAsyncWithHttpInfo
     *
     * List auto locate details for each device in your organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 10000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by one or more network IDs (optional)
     * @param  string[]|null $floor_plan_ids Optional parameter to filter devices by one or more floorplan IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationFloorPlansAutoLocateDevicesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $floor_plan_ids = null, string $contentType = self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationFloorPlansAutoLocateDevices200ResponseInner[]';
        $request = $this->getOrganizationFloorPlansAutoLocateDevicesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $floor_plan_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationFloorPlansAutoLocateDevices'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 10000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter devices by one or more network IDs (optional)
     * @param  string[]|null $floor_plan_ids Optional parameter to filter devices by one or more floorplan IDs (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationFloorPlansAutoLocateDevicesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $floor_plan_ids = null, string $contentType = self::contentTypes['getOrganizationFloorPlansAutoLocateDevices'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationFloorPlansAutoLocateDevices'
            );
        }







        $resourcePath = '/organizations/{organizationId}/floorPlans/autoLocate/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $floor_plan_ids,
            'floorPlanIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationInventoryDevice
     *
     * Return a single device from the inventory of an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationInventoryDevices200ResponseInner
     */
    public function getOrganizationInventoryDevice($organization_id, $serial, string $contentType = self::contentTypes['getOrganizationInventoryDevice'][0])
    {
        list($response) = $this->getOrganizationInventoryDeviceWithHttpInfo($organization_id, $serial, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationInventoryDeviceWithHttpInfo
     *
     * Return a single device from the inventory of an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationInventoryDevices200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationInventoryDeviceWithHttpInfo($organization_id, $serial, string $contentType = self::contentTypes['getOrganizationInventoryDevice'][0])
    {
        $request = $this->getOrganizationInventoryDeviceRequest($organization_id, $serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationInventoryDeviceAsync
     *
     * Return a single device from the inventory of an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationInventoryDeviceAsync($organization_id, $serial, string $contentType = self::contentTypes['getOrganizationInventoryDevice'][0])
    {
        return $this->getOrganizationInventoryDeviceAsyncWithHttpInfo($organization_id, $serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationInventoryDeviceAsyncWithHttpInfo
     *
     * Return a single device from the inventory of an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationInventoryDeviceAsyncWithHttpInfo($organization_id, $serial, string $contentType = self::contentTypes['getOrganizationInventoryDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner';
        $request = $this->getOrganizationInventoryDeviceRequest($organization_id, $serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationInventoryDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationInventoryDeviceRequest($organization_id, $serial, string $contentType = self::contentTypes['getOrganizationInventoryDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationInventoryDevice'
            );
        }

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getOrganizationInventoryDevice'
            );
        }


        $resourcePath = '/organizations/{organizationId}/inventory/devices/{serial}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationInventoryDevices
     *
     * Return the device inventory for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $used_state Filter results by used or unused inventory. Accepted values are &#39;used&#39; or &#39;unused&#39;. (optional)
     * @param  string|null $search Search for devices in inventory based on serial number, mac address, or model. (optional)
     * @param  string[]|null $macs Search for devices in inventory based on mac addresses. (optional)
     * @param  string[]|null $network_ids Search for devices in inventory based on network ids. Use explicit &#39;null&#39; value to get available devices only. (optional)
     * @param  string[]|null $serials Search for devices in inventory based on serials. (optional)
     * @param  string[]|null $models Search for devices in inventory based on model. (optional)
     * @param  string[]|null $order_numbers Search for devices in inventory based on order numbers. (optional)
     * @param  string[]|null $tags Filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type To use with &#39;tags&#39; parameter, to filter devices which contain ANY or ALL given tags. Accepted values are &#39;withAnyTags&#39; or &#39;withAllTags&#39;, default is &#39;withAnyTags&#39;. (optional)
     * @param  string[]|null $product_types Filter devices by product type. Accepted values are appliance, camera, cellularGateway, secureConnect, sensor, switch, systemsManager, wireless, and wirelessController. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationInventoryDevices200ResponseInner[]
     */
    public function getOrganizationInventoryDevices($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $used_state = null, $search = null, $macs = null, $network_ids = null, $serials = null, $models = null, $order_numbers = null, $tags = null, $tags_filter_type = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationInventoryDevices'][0])
    {
        list($response) = $this->getOrganizationInventoryDevicesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $used_state, $search, $macs, $network_ids, $serials, $models, $order_numbers, $tags, $tags_filter_type, $product_types, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationInventoryDevicesWithHttpInfo
     *
     * Return the device inventory for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $used_state Filter results by used or unused inventory. Accepted values are &#39;used&#39; or &#39;unused&#39;. (optional)
     * @param  string|null $search Search for devices in inventory based on serial number, mac address, or model. (optional)
     * @param  string[]|null $macs Search for devices in inventory based on mac addresses. (optional)
     * @param  string[]|null $network_ids Search for devices in inventory based on network ids. Use explicit &#39;null&#39; value to get available devices only. (optional)
     * @param  string[]|null $serials Search for devices in inventory based on serials. (optional)
     * @param  string[]|null $models Search for devices in inventory based on model. (optional)
     * @param  string[]|null $order_numbers Search for devices in inventory based on order numbers. (optional)
     * @param  string[]|null $tags Filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type To use with &#39;tags&#39; parameter, to filter devices which contain ANY or ALL given tags. Accepted values are &#39;withAnyTags&#39; or &#39;withAllTags&#39;, default is &#39;withAnyTags&#39;. (optional)
     * @param  string[]|null $product_types Filter devices by product type. Accepted values are appliance, camera, cellularGateway, secureConnect, sensor, switch, systemsManager, wireless, and wirelessController. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationInventoryDevices200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationInventoryDevicesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $used_state = null, $search = null, $macs = null, $network_ids = null, $serials = null, $models = null, $order_numbers = null, $tags = null, $tags_filter_type = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationInventoryDevices'][0])
    {
        $request = $this->getOrganizationInventoryDevicesRequest($organization_id, $per_page, $starting_after, $ending_before, $used_state, $search, $macs, $network_ids, $serials, $models, $order_numbers, $tags, $tags_filter_type, $product_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationInventoryDevicesAsync
     *
     * Return the device inventory for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $used_state Filter results by used or unused inventory. Accepted values are &#39;used&#39; or &#39;unused&#39;. (optional)
     * @param  string|null $search Search for devices in inventory based on serial number, mac address, or model. (optional)
     * @param  string[]|null $macs Search for devices in inventory based on mac addresses. (optional)
     * @param  string[]|null $network_ids Search for devices in inventory based on network ids. Use explicit &#39;null&#39; value to get available devices only. (optional)
     * @param  string[]|null $serials Search for devices in inventory based on serials. (optional)
     * @param  string[]|null $models Search for devices in inventory based on model. (optional)
     * @param  string[]|null $order_numbers Search for devices in inventory based on order numbers. (optional)
     * @param  string[]|null $tags Filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type To use with &#39;tags&#39; parameter, to filter devices which contain ANY or ALL given tags. Accepted values are &#39;withAnyTags&#39; or &#39;withAllTags&#39;, default is &#39;withAnyTags&#39;. (optional)
     * @param  string[]|null $product_types Filter devices by product type. Accepted values are appliance, camera, cellularGateway, secureConnect, sensor, switch, systemsManager, wireless, and wirelessController. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationInventoryDevicesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $used_state = null, $search = null, $macs = null, $network_ids = null, $serials = null, $models = null, $order_numbers = null, $tags = null, $tags_filter_type = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationInventoryDevices'][0])
    {
        return $this->getOrganizationInventoryDevicesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $used_state, $search, $macs, $network_ids, $serials, $models, $order_numbers, $tags, $tags_filter_type, $product_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationInventoryDevicesAsyncWithHttpInfo
     *
     * Return the device inventory for an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $used_state Filter results by used or unused inventory. Accepted values are &#39;used&#39; or &#39;unused&#39;. (optional)
     * @param  string|null $search Search for devices in inventory based on serial number, mac address, or model. (optional)
     * @param  string[]|null $macs Search for devices in inventory based on mac addresses. (optional)
     * @param  string[]|null $network_ids Search for devices in inventory based on network ids. Use explicit &#39;null&#39; value to get available devices only. (optional)
     * @param  string[]|null $serials Search for devices in inventory based on serials. (optional)
     * @param  string[]|null $models Search for devices in inventory based on model. (optional)
     * @param  string[]|null $order_numbers Search for devices in inventory based on order numbers. (optional)
     * @param  string[]|null $tags Filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type To use with &#39;tags&#39; parameter, to filter devices which contain ANY or ALL given tags. Accepted values are &#39;withAnyTags&#39; or &#39;withAllTags&#39;, default is &#39;withAnyTags&#39;. (optional)
     * @param  string[]|null $product_types Filter devices by product type. Accepted values are appliance, camera, cellularGateway, secureConnect, sensor, switch, systemsManager, wireless, and wirelessController. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationInventoryDevicesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $used_state = null, $search = null, $macs = null, $network_ids = null, $serials = null, $models = null, $order_numbers = null, $tags = null, $tags_filter_type = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationInventoryDevices'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationInventoryDevices200ResponseInner[]';
        $request = $this->getOrganizationInventoryDevicesRequest($organization_id, $per_page, $starting_after, $ending_before, $used_state, $search, $macs, $network_ids, $serials, $models, $order_numbers, $tags, $tags_filter_type, $product_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationInventoryDevices'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $used_state Filter results by used or unused inventory. Accepted values are &#39;used&#39; or &#39;unused&#39;. (optional)
     * @param  string|null $search Search for devices in inventory based on serial number, mac address, or model. (optional)
     * @param  string[]|null $macs Search for devices in inventory based on mac addresses. (optional)
     * @param  string[]|null $network_ids Search for devices in inventory based on network ids. Use explicit &#39;null&#39; value to get available devices only. (optional)
     * @param  string[]|null $serials Search for devices in inventory based on serials. (optional)
     * @param  string[]|null $models Search for devices in inventory based on model. (optional)
     * @param  string[]|null $order_numbers Search for devices in inventory based on order numbers. (optional)
     * @param  string[]|null $tags Filter devices by tags. The filtering is case-sensitive. If tags are included, &#39;tagsFilterType&#39; should also be included (see below). (optional)
     * @param  string|null $tags_filter_type To use with &#39;tags&#39; parameter, to filter devices which contain ANY or ALL given tags. Accepted values are &#39;withAnyTags&#39; or &#39;withAllTags&#39;, default is &#39;withAnyTags&#39;. (optional)
     * @param  string[]|null $product_types Filter devices by product type. Accepted values are appliance, camera, cellularGateway, secureConnect, sensor, switch, systemsManager, wireless, and wirelessController. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationInventoryDevicesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $used_state = null, $search = null, $macs = null, $network_ids = null, $serials = null, $models = null, $order_numbers = null, $tags = null, $tags_filter_type = null, $product_types = null, string $contentType = self::contentTypes['getOrganizationInventoryDevices'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationInventoryDevices'
            );
        }















        $resourcePath = '/organizations/{organizationId}/inventory/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $used_state,
            'usedState', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $macs,
            'macs', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $models,
            'models', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_numbers,
            'orderNumbers', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags_filter_type,
            'tagsFilterType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_types,
            'productTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationInventoryDevicesSwapsBulk
     *
     * List of device swaps for a given request ID ({id}).
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response
     */
    public function getOrganizationInventoryDevicesSwapsBulk($organization_id, $id, string $contentType = self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'][0])
    {
        list($response) = $this->getOrganizationInventoryDevicesSwapsBulkWithHttpInfo($organization_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationInventoryDevicesSwapsBulkWithHttpInfo
     *
     * List of device swaps for a given request ID ({id}).
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationInventoryDevicesSwapsBulkWithHttpInfo($organization_id, $id, string $contentType = self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'][0])
    {
        $request = $this->getOrganizationInventoryDevicesSwapsBulkRequest($organization_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationInventoryDevicesSwapsBulkAsync
     *
     * List of device swaps for a given request ID ({id}).
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationInventoryDevicesSwapsBulkAsync($organization_id, $id, string $contentType = self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'][0])
    {
        return $this->getOrganizationInventoryDevicesSwapsBulkAsyncWithHttpInfo($organization_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationInventoryDevicesSwapsBulkAsyncWithHttpInfo
     *
     * List of device swaps for a given request ID ({id}).
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationInventoryDevicesSwapsBulkAsyncWithHttpInfo($organization_id, $id, string $contentType = self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'][0])
    {
        $returnType = '\Meraki\Model\CreateOrganizationInventoryDevicesSwapsBulk207Response';
        $request = $this->getOrganizationInventoryDevicesSwapsBulkRequest($organization_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationInventoryDevicesSwapsBulk'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $id ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationInventoryDevicesSwapsBulkRequest($organization_id, $id, string $contentType = self::contentTypes['getOrganizationInventoryDevicesSwapsBulk'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationInventoryDevicesSwapsBulk'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOrganizationInventoryDevicesSwapsBulk'
            );
        }


        $resourcePath = '/organizations/{organizationId}/inventory/devices/swaps/bulk/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationSummaryTopDevicesByUsage
     *
     * Return metrics for organization&#39;s top 10 devices sorted by data usage over given time range
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesByUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationSummaryTopDevicesByUsage200ResponseInner[]
     */
    public function getOrganizationSummaryTopDevicesByUsage($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesByUsage'][0])
    {
        list($response) = $this->getOrganizationSummaryTopDevicesByUsageWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationSummaryTopDevicesByUsageWithHttpInfo
     *
     * Return metrics for organization&#39;s top 10 devices sorted by data usage over given time range
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesByUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationSummaryTopDevicesByUsage200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationSummaryTopDevicesByUsageWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesByUsage'][0])
    {
        $request = $this->getOrganizationSummaryTopDevicesByUsageRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationSummaryTopDevicesByUsage200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationSummaryTopDevicesByUsage200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationSummaryTopDevicesByUsage200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationSummaryTopDevicesByUsage200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationSummaryTopDevicesByUsage200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationSummaryTopDevicesByUsageAsync
     *
     * Return metrics for organization&#39;s top 10 devices sorted by data usage over given time range
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopDevicesByUsageAsync($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesByUsage'][0])
    {
        return $this->getOrganizationSummaryTopDevicesByUsageAsyncWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationSummaryTopDevicesByUsageAsyncWithHttpInfo
     *
     * Return metrics for organization&#39;s top 10 devices sorted by data usage over given time range
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopDevicesByUsageAsyncWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesByUsage'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationSummaryTopDevicesByUsage200ResponseInner[]';
        $request = $this->getOrganizationSummaryTopDevicesByUsageRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationSummaryTopDevicesByUsage'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationSummaryTopDevicesByUsageRequest($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesByUsage'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationSummaryTopDevicesByUsage'
            );
        }








        if ($timespan !== null && $timespan > 16070400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationSummaryTopDevicesByUsage, must be smaller than or equal to 16070400.');
        }
        if ($timespan !== null && $timespan < 28800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationSummaryTopDevicesByUsage, must be bigger than or equal to 28800.');
        }
        

        $resourcePath = '/organizations/{organizationId}/summary/top/devices/byUsage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_tag,
            'networkTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tag,
            'deviceTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity,
            'quantity', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_name,
            'ssidName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $usage_uplink,
            'usageUplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationSummaryTopDevicesModelsByUsage
     *
     * Return metrics for organization&#39;s top 10 device models sorted by data usage over given time range
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationSummaryTopDevicesModelsByUsage200ResponseInner[]
     */
    public function getOrganizationSummaryTopDevicesModelsByUsage($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'][0])
    {
        list($response) = $this->getOrganizationSummaryTopDevicesModelsByUsageWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationSummaryTopDevicesModelsByUsageWithHttpInfo
     *
     * Return metrics for organization&#39;s top 10 device models sorted by data usage over given time range
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationSummaryTopDevicesModelsByUsage200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationSummaryTopDevicesModelsByUsageWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'][0])
    {
        $request = $this->getOrganizationSummaryTopDevicesModelsByUsageRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationSummaryTopDevicesModelsByUsage200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationSummaryTopDevicesModelsByUsage200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationSummaryTopDevicesModelsByUsage200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationSummaryTopDevicesModelsByUsage200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationSummaryTopDevicesModelsByUsage200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationSummaryTopDevicesModelsByUsageAsync
     *
     * Return metrics for organization&#39;s top 10 device models sorted by data usage over given time range
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopDevicesModelsByUsageAsync($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'][0])
    {
        return $this->getOrganizationSummaryTopDevicesModelsByUsageAsyncWithHttpInfo($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationSummaryTopDevicesModelsByUsageAsyncWithHttpInfo
     *
     * Return metrics for organization&#39;s top 10 device models sorted by data usage over given time range
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationSummaryTopDevicesModelsByUsageAsyncWithHttpInfo($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationSummaryTopDevicesModelsByUsage200ResponseInner[]';
        $request = $this->getOrganizationSummaryTopDevicesModelsByUsageRequest($organization_id, $network_tag, $device_tag, $quantity, $ssid_name, $usage_uplink, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationSummaryTopDevicesModelsByUsage'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $network_tag Match result to an exact network tag (optional)
     * @param  string|null $device_tag Match result to an exact device tag (optional)
     * @param  int|null $quantity Set number of desired results to return. Default is 10. (optional)
     * @param  string|null $ssid_name Filter results by ssid name (optional)
     * @param  string|null $usage_uplink Filter results by usage uplink (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 186 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 8 hours and be less than or equal to 186 days. The default is 1 day. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationSummaryTopDevicesModelsByUsageRequest($organization_id, $network_tag = null, $device_tag = null, $quantity = null, $ssid_name = null, $usage_uplink = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationSummaryTopDevicesModelsByUsage'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationSummaryTopDevicesModelsByUsage'
            );
        }








        if ($timespan !== null && $timespan > 16070400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationSummaryTopDevicesModelsByUsage, must be smaller than or equal to 16070400.');
        }
        if ($timespan !== null && $timespan < 28800) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationSummaryTopDevicesModelsByUsage, must be bigger than or equal to 28800.');
        }
        

        $resourcePath = '/organizations/{organizationId}/summary/top/devices/models/byUsage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_tag,
            'networkTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $device_tag,
            'deviceTag', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity,
            'quantity', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssid_name,
            'ssidName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $usage_uplink,
            'usageUplink', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2ByDevice
     *
     * List wireless LAN controller layer 2 interfaces in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2ByDevice200Response
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2ByDevice($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceWithHttpInfo
     *
     * List wireless LAN controller layer 2 interfaces in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2ByDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2ByDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2ByDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2ByDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2ByDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2ByDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceAsync
     *
     * List wireless LAN controller layer 2 interfaces in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceAsync($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceAsyncWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceAsyncWithHttpInfo
     *
     * List wireless LAN controller layer 2 interfaces in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceAsyncWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2ByDevice200Response';
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2ByDeviceRequest($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesInterfacesL2ByDevice'
            );
        }




        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesInterfacesL2ByDevice, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/interfaces/l2/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice
     *
     * List wireless LAN controller layer 2 interfaces history status in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice200Response
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceWithHttpInfo($organization_id, $serials, $include_interfaces_without_changes, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceWithHttpInfo
     *
     * List wireless LAN controller layer 2 interfaces history status in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceWithHttpInfo($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceRequest($organization_id, $serials, $include_interfaces_without_changes, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceAsync
     *
     * List wireless LAN controller layer 2 interfaces history status in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceAsync($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceAsyncWithHttpInfo($organization_id, $serials, $include_interfaces_without_changes, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceAsyncWithHttpInfo
     *
     * List wireless LAN controller layer 2 interfaces history status in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceAsyncWithHttpInfo($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice200Response';
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceRequest($organization_id, $serials, $include_interfaces_without_changes, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDeviceRequest($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice'
            );
        }





        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesInterfacesL2StatusesChangeHistoryByDevice, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/interfaces/l2/statuses/changeHistory/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_interfaces_without_changes,
            'includeInterfacesWithoutChanges', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval
     *
     * List wireless LAN controller layer 2 interfaces history usage in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval200Response
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalWithHttpInfo
     *
     * List wireless LAN controller layer 2 interfaces history usage in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalAsync
     *
     * List wireless LAN controller layer 2 interfaces history usage in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalAsync($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalAsyncWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalAsyncWithHttpInfo
     *
     * List wireless LAN controller layer 2 interfaces history usage in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalAsyncWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval200Response';
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByIntervalRequest($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval'
            );
        }




        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesInterfacesL2UsageHistoryByInterval, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/interfaces/l2/usage/history/byInterval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3ByDevice
     *
     * List wireless LAN controller layer 3 interfaces in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3ByDevice200Response
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3ByDevice($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceWithHttpInfo
     *
     * List wireless LAN controller layer 3 interfaces in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3ByDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3ByDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3ByDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3ByDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3ByDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3ByDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceAsync
     *
     * List wireless LAN controller layer 3 interfaces in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceAsync($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceAsyncWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceAsyncWithHttpInfo
     *
     * List wireless LAN controller layer 3 interfaces in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceAsyncWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3ByDevice200Response';
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3ByDeviceRequest($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesInterfacesL3ByDevice'
            );
        }




        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesInterfacesL3ByDevice, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/interfaces/l3/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice
     *
     * List wireless LAN controller layer 3 interfaces history status in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice200Response
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceWithHttpInfo($organization_id, $serials, $include_interfaces_without_changes, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceWithHttpInfo
     *
     * List wireless LAN controller layer 3 interfaces history status in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceWithHttpInfo($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceRequest($organization_id, $serials, $include_interfaces_without_changes, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceAsync
     *
     * List wireless LAN controller layer 3 interfaces history status in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceAsync($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceAsyncWithHttpInfo($organization_id, $serials, $include_interfaces_without_changes, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceAsyncWithHttpInfo
     *
     * List wireless LAN controller layer 3 interfaces history status in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceAsyncWithHttpInfo($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice200Response';
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceRequest($organization_id, $serials, $include_interfaces_without_changes, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  bool|null $include_interfaces_without_changes By default, interfaces without changes are omitted from the response for brevity. If you want to include the interfaces even if they have no changes, set to true. (default: false) (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDeviceRequest($organization_id, $serials = null, $include_interfaces_without_changes = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice'
            );
        }





        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesInterfacesL3StatusesChangeHistoryByDevice, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/interfaces/l3/statuses/changeHistory/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_interfaces_without_changes,
            'includeInterfacesWithoutChanges', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval
     *
     * List wireless LAN controller layer 3 interfaces history usage in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval200Response
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalWithHttpInfo
     *
     * List wireless LAN controller layer 3 interfaces history usage in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalAsync
     *
     * List wireless LAN controller layer 3 interfaces history usage in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalAsync($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalAsyncWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalAsyncWithHttpInfo
     *
     * List wireless LAN controller layer 3 interfaces history usage in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalAsyncWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval200Response';
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByIntervalRequest($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval'
            );
        }




        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesInterfacesL3UsageHistoryByInterval, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/interfaces/l3/usage/history/byInterval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice
     *
     * Retrieve the packet counters for the interfaces of a Wireless LAN controller
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 hour. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice200Response
     */
    public function getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceWithHttpInfo($organization_id, $serials, $names, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceWithHttpInfo
     *
     * Retrieve the packet counters for the interfaces of a Wireless LAN controller
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 hour. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceWithHttpInfo($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest($organization_id, $serials, $names, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceAsync
     *
     * Retrieve the packet counters for the interfaces of a Wireless LAN controller
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 hour. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceAsync($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceAsyncWithHttpInfo($organization_id, $serials, $names, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceAsyncWithHttpInfo
     *
     * Retrieve the packet counters for the interfaces of a Wireless LAN controller
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 hour. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceAsyncWithHttpInfo($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice200Response';
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest($organization_id, $serials, $names, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 hour. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice'
            );
        }





        if ($timespan !== null && $timespan > 86400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice, must be smaller than or equal to 86400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/interfaces/packets/overview/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $names,
            'names', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval
     *
     * Retrieve the traffic for the interfaces of a Wireless LAN controller
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval200Response
     */
    public function getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalWithHttpInfo($organization_id, $serials, $names, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalWithHttpInfo
     *
     * Retrieve the traffic for the interfaces of a Wireless LAN controller
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalWithHttpInfo($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalRequest($organization_id, $serials, $names, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalAsync
     *
     * Retrieve the traffic for the interfaces of a Wireless LAN controller
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalAsync($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalAsyncWithHttpInfo($organization_id, $serials, $names, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalAsyncWithHttpInfo
     *
     * Retrieve the traffic for the interfaces of a Wireless LAN controller
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalAsyncWithHttpInfo($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval200Response';
        $request = $this->getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalRequest($organization_id, $serials, $names, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $names Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByIntervalRequest($organization_id, $serials = null, $names = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval'
            );
        }





        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesInterfacesUsageHistoryByInterval, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/interfaces/usage/history/byInterval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $names,
            'names', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesRedundancyFailoverHistory
     *
     * List the failover events of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyFailoverHistory200ResponseInner[]
     */
    public function getOrganizationWirelessControllerDevicesRedundancyFailoverHistory($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryWithHttpInfo
     *
     * List the failover events of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyFailoverHistory200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyFailoverHistory200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyFailoverHistory200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyFailoverHistory200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyFailoverHistory200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyFailoverHistory200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryAsync
     *
     * List the failover events of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryAsync($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryAsyncWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryAsyncWithHttpInfo
     *
     * List the failover events of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryAsyncWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyFailoverHistory200ResponseInner[]';
        $request = $this->getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesRedundancyFailoverHistoryRequest($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesRedundancyFailoverHistory'
            );
        }




        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesRedundancyFailoverHistory, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/redundancy/failover/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesRedundancyStatuses
     *
     * List redundancy details of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyStatuses200Response
     */
    public function getOrganizationWirelessControllerDevicesRedundancyStatuses($organization_id, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesRedundancyStatusesWithHttpInfo($organization_id, $serials, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesRedundancyStatusesWithHttpInfo
     *
     * List redundancy details of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyStatuses200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesRedundancyStatusesWithHttpInfo($organization_id, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesRedundancyStatusesRequest($organization_id, $serials, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyStatuses200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyStatuses200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyStatuses200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyStatuses200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyStatuses200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesRedundancyStatusesAsync
     *
     * List redundancy details of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesRedundancyStatusesAsync($organization_id, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesRedundancyStatusesAsyncWithHttpInfo($organization_id, $serials, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesRedundancyStatusesAsyncWithHttpInfo
     *
     * List redundancy details of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesRedundancyStatusesAsyncWithHttpInfo($organization_id, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesRedundancyStatuses200Response';
        $request = $this->getOrganizationWirelessControllerDevicesRedundancyStatusesRequest($organization_id, $serials, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesRedundancyStatuses'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud IDs. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesRedundancyStatusesRequest($organization_id, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesRedundancyStatuses'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesRedundancyStatuses'
            );
        }






        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/redundancy/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval
     *
     * List cpu utilization data of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval200Response
     */
    public function getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'][0])
    {
        list($response) = $this->getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalWithHttpInfo
     *
     * List cpu utilization data of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'][0])
    {
        $request = $this->getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalAsync
     *
     * List cpu utilization data of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalAsync($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'][0])
    {
        return $this->getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalAsyncWithHttpInfo($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalAsyncWithHttpInfo
     *
     * List cpu utilization data of wireless LAN controllers in an organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalAsyncWithHttpInfo($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval200Response';
        $request = $this->getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalRequest($organization_id, $serials, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $serials Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByIntervalRequest($organization_id, $serials = null, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval'
            );
        }




        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessControllerDevicesSystemUtilizationHistoryByInterval, must be smaller than or equal to 2678400.');
        }
        




        $resourcePath = '/organizations/{organizationId}/wirelessController/devices/system/utilization/history/byInterval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationByDevice
     *
     * Get average channel utilization for all bands in a network, split by AP
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByDevice200ResponseInner[]
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByDevice($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesChannelUtilizationByDeviceWithHttpInfo($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationByDeviceWithHttpInfo
     *
     * Get average channel utilization for all bands in a network, split by AP
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByDevice200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByDeviceWithHttpInfo($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'][0])
    {
        $request = $this->getOrganizationWirelessDevicesChannelUtilizationByDeviceRequest($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByDevice200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByDevice200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByDevice200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByDevice200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByDevice200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationByDeviceAsync
     *
     * Get average channel utilization for all bands in a network, split by AP
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByDeviceAsync($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'][0])
    {
        return $this->getOrganizationWirelessDevicesChannelUtilizationByDeviceAsyncWithHttpInfo($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationByDeviceAsyncWithHttpInfo
     *
     * Get average channel utilization for all bands in a network, split by AP
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByDeviceAsyncWithHttpInfo($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByDevice200ResponseInner[]';
        $request = $this->getOrganizationWirelessDevicesChannelUtilizationByDeviceRequest($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesChannelUtilizationByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByDeviceRequest($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesChannelUtilizationByDevice'
            );
        }








        if ($timespan !== null && $timespan > 7776000) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesChannelUtilizationByDevice, must be smaller than or equal to 7776000.');
        }
        


        $resourcePath = '/organizations/{organizationId}/wireless/devices/channelUtilization/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationByNetwork
     *
     * Get average channel utilization across all bands for all networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByNetwork200ResponseInner[]
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByNetwork($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesChannelUtilizationByNetworkWithHttpInfo($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationByNetworkWithHttpInfo
     *
     * Get average channel utilization across all bands for all networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByNetwork200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByNetworkWithHttpInfo($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'][0])
    {
        $request = $this->getOrganizationWirelessDevicesChannelUtilizationByNetworkRequest($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByNetwork200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByNetwork200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByNetwork200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByNetwork200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByNetwork200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationByNetworkAsync
     *
     * Get average channel utilization across all bands for all networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByNetworkAsync($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'][0])
    {
        return $this->getOrganizationWirelessDevicesChannelUtilizationByNetworkAsyncWithHttpInfo($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationByNetworkAsyncWithHttpInfo
     *
     * Get average channel utilization across all bands for all networks in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByNetworkAsyncWithHttpInfo($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationByNetwork200ResponseInner[]';
        $request = $this->getOrganizationWirelessDevicesChannelUtilizationByNetworkRequest($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesChannelUtilizationByNetwork'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesChannelUtilizationByNetworkRequest($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationByNetwork'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesChannelUtilizationByNetwork'
            );
        }








        if ($timespan !== null && $timespan > 7776000) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesChannelUtilizationByNetwork, must be smaller than or equal to 7776000.');
        }
        


        $resourcePath = '/organizations/{organizationId}/wireless/devices/channelUtilization/byNetwork';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval
     *
     * Get a time-series of average channel utilization for all bands, segmented by device.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval200ResponseInner[]
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalWithHttpInfo($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalWithHttpInfo
     *
     * Get a time-series of average channel utilization for all bands, segmented by device.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalWithHttpInfo($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'][0])
    {
        $request = $this->getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalRequest($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalAsync
     *
     * Get a time-series of average channel utilization for all bands, segmented by device.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalAsync($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'][0])
    {
        return $this->getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalAsyncWithHttpInfo($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalAsyncWithHttpInfo
     *
     * Get a time-series of average channel utilization for all bands, segmented by device.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalAsyncWithHttpInfo($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval200ResponseInner[]';
        $request = $this->getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalRequest($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalRequest($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval'
            );
        }








        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesChannelUtilizationHistoryByDeviceByInterval, must be smaller than or equal to 2678400.');
        }
        


        $resourcePath = '/organizations/{organizationId}/wireless/devices/channelUtilization/history/byDevice/byInterval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval
     *
     * Get a time-series of average channel utilization for all bands
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval200ResponseInner[]
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalWithHttpInfo($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalWithHttpInfo
     *
     * Get a time-series of average channel utilization for all bands
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalWithHttpInfo($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'][0])
    {
        $request = $this->getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalRequest($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalAsync
     *
     * Get a time-series of average channel utilization for all bands
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalAsync($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'][0])
    {
        return $this->getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalAsyncWithHttpInfo($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalAsyncWithHttpInfo
     *
     * Get a time-series of average channel utilization for all bands
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalAsyncWithHttpInfo($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval200ResponseInner[]';
        $request = $this->getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalRequest($organization_id, $network_ids, $serials, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $interval, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int|null $interval The time interval in seconds for returned data. The valid intervals are: 300, 600, 3600, 7200, 14400, 21600. The default is 3600. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalRequest($organization_id, $network_ids = null, $serials = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $interval = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval'
            );
        }








        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesChannelUtilizationHistoryByNetworkByInterval, must be smaller than or equal to 2678400.');
        }
        


        $resourcePath = '/organizations/{organizationId}/wireless/devices/channelUtilization/history/byNetwork/byInterval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesEthernetStatuses
     *
     * List the most recent Ethernet link speed, duplex, aggregation and power mode and status information for wireless devices.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner[]
     */
    public function getOrganizationWirelessDevicesEthernetStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesEthernetStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesEthernetStatusesWithHttpInfo
     *
     * List the most recent Ethernet link speed, duplex, aggregation and power mode and status information for wireless devices.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesEthernetStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'][0])
    {
        $request = $this->getOrganizationWirelessDevicesEthernetStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesEthernetStatusesAsync
     *
     * List the most recent Ethernet link speed, duplex, aggregation and power mode and status information for wireless devices.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesEthernetStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'][0])
    {
        return $this->getOrganizationWirelessDevicesEthernetStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesEthernetStatusesAsyncWithHttpInfo
     *
     * List the most recent Ethernet link speed, duplex, aggregation and power mode and status information for wireless devices.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesEthernetStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesEthernetStatuses200ResponseInner[]';
        $request = $this->getOrganizationWirelessDevicesEthernetStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesEthernetStatuses'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesEthernetStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesEthernetStatuses'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesEthernetStatuses'
            );
        }






        $resourcePath = '/organizations/{organizationId}/wireless/devices/ethernet/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByClient
     *
     * Get average packet loss for the given timespan for all clients in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  string[]|null $macs Filter results by client mac address(es). (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesPacketLossByClient200ResponseInner[]
     */
    public function getOrganizationWirelessDevicesPacketLossByClient($organization_id, $network_ids = null, $ssids = null, $bands = null, $macs = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesPacketLossByClientWithHttpInfo($organization_id, $network_ids, $ssids, $bands, $macs, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByClientWithHttpInfo
     *
     * Get average packet loss for the given timespan for all clients in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  string[]|null $macs Filter results by client mac address(es). (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesPacketLossByClient200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesPacketLossByClientWithHttpInfo($organization_id, $network_ids = null, $ssids = null, $bands = null, $macs = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'][0])
    {
        $request = $this->getOrganizationWirelessDevicesPacketLossByClientRequest($organization_id, $network_ids, $ssids, $bands, $macs, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByClient200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByClient200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByClient200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByClient200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByClient200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByClientAsync
     *
     * Get average packet loss for the given timespan for all clients in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  string[]|null $macs Filter results by client mac address(es). (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesPacketLossByClientAsync($organization_id, $network_ids = null, $ssids = null, $bands = null, $macs = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'][0])
    {
        return $this->getOrganizationWirelessDevicesPacketLossByClientAsyncWithHttpInfo($organization_id, $network_ids, $ssids, $bands, $macs, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByClientAsyncWithHttpInfo
     *
     * Get average packet loss for the given timespan for all clients in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  string[]|null $macs Filter results by client mac address(es). (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesPacketLossByClientAsyncWithHttpInfo($organization_id, $network_ids = null, $ssids = null, $bands = null, $macs = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByClient200ResponseInner[]';
        $request = $this->getOrganizationWirelessDevicesPacketLossByClientRequest($organization_id, $network_ids, $ssids, $bands, $macs, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesPacketLossByClient'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  string[]|null $macs Filter results by client mac address(es). (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesPacketLossByClientRequest($organization_id, $network_ids = null, $ssids = null, $bands = null, $macs = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByClient'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesPacketLossByClient'
            );
        }










        if ($timespan !== null && $timespan > 7776000) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesPacketLossByClient, must be smaller than or equal to 7776000.');
        }
        if ($timespan !== null && $timespan < 300) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesPacketLossByClient, must be bigger than or equal to 300.');
        }
        

        $resourcePath = '/organizations/{organizationId}/wireless/devices/packetLoss/byClient';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssids,
            'ssids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bands,
            'bands', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $macs,
            'macs', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByDevice
     *
     * Get average packet loss for the given timespan for all devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesPacketLossByDevice200ResponseInner[]
     */
    public function getOrganizationWirelessDevicesPacketLossByDevice($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesPacketLossByDeviceWithHttpInfo($organization_id, $network_ids, $serials, $ssids, $bands, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByDeviceWithHttpInfo
     *
     * Get average packet loss for the given timespan for all devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesPacketLossByDevice200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesPacketLossByDeviceWithHttpInfo($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'][0])
    {
        $request = $this->getOrganizationWirelessDevicesPacketLossByDeviceRequest($organization_id, $network_ids, $serials, $ssids, $bands, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByDevice200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByDevice200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByDevice200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByDevice200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByDevice200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByDeviceAsync
     *
     * Get average packet loss for the given timespan for all devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesPacketLossByDeviceAsync($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'][0])
    {
        return $this->getOrganizationWirelessDevicesPacketLossByDeviceAsyncWithHttpInfo($organization_id, $network_ids, $serials, $ssids, $bands, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByDeviceAsyncWithHttpInfo
     *
     * Get average packet loss for the given timespan for all devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesPacketLossByDeviceAsyncWithHttpInfo($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByDevice200ResponseInner[]';
        $request = $this->getOrganizationWirelessDevicesPacketLossByDeviceRequest($organization_id, $network_ids, $serials, $ssids, $bands, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesPacketLossByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesPacketLossByDeviceRequest($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesPacketLossByDevice'
            );
        }










        if ($timespan !== null && $timespan > 7776000) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesPacketLossByDevice, must be smaller than or equal to 7776000.');
        }
        if ($timespan !== null && $timespan < 300) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesPacketLossByDevice, must be bigger than or equal to 300.');
        }
        

        $resourcePath = '/organizations/{organizationId}/wireless/devices/packetLoss/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssids,
            'ssids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bands,
            'bands', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByNetwork
     *
     * Get average packet loss for the given timespan for all networks in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesPacketLossByNetwork200ResponseInner[]
     */
    public function getOrganizationWirelessDevicesPacketLossByNetwork($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesPacketLossByNetworkWithHttpInfo($organization_id, $network_ids, $serials, $ssids, $bands, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByNetworkWithHttpInfo
     *
     * Get average packet loss for the given timespan for all networks in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesPacketLossByNetwork200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesPacketLossByNetworkWithHttpInfo($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'][0])
    {
        $request = $this->getOrganizationWirelessDevicesPacketLossByNetworkRequest($organization_id, $network_ids, $serials, $ssids, $bands, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByNetwork200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByNetwork200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByNetwork200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByNetwork200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByNetwork200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByNetworkAsync
     *
     * Get average packet loss for the given timespan for all networks in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesPacketLossByNetworkAsync($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'][0])
    {
        return $this->getOrganizationWirelessDevicesPacketLossByNetworkAsyncWithHttpInfo($organization_id, $network_ids, $serials, $ssids, $bands, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesPacketLossByNetworkAsyncWithHttpInfo
     *
     * Get average packet loss for the given timespan for all networks in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesPacketLossByNetworkAsyncWithHttpInfo($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesPacketLossByNetwork200ResponseInner[]';
        $request = $this->getOrganizationWirelessDevicesPacketLossByNetworkRequest($organization_id, $network_ids, $serials, $ssids, $bands, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesPacketLossByNetwork'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Filter results by network. (optional)
     * @param  string[]|null $serials Filter results by device. (optional)
     * @param  int[]|null $ssids Filter results by SSID number. (optional)
     * @param  string[]|null $bands Filter results by band. Valid bands are: 2.4, 5, and 6. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 90 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 5 minutes and be less than or equal to 90 days. The default is 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesPacketLossByNetworkRequest($organization_id, $network_ids = null, $serials = null, $ssids = null, $bands = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPacketLossByNetwork'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesPacketLossByNetwork'
            );
        }










        if ($timespan !== null && $timespan > 7776000) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesPacketLossByNetwork, must be smaller than or equal to 7776000.');
        }
        if ($timespan !== null && $timespan < 300) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesPacketLossByNetwork, must be bigger than or equal to 300.');
        }
        

        $resourcePath = '/organizations/{organizationId}/wireless/devices/packetLoss/byNetwork';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ssids,
            'ssids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bands,
            'bands', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesPowerModeHistory
     *
     * Return a record of power mode changes for wireless devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesPowerModeHistory200Response
     */
    public function getOrganizationWirelessDevicesPowerModeHistory($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesPowerModeHistoryWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_ids, $serials, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesPowerModeHistoryWithHttpInfo
     *
     * Return a record of power mode changes for wireless devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesPowerModeHistory200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesPowerModeHistoryWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'][0])
    {
        $request = $this->getOrganizationWirelessDevicesPowerModeHistoryRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_ids, $serials, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesPowerModeHistory200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesPowerModeHistory200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesPowerModeHistory200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesPowerModeHistory200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesPowerModeHistory200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesPowerModeHistoryAsync
     *
     * Return a record of power mode changes for wireless devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesPowerModeHistoryAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'][0])
    {
        return $this->getOrganizationWirelessDevicesPowerModeHistoryAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_ids, $serials, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesPowerModeHistoryAsyncWithHttpInfo
     *
     * Return a record of power mode changes for wireless devices in the organization
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesPowerModeHistoryAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesPowerModeHistory200Response';
        $request = $this->getOrganizationWirelessDevicesPowerModeHistoryRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_ids, $serials, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesPowerModeHistory'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesPowerModeHistoryRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesPowerModeHistory'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesPowerModeHistory'
            );
        }



        if ($timespan !== null && $timespan > 86400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesPowerModeHistory, must be smaller than or equal to 86400.');
        }
        






        $resourcePath = '/organizations/{organizationId}/wireless/devices/power/mode/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesSystemCpuLoadHistory
     *
     * Return the CPU Load history for a list of wireless devices in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesSystemCpuLoadHistory200Response
     */
    public function getOrganizationWirelessDevicesSystemCpuLoadHistory($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesSystemCpuLoadHistoryWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_ids, $serials, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesSystemCpuLoadHistoryWithHttpInfo
     *
     * Return the CPU Load history for a list of wireless devices in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesSystemCpuLoadHistory200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesSystemCpuLoadHistoryWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'][0])
    {
        $request = $this->getOrganizationWirelessDevicesSystemCpuLoadHistoryRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_ids, $serials, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesSystemCpuLoadHistory200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesSystemCpuLoadHistory200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesSystemCpuLoadHistory200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesSystemCpuLoadHistory200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesSystemCpuLoadHistory200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesSystemCpuLoadHistoryAsync
     *
     * Return the CPU Load history for a list of wireless devices in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesSystemCpuLoadHistoryAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'][0])
    {
        return $this->getOrganizationWirelessDevicesSystemCpuLoadHistoryAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_ids, $serials, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesSystemCpuLoadHistoryAsyncWithHttpInfo
     *
     * Return the CPU Load history for a list of wireless devices in the organization.
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesSystemCpuLoadHistoryAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesSystemCpuLoadHistory200Response';
        $request = $this->getOrganizationWirelessDevicesSystemCpuLoadHistoryRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_ids, $serials, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesSystemCpuLoadHistory'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 1 day after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 20. Default is 10. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[]|null $network_ids Optional parameter to filter the result set by the included set of network IDs (optional)
     * @param  string[]|null $serials Optional parameter to filter device availabilities history by device serial numbers (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesSystemCpuLoadHistoryRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesSystemCpuLoadHistory'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesSystemCpuLoadHistory'
            );
        }



        if ($timespan !== null && $timespan > 86400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling DevicesApi.getOrganizationWirelessDevicesSystemCpuLoadHistory, must be smaller than or equal to 86400.');
        }
        






        $resourcePath = '/organizations/{organizationId}/wireless/devices/system/cpu/load/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWirelessDevicesWirelessControllersByDevice
     *
     * List of Catalyst access points information
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $controller_serials Optional parameter to filter access points by its wireless LAN controller cloud ID. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWirelessDevicesWirelessControllersByDevice200Response
     */
    public function getOrganizationWirelessDevicesWirelessControllersByDevice($organization_id, $network_ids = null, $serials = null, $controller_serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'][0])
    {
        list($response) = $this->getOrganizationWirelessDevicesWirelessControllersByDeviceWithHttpInfo($organization_id, $network_ids, $serials, $controller_serials, $per_page, $starting_after, $ending_before, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWirelessDevicesWirelessControllersByDeviceWithHttpInfo
     *
     * List of Catalyst access points information
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $controller_serials Optional parameter to filter access points by its wireless LAN controller cloud ID. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWirelessDevicesWirelessControllersByDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWirelessDevicesWirelessControllersByDeviceWithHttpInfo($organization_id, $network_ids = null, $serials = null, $controller_serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'][0])
    {
        $request = $this->getOrganizationWirelessDevicesWirelessControllersByDeviceRequest($organization_id, $network_ids, $serials, $controller_serials, $per_page, $starting_after, $ending_before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWirelessDevicesWirelessControllersByDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWirelessDevicesWirelessControllersByDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWirelessDevicesWirelessControllersByDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesWirelessControllersByDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWirelessDevicesWirelessControllersByDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWirelessDevicesWirelessControllersByDeviceAsync
     *
     * List of Catalyst access points information
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $controller_serials Optional parameter to filter access points by its wireless LAN controller cloud ID. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesWirelessControllersByDeviceAsync($organization_id, $network_ids = null, $serials = null, $controller_serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'][0])
    {
        return $this->getOrganizationWirelessDevicesWirelessControllersByDeviceAsyncWithHttpInfo($organization_id, $network_ids, $serials, $controller_serials, $per_page, $starting_after, $ending_before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWirelessDevicesWirelessControllersByDeviceAsyncWithHttpInfo
     *
     * List of Catalyst access points information
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $controller_serials Optional parameter to filter access points by its wireless LAN controller cloud ID. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWirelessDevicesWirelessControllersByDeviceAsyncWithHttpInfo($organization_id, $network_ids = null, $serials = null, $controller_serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWirelessDevicesWirelessControllersByDevice200Response';
        $request = $this->getOrganizationWirelessDevicesWirelessControllersByDeviceRequest($organization_id, $network_ids, $serials, $controller_serials, $per_page, $starting_after, $ending_before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWirelessDevicesWirelessControllersByDevice'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string[]|null $network_ids Optional parameter to filter access points by network ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $serials Optional parameter to filter access points by its cloud ID. This filter uses multiple exact matches. (optional)
     * @param  string[]|null $controller_serials Optional parameter to filter access points by its wireless LAN controller cloud ID. This filter uses multiple exact matches. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWirelessDevicesWirelessControllersByDeviceRequest($organization_id, $network_ids = null, $serials = null, $controller_serials = null, $per_page = null, $starting_after = null, $ending_before = null, string $contentType = self::contentTypes['getOrganizationWirelessDevicesWirelessControllersByDevice'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWirelessDevicesWirelessControllersByDevice'
            );
        }








        $resourcePath = '/organizations/{organizationId}/wireless/devices/wirelessControllers/byDevice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network_ids,
            'networkIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $serials,
            'serials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $controller_serials,
            'controllerSerials', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation installNetworkSmDeviceApps
     *
     * Install applications on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\InstallNetworkSmDeviceAppsRequest $install_network_sm_device_apps_request install_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function installNetworkSmDeviceApps($network_id, $device_id, $install_network_sm_device_apps_request, string $contentType = self::contentTypes['installNetworkSmDeviceApps'][0])
    {
        list($response) = $this->installNetworkSmDeviceAppsWithHttpInfo($network_id, $device_id, $install_network_sm_device_apps_request, $contentType);
        return $response;
    }

    /**
     * Operation installNetworkSmDeviceAppsWithHttpInfo
     *
     * Install applications on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\InstallNetworkSmDeviceAppsRequest $install_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function installNetworkSmDeviceAppsWithHttpInfo($network_id, $device_id, $install_network_sm_device_apps_request, string $contentType = self::contentTypes['installNetworkSmDeviceApps'][0])
    {
        $request = $this->installNetworkSmDeviceAppsRequest($network_id, $device_id, $install_network_sm_device_apps_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation installNetworkSmDeviceAppsAsync
     *
     * Install applications on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\InstallNetworkSmDeviceAppsRequest $install_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function installNetworkSmDeviceAppsAsync($network_id, $device_id, $install_network_sm_device_apps_request, string $contentType = self::contentTypes['installNetworkSmDeviceApps'][0])
    {
        return $this->installNetworkSmDeviceAppsAsyncWithHttpInfo($network_id, $device_id, $install_network_sm_device_apps_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation installNetworkSmDeviceAppsAsyncWithHttpInfo
     *
     * Install applications on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\InstallNetworkSmDeviceAppsRequest $install_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function installNetworkSmDeviceAppsAsyncWithHttpInfo($network_id, $device_id, $install_network_sm_device_apps_request, string $contentType = self::contentTypes['installNetworkSmDeviceApps'][0])
    {
        $returnType = 'object';
        $request = $this->installNetworkSmDeviceAppsRequest($network_id, $device_id, $install_network_sm_device_apps_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'installNetworkSmDeviceApps'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\InstallNetworkSmDeviceAppsRequest $install_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['installNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function installNetworkSmDeviceAppsRequest($network_id, $device_id, $install_network_sm_device_apps_request, string $contentType = self::contentTypes['installNetworkSmDeviceApps'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling installNetworkSmDeviceApps'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling installNetworkSmDeviceApps'
            );
        }

        // verify the required parameter 'install_network_sm_device_apps_request' is set
        if ($install_network_sm_device_apps_request === null || (is_array($install_network_sm_device_apps_request) && count($install_network_sm_device_apps_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $install_network_sm_device_apps_request when calling installNetworkSmDeviceApps'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/installApps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($install_network_sm_device_apps_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($install_network_sm_device_apps_request));
            } else {
                $httpBody = $install_network_sm_device_apps_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockNetworkSmDevices
     *
     * Lock a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\LockNetworkSmDevicesRequest|null $lock_network_sm_devices_request lock_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CheckinNetworkSmDevices200Response
     */
    public function lockNetworkSmDevices($network_id, $lock_network_sm_devices_request = null, string $contentType = self::contentTypes['lockNetworkSmDevices'][0])
    {
        list($response) = $this->lockNetworkSmDevicesWithHttpInfo($network_id, $lock_network_sm_devices_request, $contentType);
        return $response;
    }

    /**
     * Operation lockNetworkSmDevicesWithHttpInfo
     *
     * Lock a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\LockNetworkSmDevicesRequest|null $lock_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CheckinNetworkSmDevices200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function lockNetworkSmDevicesWithHttpInfo($network_id, $lock_network_sm_devices_request = null, string $contentType = self::contentTypes['lockNetworkSmDevices'][0])
    {
        $request = $this->lockNetworkSmDevicesRequest($network_id, $lock_network_sm_devices_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CheckinNetworkSmDevices200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CheckinNetworkSmDevices200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CheckinNetworkSmDevices200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CheckinNetworkSmDevices200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CheckinNetworkSmDevices200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lockNetworkSmDevicesAsync
     *
     * Lock a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\LockNetworkSmDevicesRequest|null $lock_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockNetworkSmDevicesAsync($network_id, $lock_network_sm_devices_request = null, string $contentType = self::contentTypes['lockNetworkSmDevices'][0])
    {
        return $this->lockNetworkSmDevicesAsyncWithHttpInfo($network_id, $lock_network_sm_devices_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lockNetworkSmDevicesAsyncWithHttpInfo
     *
     * Lock a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\LockNetworkSmDevicesRequest|null $lock_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockNetworkSmDevicesAsyncWithHttpInfo($network_id, $lock_network_sm_devices_request = null, string $contentType = self::contentTypes['lockNetworkSmDevices'][0])
    {
        $returnType = '\Meraki\Model\CheckinNetworkSmDevices200Response';
        $request = $this->lockNetworkSmDevicesRequest($network_id, $lock_network_sm_devices_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lockNetworkSmDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\LockNetworkSmDevicesRequest|null $lock_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lockNetworkSmDevicesRequest($network_id, $lock_network_sm_devices_request = null, string $contentType = self::contentTypes['lockNetworkSmDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling lockNetworkSmDevices'
            );
        }



        $resourcePath = '/networks/{networkId}/sm/devices/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($lock_network_sm_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($lock_network_sm_devices_request));
            } else {
                $httpBody = $lock_network_sm_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modifyNetworkSmDevicesTags
     *
     * Add, delete, or update the tags of a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ModifyNetworkSmDevicesTagsRequest $modify_network_sm_devices_tags_request modify_network_sm_devices_tags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyNetworkSmDevicesTags'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\ModifyNetworkSmDevicesTags200ResponseInner[]
     */
    public function modifyNetworkSmDevicesTags($network_id, $modify_network_sm_devices_tags_request, string $contentType = self::contentTypes['modifyNetworkSmDevicesTags'][0])
    {
        list($response) = $this->modifyNetworkSmDevicesTagsWithHttpInfo($network_id, $modify_network_sm_devices_tags_request, $contentType);
        return $response;
    }

    /**
     * Operation modifyNetworkSmDevicesTagsWithHttpInfo
     *
     * Add, delete, or update the tags of a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ModifyNetworkSmDevicesTagsRequest $modify_network_sm_devices_tags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyNetworkSmDevicesTags'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\ModifyNetworkSmDevicesTags200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function modifyNetworkSmDevicesTagsWithHttpInfo($network_id, $modify_network_sm_devices_tags_request, string $contentType = self::contentTypes['modifyNetworkSmDevicesTags'][0])
    {
        $request = $this->modifyNetworkSmDevicesTagsRequest($network_id, $modify_network_sm_devices_tags_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\ModifyNetworkSmDevicesTags200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\ModifyNetworkSmDevicesTags200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\ModifyNetworkSmDevicesTags200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\ModifyNetworkSmDevicesTags200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\ModifyNetworkSmDevicesTags200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modifyNetworkSmDevicesTagsAsync
     *
     * Add, delete, or update the tags of a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ModifyNetworkSmDevicesTagsRequest $modify_network_sm_devices_tags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyNetworkSmDevicesTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyNetworkSmDevicesTagsAsync($network_id, $modify_network_sm_devices_tags_request, string $contentType = self::contentTypes['modifyNetworkSmDevicesTags'][0])
    {
        return $this->modifyNetworkSmDevicesTagsAsyncWithHttpInfo($network_id, $modify_network_sm_devices_tags_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modifyNetworkSmDevicesTagsAsyncWithHttpInfo
     *
     * Add, delete, or update the tags of a set of devices
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ModifyNetworkSmDevicesTagsRequest $modify_network_sm_devices_tags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyNetworkSmDevicesTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyNetworkSmDevicesTagsAsyncWithHttpInfo($network_id, $modify_network_sm_devices_tags_request, string $contentType = self::contentTypes['modifyNetworkSmDevicesTags'][0])
    {
        $returnType = '\Meraki\Model\ModifyNetworkSmDevicesTags200ResponseInner[]';
        $request = $this->modifyNetworkSmDevicesTagsRequest($network_id, $modify_network_sm_devices_tags_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modifyNetworkSmDevicesTags'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ModifyNetworkSmDevicesTagsRequest $modify_network_sm_devices_tags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyNetworkSmDevicesTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modifyNetworkSmDevicesTagsRequest($network_id, $modify_network_sm_devices_tags_request, string $contentType = self::contentTypes['modifyNetworkSmDevicesTags'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling modifyNetworkSmDevicesTags'
            );
        }

        // verify the required parameter 'modify_network_sm_devices_tags_request' is set
        if ($modify_network_sm_devices_tags_request === null || (is_array($modify_network_sm_devices_tags_request) && count($modify_network_sm_devices_tags_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modify_network_sm_devices_tags_request when calling modifyNetworkSmDevicesTags'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/modifyTags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modify_network_sm_devices_tags_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modify_network_sm_devices_tags_request));
            } else {
                $httpBody = $modify_network_sm_devices_tags_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation moveNetworkSmDevices
     *
     * Move a set of devices to a new network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\MoveNetworkSmDevicesRequest $move_network_sm_devices_request move_network_sm_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\MoveNetworkSmDevices200Response
     */
    public function moveNetworkSmDevices($network_id, $move_network_sm_devices_request, string $contentType = self::contentTypes['moveNetworkSmDevices'][0])
    {
        list($response) = $this->moveNetworkSmDevicesWithHttpInfo($network_id, $move_network_sm_devices_request, $contentType);
        return $response;
    }

    /**
     * Operation moveNetworkSmDevicesWithHttpInfo
     *
     * Move a set of devices to a new network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\MoveNetworkSmDevicesRequest $move_network_sm_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\MoveNetworkSmDevices200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveNetworkSmDevicesWithHttpInfo($network_id, $move_network_sm_devices_request, string $contentType = self::contentTypes['moveNetworkSmDevices'][0])
    {
        $request = $this->moveNetworkSmDevicesRequest($network_id, $move_network_sm_devices_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\MoveNetworkSmDevices200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\MoveNetworkSmDevices200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\MoveNetworkSmDevices200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\MoveNetworkSmDevices200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\MoveNetworkSmDevices200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation moveNetworkSmDevicesAsync
     *
     * Move a set of devices to a new network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\MoveNetworkSmDevicesRequest $move_network_sm_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveNetworkSmDevicesAsync($network_id, $move_network_sm_devices_request, string $contentType = self::contentTypes['moveNetworkSmDevices'][0])
    {
        return $this->moveNetworkSmDevicesAsyncWithHttpInfo($network_id, $move_network_sm_devices_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveNetworkSmDevicesAsyncWithHttpInfo
     *
     * Move a set of devices to a new network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\MoveNetworkSmDevicesRequest $move_network_sm_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveNetworkSmDevicesAsyncWithHttpInfo($network_id, $move_network_sm_devices_request, string $contentType = self::contentTypes['moveNetworkSmDevices'][0])
    {
        $returnType = '\Meraki\Model\MoveNetworkSmDevices200Response';
        $request = $this->moveNetworkSmDevicesRequest($network_id, $move_network_sm_devices_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'moveNetworkSmDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\MoveNetworkSmDevicesRequest $move_network_sm_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function moveNetworkSmDevicesRequest($network_id, $move_network_sm_devices_request, string $contentType = self::contentTypes['moveNetworkSmDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling moveNetworkSmDevices'
            );
        }

        // verify the required parameter 'move_network_sm_devices_request' is set
        if ($move_network_sm_devices_request === null || (is_array($move_network_sm_devices_request) && count($move_network_sm_devices_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $move_network_sm_devices_request when calling moveNetworkSmDevices'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($move_network_sm_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($move_network_sm_devices_request));
            } else {
                $httpBody = $move_network_sm_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rebootDevice
     *
     * Reboot a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\RebootDevice202Response
     */
    public function rebootDevice($serial, string $contentType = self::contentTypes['rebootDevice'][0])
    {
        list($response) = $this->rebootDeviceWithHttpInfo($serial, $contentType);
        return $response;
    }

    /**
     * Operation rebootDeviceWithHttpInfo
     *
     * Reboot a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\RebootDevice202Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function rebootDeviceWithHttpInfo($serial, string $contentType = self::contentTypes['rebootDevice'][0])
    {
        $request = $this->rebootDeviceRequest($serial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\Meraki\Model\RebootDevice202Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\RebootDevice202Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\RebootDevice202Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\RebootDevice202Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\RebootDevice202Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rebootDeviceAsync
     *
     * Reboot a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebootDeviceAsync($serial, string $contentType = self::contentTypes['rebootDevice'][0])
    {
        return $this->rebootDeviceAsyncWithHttpInfo($serial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rebootDeviceAsyncWithHttpInfo
     *
     * Reboot a device
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebootDeviceAsyncWithHttpInfo($serial, string $contentType = self::contentTypes['rebootDevice'][0])
    {
        $returnType = '\Meraki\Model\RebootDevice202Response';
        $request = $this->rebootDeviceRequest($serial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rebootDevice'
     *
     * @param  string $serial Serial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function rebootDeviceRequest($serial, string $contentType = self::contentTypes['rebootDevice'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling rebootDevice'
            );
        }


        $resourcePath = '/devices/{serial}/reboot';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rebootNetworkSmDevices
     *
     * Reboot a set of endpoints
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RebootNetworkSmDevicesRequest|null $reboot_network_sm_devices_request reboot_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\RebootNetworkSmDevices200Response
     */
    public function rebootNetworkSmDevices($network_id, $reboot_network_sm_devices_request = null, string $contentType = self::contentTypes['rebootNetworkSmDevices'][0])
    {
        list($response) = $this->rebootNetworkSmDevicesWithHttpInfo($network_id, $reboot_network_sm_devices_request, $contentType);
        return $response;
    }

    /**
     * Operation rebootNetworkSmDevicesWithHttpInfo
     *
     * Reboot a set of endpoints
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RebootNetworkSmDevicesRequest|null $reboot_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\RebootNetworkSmDevices200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function rebootNetworkSmDevicesWithHttpInfo($network_id, $reboot_network_sm_devices_request = null, string $contentType = self::contentTypes['rebootNetworkSmDevices'][0])
    {
        $request = $this->rebootNetworkSmDevicesRequest($network_id, $reboot_network_sm_devices_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\RebootNetworkSmDevices200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\RebootNetworkSmDevices200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\RebootNetworkSmDevices200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\RebootNetworkSmDevices200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\RebootNetworkSmDevices200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation rebootNetworkSmDevicesAsync
     *
     * Reboot a set of endpoints
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RebootNetworkSmDevicesRequest|null $reboot_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebootNetworkSmDevicesAsync($network_id, $reboot_network_sm_devices_request = null, string $contentType = self::contentTypes['rebootNetworkSmDevices'][0])
    {
        return $this->rebootNetworkSmDevicesAsyncWithHttpInfo($network_id, $reboot_network_sm_devices_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rebootNetworkSmDevicesAsyncWithHttpInfo
     *
     * Reboot a set of endpoints
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RebootNetworkSmDevicesRequest|null $reboot_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rebootNetworkSmDevicesAsyncWithHttpInfo($network_id, $reboot_network_sm_devices_request = null, string $contentType = self::contentTypes['rebootNetworkSmDevices'][0])
    {
        $returnType = '\Meraki\Model\RebootNetworkSmDevices200Response';
        $request = $this->rebootNetworkSmDevicesRequest($network_id, $reboot_network_sm_devices_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rebootNetworkSmDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RebootNetworkSmDevicesRequest|null $reboot_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rebootNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function rebootNetworkSmDevicesRequest($network_id, $reboot_network_sm_devices_request = null, string $contentType = self::contentTypes['rebootNetworkSmDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling rebootNetworkSmDevices'
            );
        }



        $resourcePath = '/networks/{networkId}/sm/devices/reboot';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reboot_network_sm_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reboot_network_sm_devices_request));
            } else {
                $httpBody = $reboot_network_sm_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation refreshNetworkSmDeviceDetails
     *
     * Refresh the details of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshNetworkSmDeviceDetails'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function refreshNetworkSmDeviceDetails($network_id, $device_id, string $contentType = self::contentTypes['refreshNetworkSmDeviceDetails'][0])
    {
        list($response) = $this->refreshNetworkSmDeviceDetailsWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation refreshNetworkSmDeviceDetailsWithHttpInfo
     *
     * Refresh the details of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshNetworkSmDeviceDetails'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function refreshNetworkSmDeviceDetailsWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['refreshNetworkSmDeviceDetails'][0])
    {
        $request = $this->refreshNetworkSmDeviceDetailsRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refreshNetworkSmDeviceDetailsAsync
     *
     * Refresh the details of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshNetworkSmDeviceDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refreshNetworkSmDeviceDetailsAsync($network_id, $device_id, string $contentType = self::contentTypes['refreshNetworkSmDeviceDetails'][0])
    {
        return $this->refreshNetworkSmDeviceDetailsAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refreshNetworkSmDeviceDetailsAsyncWithHttpInfo
     *
     * Refresh the details of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshNetworkSmDeviceDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refreshNetworkSmDeviceDetailsAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['refreshNetworkSmDeviceDetails'][0])
    {
        $returnType = 'object';
        $request = $this->refreshNetworkSmDeviceDetailsRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refreshNetworkSmDeviceDetails'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshNetworkSmDeviceDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refreshNetworkSmDeviceDetailsRequest($network_id, $device_id, string $contentType = self::contentTypes['refreshNetworkSmDeviceDetails'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling refreshNetworkSmDeviceDetails'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling refreshNetworkSmDeviceDetails'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/refreshDetails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeNetworkDevices
     *
     * Remove a single device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeNetworkDevices($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {
        $this->removeNetworkDevicesWithHttpInfo($network_id, $remove_network_devices_request, $contentType);
    }

    /**
     * Operation removeNetworkDevicesWithHttpInfo
     *
     * Remove a single device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeNetworkDevicesWithHttpInfo($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {
        $request = $this->removeNetworkDevicesRequest($network_id, $remove_network_devices_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeNetworkDevicesAsync
     *
     * Remove a single device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeNetworkDevicesAsync($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {
        return $this->removeNetworkDevicesAsyncWithHttpInfo($network_id, $remove_network_devices_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeNetworkDevicesAsyncWithHttpInfo
     *
     * Remove a single device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeNetworkDevicesAsyncWithHttpInfo($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {
        $returnType = '';
        $request = $this->removeNetworkDevicesRequest($network_id, $remove_network_devices_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeNetworkDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\RemoveNetworkDevicesRequest $remove_network_devices_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeNetworkDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeNetworkDevicesRequest($network_id, $remove_network_devices_request, string $contentType = self::contentTypes['removeNetworkDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling removeNetworkDevices'
            );
        }

        // verify the required parameter 'remove_network_devices_request' is set
        if ($remove_network_devices_request === null || (is_array($remove_network_devices_request) && count($remove_network_devices_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_network_devices_request when calling removeNetworkDevices'
            );
        }


        $resourcePath = '/networks/{networkId}/devices/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($remove_network_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($remove_network_devices_request));
            } else {
                $httpBody = $remove_network_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shutdownNetworkSmDevices
     *
     * Shutdown a set of endpoints
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ShutdownNetworkSmDevicesRequest|null $shutdown_network_sm_devices_request shutdown_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shutdownNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\RebootNetworkSmDevices200Response
     */
    public function shutdownNetworkSmDevices($network_id, $shutdown_network_sm_devices_request = null, string $contentType = self::contentTypes['shutdownNetworkSmDevices'][0])
    {
        list($response) = $this->shutdownNetworkSmDevicesWithHttpInfo($network_id, $shutdown_network_sm_devices_request, $contentType);
        return $response;
    }

    /**
     * Operation shutdownNetworkSmDevicesWithHttpInfo
     *
     * Shutdown a set of endpoints
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ShutdownNetworkSmDevicesRequest|null $shutdown_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shutdownNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\RebootNetworkSmDevices200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function shutdownNetworkSmDevicesWithHttpInfo($network_id, $shutdown_network_sm_devices_request = null, string $contentType = self::contentTypes['shutdownNetworkSmDevices'][0])
    {
        $request = $this->shutdownNetworkSmDevicesRequest($network_id, $shutdown_network_sm_devices_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\RebootNetworkSmDevices200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\RebootNetworkSmDevices200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\RebootNetworkSmDevices200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\RebootNetworkSmDevices200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\RebootNetworkSmDevices200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shutdownNetworkSmDevicesAsync
     *
     * Shutdown a set of endpoints
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ShutdownNetworkSmDevicesRequest|null $shutdown_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shutdownNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shutdownNetworkSmDevicesAsync($network_id, $shutdown_network_sm_devices_request = null, string $contentType = self::contentTypes['shutdownNetworkSmDevices'][0])
    {
        return $this->shutdownNetworkSmDevicesAsyncWithHttpInfo($network_id, $shutdown_network_sm_devices_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shutdownNetworkSmDevicesAsyncWithHttpInfo
     *
     * Shutdown a set of endpoints
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ShutdownNetworkSmDevicesRequest|null $shutdown_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shutdownNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shutdownNetworkSmDevicesAsyncWithHttpInfo($network_id, $shutdown_network_sm_devices_request = null, string $contentType = self::contentTypes['shutdownNetworkSmDevices'][0])
    {
        $returnType = '\Meraki\Model\RebootNetworkSmDevices200Response';
        $request = $this->shutdownNetworkSmDevicesRequest($network_id, $shutdown_network_sm_devices_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shutdownNetworkSmDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\ShutdownNetworkSmDevicesRequest|null $shutdown_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['shutdownNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function shutdownNetworkSmDevicesRequest($network_id, $shutdown_network_sm_devices_request = null, string $contentType = self::contentTypes['shutdownNetworkSmDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling shutdownNetworkSmDevices'
            );
        }



        $resourcePath = '/networks/{networkId}/sm/devices/shutdown';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($shutdown_network_sm_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($shutdown_network_sm_devices_request));
            } else {
                $httpBody = $shutdown_network_sm_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unenrollNetworkSmDevice
     *
     * Unenroll a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unenrollNetworkSmDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\UnenrollNetworkSmDevice200Response
     */
    public function unenrollNetworkSmDevice($network_id, $device_id, string $contentType = self::contentTypes['unenrollNetworkSmDevice'][0])
    {
        list($response) = $this->unenrollNetworkSmDeviceWithHttpInfo($network_id, $device_id, $contentType);
        return $response;
    }

    /**
     * Operation unenrollNetworkSmDeviceWithHttpInfo
     *
     * Unenroll a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unenrollNetworkSmDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\UnenrollNetworkSmDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function unenrollNetworkSmDeviceWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['unenrollNetworkSmDevice'][0])
    {
        $request = $this->unenrollNetworkSmDeviceRequest($network_id, $device_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\UnenrollNetworkSmDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\UnenrollNetworkSmDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\UnenrollNetworkSmDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\UnenrollNetworkSmDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\UnenrollNetworkSmDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unenrollNetworkSmDeviceAsync
     *
     * Unenroll a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unenrollNetworkSmDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unenrollNetworkSmDeviceAsync($network_id, $device_id, string $contentType = self::contentTypes['unenrollNetworkSmDevice'][0])
    {
        return $this->unenrollNetworkSmDeviceAsyncWithHttpInfo($network_id, $device_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unenrollNetworkSmDeviceAsyncWithHttpInfo
     *
     * Unenroll a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unenrollNetworkSmDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unenrollNetworkSmDeviceAsyncWithHttpInfo($network_id, $device_id, string $contentType = self::contentTypes['unenrollNetworkSmDevice'][0])
    {
        $returnType = '\Meraki\Model\UnenrollNetworkSmDevice200Response';
        $request = $this->unenrollNetworkSmDeviceRequest($network_id, $device_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unenrollNetworkSmDevice'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unenrollNetworkSmDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unenrollNetworkSmDeviceRequest($network_id, $device_id, string $contentType = self::contentTypes['unenrollNetworkSmDevice'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling unenrollNetworkSmDevice'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling unenrollNetworkSmDevice'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/unenroll';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uninstallNetworkSmDeviceApps
     *
     * Uninstall applications on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\UninstallNetworkSmDeviceAppsRequest $uninstall_network_sm_device_apps_request uninstall_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function uninstallNetworkSmDeviceApps($network_id, $device_id, $uninstall_network_sm_device_apps_request, string $contentType = self::contentTypes['uninstallNetworkSmDeviceApps'][0])
    {
        list($response) = $this->uninstallNetworkSmDeviceAppsWithHttpInfo($network_id, $device_id, $uninstall_network_sm_device_apps_request, $contentType);
        return $response;
    }

    /**
     * Operation uninstallNetworkSmDeviceAppsWithHttpInfo
     *
     * Uninstall applications on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\UninstallNetworkSmDeviceAppsRequest $uninstall_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function uninstallNetworkSmDeviceAppsWithHttpInfo($network_id, $device_id, $uninstall_network_sm_device_apps_request, string $contentType = self::contentTypes['uninstallNetworkSmDeviceApps'][0])
    {
        $request = $this->uninstallNetworkSmDeviceAppsRequest($network_id, $device_id, $uninstall_network_sm_device_apps_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uninstallNetworkSmDeviceAppsAsync
     *
     * Uninstall applications on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\UninstallNetworkSmDeviceAppsRequest $uninstall_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uninstallNetworkSmDeviceAppsAsync($network_id, $device_id, $uninstall_network_sm_device_apps_request, string $contentType = self::contentTypes['uninstallNetworkSmDeviceApps'][0])
    {
        return $this->uninstallNetworkSmDeviceAppsAsyncWithHttpInfo($network_id, $device_id, $uninstall_network_sm_device_apps_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uninstallNetworkSmDeviceAppsAsyncWithHttpInfo
     *
     * Uninstall applications on a device
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\UninstallNetworkSmDeviceAppsRequest $uninstall_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uninstallNetworkSmDeviceAppsAsyncWithHttpInfo($network_id, $device_id, $uninstall_network_sm_device_apps_request, string $contentType = self::contentTypes['uninstallNetworkSmDeviceApps'][0])
    {
        $returnType = 'object';
        $request = $this->uninstallNetworkSmDeviceAppsRequest($network_id, $device_id, $uninstall_network_sm_device_apps_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uninstallNetworkSmDeviceApps'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $device_id Device ID (required)
     * @param  \Meraki\Model\UninstallNetworkSmDeviceAppsRequest $uninstall_network_sm_device_apps_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uninstallNetworkSmDeviceApps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uninstallNetworkSmDeviceAppsRequest($network_id, $device_id, $uninstall_network_sm_device_apps_request, string $contentType = self::contentTypes['uninstallNetworkSmDeviceApps'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling uninstallNetworkSmDeviceApps'
            );
        }

        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling uninstallNetworkSmDeviceApps'
            );
        }

        // verify the required parameter 'uninstall_network_sm_device_apps_request' is set
        if ($uninstall_network_sm_device_apps_request === null || (is_array($uninstall_network_sm_device_apps_request) && count($uninstall_network_sm_device_apps_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uninstall_network_sm_device_apps_request when calling uninstallNetworkSmDeviceApps'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/uninstallApps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($uninstall_network_sm_device_apps_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($uninstall_network_sm_device_apps_request));
            } else {
                $httpBody = $uninstall_network_sm_device_apps_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDevice
     *
     * Update the attributes of a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceRequest|null $update_device_request update_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDevice200Response
     */
    public function updateDevice($serial, $update_device_request = null, string $contentType = self::contentTypes['updateDevice'][0])
    {
        list($response) = $this->updateDeviceWithHttpInfo($serial, $update_device_request, $contentType);
        return $response;
    }

    /**
     * Operation updateDeviceWithHttpInfo
     *
     * Update the attributes of a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceRequest|null $update_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDevice'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDevice200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDeviceWithHttpInfo($serial, $update_device_request = null, string $contentType = self::contentTypes['updateDevice'][0])
    {
        $request = $this->updateDeviceRequest($serial, $update_device_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDevice200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDevice200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDevice200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDevice200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDevice200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDeviceAsync
     *
     * Update the attributes of a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceRequest|null $update_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceAsync($serial, $update_device_request = null, string $contentType = self::contentTypes['updateDevice'][0])
    {
        return $this->updateDeviceAsyncWithHttpInfo($serial, $update_device_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDeviceAsyncWithHttpInfo
     *
     * Update the attributes of a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceRequest|null $update_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceAsyncWithHttpInfo($serial, $update_device_request = null, string $contentType = self::contentTypes['updateDevice'][0])
    {
        $returnType = '\Meraki\Model\GetDevice200Response';
        $request = $this->updateDeviceRequest($serial, $update_device_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDevice'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceRequest|null $update_device_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDevice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDeviceRequest($serial, $update_device_request = null, string $contentType = self::contentTypes['updateDevice'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling updateDevice'
            );
        }



        $resourcePath = '/devices/{serial}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_device_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_device_request));
            } else {
                $httpBody = $update_device_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDeviceCellularSims
     *
     * Updates the SIM and APN configurations for a cellular device.
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceCellularSimsRequest|null $update_device_cellular_sims_request update_device_cellular_sims_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceCellularSims200Response
     */
    public function updateDeviceCellularSims($serial, $update_device_cellular_sims_request = null, string $contentType = self::contentTypes['updateDeviceCellularSims'][0])
    {
        list($response) = $this->updateDeviceCellularSimsWithHttpInfo($serial, $update_device_cellular_sims_request, $contentType);
        return $response;
    }

    /**
     * Operation updateDeviceCellularSimsWithHttpInfo
     *
     * Updates the SIM and APN configurations for a cellular device.
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceCellularSimsRequest|null $update_device_cellular_sims_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceCellularSims200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDeviceCellularSimsWithHttpInfo($serial, $update_device_cellular_sims_request = null, string $contentType = self::contentTypes['updateDeviceCellularSims'][0])
    {
        $request = $this->updateDeviceCellularSimsRequest($serial, $update_device_cellular_sims_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceCellularSims200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceCellularSims200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceCellularSims200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceCellularSims200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceCellularSims200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDeviceCellularSimsAsync
     *
     * Updates the SIM and APN configurations for a cellular device.
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceCellularSimsRequest|null $update_device_cellular_sims_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceCellularSimsAsync($serial, $update_device_cellular_sims_request = null, string $contentType = self::contentTypes['updateDeviceCellularSims'][0])
    {
        return $this->updateDeviceCellularSimsAsyncWithHttpInfo($serial, $update_device_cellular_sims_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDeviceCellularSimsAsyncWithHttpInfo
     *
     * Updates the SIM and APN configurations for a cellular device.
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceCellularSimsRequest|null $update_device_cellular_sims_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceCellularSimsAsyncWithHttpInfo($serial, $update_device_cellular_sims_request = null, string $contentType = self::contentTypes['updateDeviceCellularSims'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceCellularSims200Response';
        $request = $this->updateDeviceCellularSimsRequest($serial, $update_device_cellular_sims_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDeviceCellularSims'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceCellularSimsRequest|null $update_device_cellular_sims_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceCellularSims'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDeviceCellularSimsRequest($serial, $update_device_cellular_sims_request = null, string $contentType = self::contentTypes['updateDeviceCellularSims'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling updateDeviceCellularSims'
            );
        }



        $resourcePath = '/devices/{serial}/cellular/sims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_device_cellular_sims_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_device_cellular_sims_request));
            } else {
                $httpBody = $update_device_cellular_sims_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDeviceManagementInterface
     *
     * Update the management interface settings for a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceManagementInterfaceRequest|null $update_device_management_interface_request update_device_management_interface_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetDeviceManagementInterface200Response
     */
    public function updateDeviceManagementInterface($serial, $update_device_management_interface_request = null, string $contentType = self::contentTypes['updateDeviceManagementInterface'][0])
    {
        list($response) = $this->updateDeviceManagementInterfaceWithHttpInfo($serial, $update_device_management_interface_request, $contentType);
        return $response;
    }

    /**
     * Operation updateDeviceManagementInterfaceWithHttpInfo
     *
     * Update the management interface settings for a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceManagementInterfaceRequest|null $update_device_management_interface_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetDeviceManagementInterface200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDeviceManagementInterfaceWithHttpInfo($serial, $update_device_management_interface_request = null, string $contentType = self::contentTypes['updateDeviceManagementInterface'][0])
    {
        $request = $this->updateDeviceManagementInterfaceRequest($serial, $update_device_management_interface_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetDeviceManagementInterface200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetDeviceManagementInterface200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetDeviceManagementInterface200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetDeviceManagementInterface200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetDeviceManagementInterface200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDeviceManagementInterfaceAsync
     *
     * Update the management interface settings for a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceManagementInterfaceRequest|null $update_device_management_interface_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceManagementInterfaceAsync($serial, $update_device_management_interface_request = null, string $contentType = self::contentTypes['updateDeviceManagementInterface'][0])
    {
        return $this->updateDeviceManagementInterfaceAsyncWithHttpInfo($serial, $update_device_management_interface_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDeviceManagementInterfaceAsyncWithHttpInfo
     *
     * Update the management interface settings for a device
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceManagementInterfaceRequest|null $update_device_management_interface_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceManagementInterfaceAsyncWithHttpInfo($serial, $update_device_management_interface_request = null, string $contentType = self::contentTypes['updateDeviceManagementInterface'][0])
    {
        $returnType = '\Meraki\Model\GetDeviceManagementInterface200Response';
        $request = $this->updateDeviceManagementInterfaceRequest($serial, $update_device_management_interface_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDeviceManagementInterface'
     *
     * @param  string $serial Serial (required)
     * @param  \Meraki\Model\UpdateDeviceManagementInterfaceRequest|null $update_device_management_interface_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDeviceManagementInterface'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDeviceManagementInterfaceRequest($serial, $update_device_management_interface_request = null, string $contentType = self::contentTypes['updateDeviceManagementInterface'][0])
    {

        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling updateDeviceManagementInterface'
            );
        }



        $resourcePath = '/devices/{serial}/managementInterface';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_device_management_interface_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_device_management_interface_request));
            } else {
                $httpBody = $update_device_management_interface_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkSmDevicesFields
     *
     * Modify the fields of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSmDevicesFieldsRequest $update_network_sm_devices_fields_request update_network_sm_devices_fields_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSmDevicesFields'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\UpdateNetworkSmDevicesFields200ResponseInner[]
     */
    public function updateNetworkSmDevicesFields($network_id, $update_network_sm_devices_fields_request, string $contentType = self::contentTypes['updateNetworkSmDevicesFields'][0])
    {
        list($response) = $this->updateNetworkSmDevicesFieldsWithHttpInfo($network_id, $update_network_sm_devices_fields_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkSmDevicesFieldsWithHttpInfo
     *
     * Modify the fields of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSmDevicesFieldsRequest $update_network_sm_devices_fields_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSmDevicesFields'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\UpdateNetworkSmDevicesFields200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkSmDevicesFieldsWithHttpInfo($network_id, $update_network_sm_devices_fields_request, string $contentType = self::contentTypes['updateNetworkSmDevicesFields'][0])
    {
        $request = $this->updateNetworkSmDevicesFieldsRequest($network_id, $update_network_sm_devices_fields_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\UpdateNetworkSmDevicesFields200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\UpdateNetworkSmDevicesFields200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\UpdateNetworkSmDevicesFields200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\UpdateNetworkSmDevicesFields200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\UpdateNetworkSmDevicesFields200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkSmDevicesFieldsAsync
     *
     * Modify the fields of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSmDevicesFieldsRequest $update_network_sm_devices_fields_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSmDevicesFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSmDevicesFieldsAsync($network_id, $update_network_sm_devices_fields_request, string $contentType = self::contentTypes['updateNetworkSmDevicesFields'][0])
    {
        return $this->updateNetworkSmDevicesFieldsAsyncWithHttpInfo($network_id, $update_network_sm_devices_fields_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkSmDevicesFieldsAsyncWithHttpInfo
     *
     * Modify the fields of a device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSmDevicesFieldsRequest $update_network_sm_devices_fields_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSmDevicesFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkSmDevicesFieldsAsyncWithHttpInfo($network_id, $update_network_sm_devices_fields_request, string $contentType = self::contentTypes['updateNetworkSmDevicesFields'][0])
    {
        $returnType = '\Meraki\Model\UpdateNetworkSmDevicesFields200ResponseInner[]';
        $request = $this->updateNetworkSmDevicesFieldsRequest($network_id, $update_network_sm_devices_fields_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkSmDevicesFields'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\UpdateNetworkSmDevicesFieldsRequest $update_network_sm_devices_fields_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkSmDevicesFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkSmDevicesFieldsRequest($network_id, $update_network_sm_devices_fields_request, string $contentType = self::contentTypes['updateNetworkSmDevicesFields'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkSmDevicesFields'
            );
        }

        // verify the required parameter 'update_network_sm_devices_fields_request' is set
        if ($update_network_sm_devices_fields_request === null || (is_array($update_network_sm_devices_fields_request) && count($update_network_sm_devices_fields_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_network_sm_devices_fields_request when calling updateNetworkSmDevicesFields'
            );
        }


        $resourcePath = '/networks/{networkId}/sm/devices/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_sm_devices_fields_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_sm_devices_fields_request));
            } else {
                $httpBody = $update_network_sm_devices_fields_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vmxNetworkDevicesClaim
     *
     * Claim a vMX into a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\VmxNetworkDevicesClaim200Response
     */
    public function vmxNetworkDevicesClaim($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {
        list($response) = $this->vmxNetworkDevicesClaimWithHttpInfo($network_id, $vmx_network_devices_claim_request, $contentType);
        return $response;
    }

    /**
     * Operation vmxNetworkDevicesClaimWithHttpInfo
     *
     * Claim a vMX into a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\VmxNetworkDevicesClaim200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function vmxNetworkDevicesClaimWithHttpInfo($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {
        $request = $this->vmxNetworkDevicesClaimRequest($network_id, $vmx_network_devices_claim_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\VmxNetworkDevicesClaim200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\VmxNetworkDevicesClaim200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\VmxNetworkDevicesClaim200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\VmxNetworkDevicesClaim200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\VmxNetworkDevicesClaim200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vmxNetworkDevicesClaimAsync
     *
     * Claim a vMX into a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vmxNetworkDevicesClaimAsync($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {
        return $this->vmxNetworkDevicesClaimAsyncWithHttpInfo($network_id, $vmx_network_devices_claim_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vmxNetworkDevicesClaimAsyncWithHttpInfo
     *
     * Claim a vMX into a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vmxNetworkDevicesClaimAsyncWithHttpInfo($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {
        $returnType = '\Meraki\Model\VmxNetworkDevicesClaim200Response';
        $request = $this->vmxNetworkDevicesClaimRequest($network_id, $vmx_network_devices_claim_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vmxNetworkDevicesClaim'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\VmxNetworkDevicesClaimRequest $vmx_network_devices_claim_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vmxNetworkDevicesClaim'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vmxNetworkDevicesClaimRequest($network_id, $vmx_network_devices_claim_request, string $contentType = self::contentTypes['vmxNetworkDevicesClaim'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling vmxNetworkDevicesClaim'
            );
        }

        // verify the required parameter 'vmx_network_devices_claim_request' is set
        if ($vmx_network_devices_claim_request === null || (is_array($vmx_network_devices_claim_request) && count($vmx_network_devices_claim_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vmx_network_devices_claim_request when calling vmxNetworkDevicesClaim'
            );
        }


        $resourcePath = '/networks/{networkId}/devices/claim/vmx';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vmx_network_devices_claim_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vmx_network_devices_claim_request));
            } else {
                $httpBody = $vmx_network_devices_claim_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wipeNetworkSmDevices
     *
     * Wipe a device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\WipeNetworkSmDevicesRequest|null $wipe_network_sm_devices_request wipe_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wipeNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\WipeNetworkSmDevices200Response
     */
    public function wipeNetworkSmDevices($network_id, $wipe_network_sm_devices_request = null, string $contentType = self::contentTypes['wipeNetworkSmDevices'][0])
    {
        list($response) = $this->wipeNetworkSmDevicesWithHttpInfo($network_id, $wipe_network_sm_devices_request, $contentType);
        return $response;
    }

    /**
     * Operation wipeNetworkSmDevicesWithHttpInfo
     *
     * Wipe a device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\WipeNetworkSmDevicesRequest|null $wipe_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wipeNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\WipeNetworkSmDevices200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function wipeNetworkSmDevicesWithHttpInfo($network_id, $wipe_network_sm_devices_request = null, string $contentType = self::contentTypes['wipeNetworkSmDevices'][0])
    {
        $request = $this->wipeNetworkSmDevicesRequest($network_id, $wipe_network_sm_devices_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\WipeNetworkSmDevices200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\WipeNetworkSmDevices200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\WipeNetworkSmDevices200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\WipeNetworkSmDevices200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\WipeNetworkSmDevices200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation wipeNetworkSmDevicesAsync
     *
     * Wipe a device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\WipeNetworkSmDevicesRequest|null $wipe_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wipeNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wipeNetworkSmDevicesAsync($network_id, $wipe_network_sm_devices_request = null, string $contentType = self::contentTypes['wipeNetworkSmDevices'][0])
    {
        return $this->wipeNetworkSmDevicesAsyncWithHttpInfo($network_id, $wipe_network_sm_devices_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wipeNetworkSmDevicesAsyncWithHttpInfo
     *
     * Wipe a device
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\WipeNetworkSmDevicesRequest|null $wipe_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wipeNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wipeNetworkSmDevicesAsyncWithHttpInfo($network_id, $wipe_network_sm_devices_request = null, string $contentType = self::contentTypes['wipeNetworkSmDevices'][0])
    {
        $returnType = '\Meraki\Model\WipeNetworkSmDevices200Response';
        $request = $this->wipeNetworkSmDevicesRequest($network_id, $wipe_network_sm_devices_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'wipeNetworkSmDevices'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\WipeNetworkSmDevicesRequest|null $wipe_network_sm_devices_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['wipeNetworkSmDevices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function wipeNetworkSmDevicesRequest($network_id, $wipe_network_sm_devices_request = null, string $contentType = self::contentTypes['wipeNetworkSmDevices'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling wipeNetworkSmDevices'
            );
        }



        $resourcePath = '/networks/{networkId}/sm/devices/wipe';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wipe_network_sm_devices_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wipe_network_sm_devices_request));
            } else {
                $httpBody = $wipe_network_sm_devices_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
