<?php
/**
 * WebhooksApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Meraki Dashboard API
 *
 * A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 02 April, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * The version of the OpenAPI document: 1.57.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Meraki\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Meraki\ApiException;
use Meraki\Configuration;
use Meraki\HeaderSelector;
use Meraki\ObjectSerializer;

/**
 * WebhooksApi Class Doc Comment
 *
 * @category Class
 * @package  Meraki
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class WebhooksApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createNetworkWebhooksHttpServer' => [
            'application/json',
        ],
        'createNetworkWebhooksPayloadTemplate' => [
            'application/json',
        ],
        'createNetworkWebhooksWebhookTest' => [
            'application/json',
        ],
        'deleteNetworkWebhooksHttpServer' => [
            'application/json',
        ],
        'deleteNetworkWebhooksPayloadTemplate' => [
            'application/json',
        ],
        'getNetworkWebhooksHttpServer' => [
            'application/json',
        ],
        'getNetworkWebhooksHttpServers' => [
            'application/json',
        ],
        'getNetworkWebhooksPayloadTemplate' => [
            'application/json',
        ],
        'getNetworkWebhooksPayloadTemplates' => [
            'application/json',
        ],
        'getNetworkWebhooksWebhookTest' => [
            'application/json',
        ],
        'getOrganizationWebhooksAlertTypes' => [
            'application/json',
        ],
        'getOrganizationWebhooksCallbacksStatus' => [
            'application/json',
        ],
        'getOrganizationWebhooksLogs' => [
            'application/json',
        ],
        'updateNetworkWebhooksHttpServer' => [
            'application/json',
        ],
        'updateNetworkWebhooksPayloadTemplate' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createNetworkWebhooksHttpServer
     *
     * Add an HTTP server to a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner
     */
    public function createNetworkWebhooksHttpServer($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {
        list($response) = $this->createNetworkWebhooksHttpServerWithHttpInfo($network_id, $create_network_webhooks_http_server_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkWebhooksHttpServerWithHttpInfo
     *
     * Add an HTTP server to a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkWebhooksHttpServerWithHttpInfo($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {
        $request = $this->createNetworkWebhooksHttpServerRequest($network_id, $create_network_webhooks_http_server_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkWebhooksHttpServerAsync
     *
     * Add an HTTP server to a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksHttpServerAsync($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {
        return $this->createNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $create_network_webhooks_http_server_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkWebhooksHttpServerAsyncWithHttpInfo
     *
     * Add an HTTP server to a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
        $request = $this->createNetworkWebhooksHttpServerRequest($network_id, $create_network_webhooks_http_server_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkWebhooksHttpServer'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksHttpServerRequest $create_network_webhooks_http_server_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkWebhooksHttpServerRequest($network_id, $create_network_webhooks_http_server_request, string $contentType = self::contentTypes['createNetworkWebhooksHttpServer'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkWebhooksHttpServer'
            );
        }

        // verify the required parameter 'create_network_webhooks_http_server_request' is set
        if ($create_network_webhooks_http_server_request === null || (is_array($create_network_webhooks_http_server_request) && count($create_network_webhooks_http_server_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_webhooks_http_server_request when calling createNetworkWebhooksHttpServer'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/httpServers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_webhooks_http_server_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_webhooks_http_server_request));
            } else {
                $httpBody = $create_network_webhooks_http_server_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkWebhooksPayloadTemplate
     *
     * Create a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner
     */
    public function createNetworkWebhooksPayloadTemplate($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {
        list($response) = $this->createNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $create_network_webhooks_payload_template_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkWebhooksPayloadTemplateWithHttpInfo
     *
     * Create a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {
        $request = $this->createNetworkWebhooksPayloadTemplateRequest($network_id, $create_network_webhooks_payload_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkWebhooksPayloadTemplateAsync
     *
     * Create a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksPayloadTemplateAsync($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {
        return $this->createNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $create_network_webhooks_payload_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkWebhooksPayloadTemplateAsyncWithHttpInfo
     *
     * Create a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
        $request = $this->createNetworkWebhooksPayloadTemplateRequest($network_id, $create_network_webhooks_payload_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkWebhooksPayloadTemplate'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksPayloadTemplateRequest $create_network_webhooks_payload_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkWebhooksPayloadTemplateRequest($network_id, $create_network_webhooks_payload_template_request, string $contentType = self::contentTypes['createNetworkWebhooksPayloadTemplate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkWebhooksPayloadTemplate'
            );
        }

        // verify the required parameter 'create_network_webhooks_payload_template_request' is set
        if ($create_network_webhooks_payload_template_request === null || (is_array($create_network_webhooks_payload_template_request) && count($create_network_webhooks_payload_template_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_webhooks_payload_template_request when calling createNetworkWebhooksPayloadTemplate'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_webhooks_payload_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_webhooks_payload_template_request));
            } else {
                $httpBody = $create_network_webhooks_payload_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkWebhooksWebhookTest
     *
     * Send a test webhook for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateNetworkWebhooksWebhookTest201Response
     */
    public function createNetworkWebhooksWebhookTest($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {
        list($response) = $this->createNetworkWebhooksWebhookTestWithHttpInfo($network_id, $create_network_webhooks_webhook_test_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetworkWebhooksWebhookTestWithHttpInfo
     *
     * Send a test webhook for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateNetworkWebhooksWebhookTest201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkWebhooksWebhookTestWithHttpInfo($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {
        $request = $this->createNetworkWebhooksWebhookTestRequest($network_id, $create_network_webhooks_webhook_test_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkWebhooksWebhookTestAsync
     *
     * Send a test webhook for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksWebhookTestAsync($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {
        return $this->createNetworkWebhooksWebhookTestAsyncWithHttpInfo($network_id, $create_network_webhooks_webhook_test_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkWebhooksWebhookTestAsyncWithHttpInfo
     *
     * Send a test webhook for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWebhooksWebhookTestAsyncWithHttpInfo($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {
        $returnType = '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response';
        $request = $this->createNetworkWebhooksWebhookTestRequest($network_id, $create_network_webhooks_webhook_test_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkWebhooksWebhookTest'
     *
     * @param  string $network_id Network ID (required)
     * @param  \Meraki\Model\CreateNetworkWebhooksWebhookTestRequest $create_network_webhooks_webhook_test_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetworkWebhooksWebhookTestRequest($network_id, $create_network_webhooks_webhook_test_request, string $contentType = self::contentTypes['createNetworkWebhooksWebhookTest'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkWebhooksWebhookTest'
            );
        }

        // verify the required parameter 'create_network_webhooks_webhook_test_request' is set
        if ($create_network_webhooks_webhook_test_request === null || (is_array($create_network_webhooks_webhook_test_request) && count($create_network_webhooks_webhook_test_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_webhooks_webhook_test_request when calling createNetworkWebhooksWebhookTest'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/webhookTests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_network_webhooks_webhook_test_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_network_webhooks_webhook_test_request));
            } else {
                $httpBody = $create_network_webhooks_webhook_test_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkWebhooksHttpServer
     *
     * Delete an HTTP server from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkWebhooksHttpServer($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {
        $this->deleteNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, $contentType);
    }

    /**
     * Operation deleteNetworkWebhooksHttpServerWithHttpInfo
     *
     * Delete an HTTP server from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {
        $request = $this->deleteNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkWebhooksHttpServerAsync
     *
     * Delete an HTTP server from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWebhooksHttpServerAsync($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {
        return $this->deleteNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkWebhooksHttpServerAsyncWithHttpInfo
     *
     * Delete an HTTP server from a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkWebhooksHttpServer'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkWebhooksHttpServerRequest($network_id, $http_server_id, string $contentType = self::contentTypes['deleteNetworkWebhooksHttpServer'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkWebhooksHttpServer'
            );
        }

        // verify the required parameter 'http_server_id' is set
        if ($http_server_id === null || (is_array($http_server_id) && count($http_server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_server_id when calling deleteNetworkWebhooksHttpServer'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/httpServers/{httpServerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($http_server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'httpServerId' . '}',
                ObjectSerializer::toPathValue($http_server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkWebhooksPayloadTemplate
     *
     * Destroy a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkWebhooksPayloadTemplate($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {
        $this->deleteNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, $contentType);
    }

    /**
     * Operation deleteNetworkWebhooksPayloadTemplateWithHttpInfo
     *
     * Destroy a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {
        $request = $this->deleteNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkWebhooksPayloadTemplateAsync
     *
     * Destroy a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWebhooksPayloadTemplateAsync($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {
        return $this->deleteNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkWebhooksPayloadTemplateAsyncWithHttpInfo
     *
     * Destroy a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {
        $returnType = '';
        $request = $this->deleteNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkWebhooksPayloadTemplate'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, string $contentType = self::contentTypes['deleteNetworkWebhooksPayloadTemplate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkWebhooksPayloadTemplate'
            );
        }

        // verify the required parameter 'payload_template_id' is set
        if ($payload_template_id === null || (is_array($payload_template_id) && count($payload_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payload_template_id when calling deleteNetworkWebhooksPayloadTemplate'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($payload_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'payloadTemplateId' . '}',
                ObjectSerializer::toPathValue($payload_template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksHttpServer
     *
     * Return an HTTP server for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner
     */
    public function getNetworkWebhooksHttpServer($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {
        list($response) = $this->getNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksHttpServerWithHttpInfo
     *
     * Return an HTTP server for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {
        $request = $this->getNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksHttpServerAsync
     *
     * Return an HTTP server for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksHttpServerAsync($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {
        return $this->getNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksHttpServerAsyncWithHttpInfo
     *
     * Return an HTTP server for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
        $request = $this->getNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksHttpServer'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksHttpServerRequest($network_id, $http_server_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServer'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksHttpServer'
            );
        }

        // verify the required parameter 'http_server_id' is set
        if ($http_server_id === null || (is_array($http_server_id) && count($http_server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_server_id when calling getNetworkWebhooksHttpServer'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/httpServers/{httpServerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($http_server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'httpServerId' . '}',
                ObjectSerializer::toPathValue($http_server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksHttpServers
     *
     * List the HTTP servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]
     */
    public function getNetworkWebhooksHttpServers($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {
        list($response) = $this->getNetworkWebhooksHttpServersWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksHttpServersWithHttpInfo
     *
     * List the HTTP servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksHttpServersWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {
        $request = $this->getNetworkWebhooksHttpServersRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksHttpServersAsync
     *
     * List the HTTP servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksHttpServersAsync($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {
        return $this->getNetworkWebhooksHttpServersAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksHttpServersAsyncWithHttpInfo
     *
     * List the HTTP servers for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksHttpServersAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner[]';
        $request = $this->getNetworkWebhooksHttpServersRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksHttpServers'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksHttpServers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksHttpServersRequest($network_id, string $contentType = self::contentTypes['getNetworkWebhooksHttpServers'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksHttpServers'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/httpServers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplate
     *
     * Get the webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner
     */
    public function getNetworkWebhooksPayloadTemplate($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {
        list($response) = $this->getNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplateWithHttpInfo
     *
     * Get the webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {
        $request = $this->getNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplateAsync
     *
     * Get the webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksPayloadTemplateAsync($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {
        return $this->getNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplateAsyncWithHttpInfo
     *
     * Get the webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
        $request = $this->getNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksPayloadTemplate'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksPayloadTemplate'
            );
        }

        // verify the required parameter 'payload_template_id' is set
        if ($payload_template_id === null || (is_array($payload_template_id) && count($payload_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payload_template_id when calling getNetworkWebhooksPayloadTemplate'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($payload_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'payloadTemplateId' . '}',
                ObjectSerializer::toPathValue($payload_template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplates
     *
     * List the webhook payload templates for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]
     */
    public function getNetworkWebhooksPayloadTemplates($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {
        list($response) = $this->getNetworkWebhooksPayloadTemplatesWithHttpInfo($network_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplatesWithHttpInfo
     *
     * List the webhook payload templates for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksPayloadTemplatesWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {
        $request = $this->getNetworkWebhooksPayloadTemplatesRequest($network_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplatesAsync
     *
     * List the webhook payload templates for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksPayloadTemplatesAsync($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {
        return $this->getNetworkWebhooksPayloadTemplatesAsyncWithHttpInfo($network_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksPayloadTemplatesAsyncWithHttpInfo
     *
     * List the webhook payload templates for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksPayloadTemplatesAsyncWithHttpInfo($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner[]';
        $request = $this->getNetworkWebhooksPayloadTemplatesRequest($network_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksPayloadTemplates'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksPayloadTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksPayloadTemplatesRequest($network_id, string $contentType = self::contentTypes['getNetworkWebhooksPayloadTemplates'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksPayloadTemplates'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWebhooksWebhookTest
     *
     * Return the status of a webhook test for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\CreateNetworkWebhooksWebhookTest201Response
     */
    public function getNetworkWebhooksWebhookTest($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {
        list($response) = $this->getNetworkWebhooksWebhookTestWithHttpInfo($network_id, $webhook_test_id, $contentType);
        return $response;
    }

    /**
     * Operation getNetworkWebhooksWebhookTestWithHttpInfo
     *
     * Return the status of a webhook test for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\CreateNetworkWebhooksWebhookTest201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWebhooksWebhookTestWithHttpInfo($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {
        $request = $this->getNetworkWebhooksWebhookTestRequest($network_id, $webhook_test_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWebhooksWebhookTestAsync
     *
     * Return the status of a webhook test for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksWebhookTestAsync($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {
        return $this->getNetworkWebhooksWebhookTestAsyncWithHttpInfo($network_id, $webhook_test_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWebhooksWebhookTestAsyncWithHttpInfo
     *
     * Return the status of a webhook test for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWebhooksWebhookTestAsyncWithHttpInfo($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {
        $returnType = '\Meraki\Model\CreateNetworkWebhooksWebhookTest201Response';
        $request = $this->getNetworkWebhooksWebhookTestRequest($network_id, $webhook_test_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWebhooksWebhookTest'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $webhook_test_id Webhook test ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNetworkWebhooksWebhookTest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNetworkWebhooksWebhookTestRequest($network_id, $webhook_test_id, string $contentType = self::contentTypes['getNetworkWebhooksWebhookTest'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWebhooksWebhookTest'
            );
        }

        // verify the required parameter 'webhook_test_id' is set
        if ($webhook_test_id === null || (is_array($webhook_test_id) && count($webhook_test_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_test_id when calling getNetworkWebhooksWebhookTest'
            );
        }


        $resourcePath = '/networks/{networkId}/webhooks/webhookTests/{webhookTestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_test_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookTestId' . '}',
                ObjectSerializer::toPathValue($webhook_test_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWebhooksAlertTypes
     *
     * Return a list of alert types to be used with managing webhook alerts
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $product_type Filter sample alerts to a specific product type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksAlertTypes'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWebhooksAlertTypes200Response
     */
    public function getOrganizationWebhooksAlertTypes($organization_id, $product_type = null, string $contentType = self::contentTypes['getOrganizationWebhooksAlertTypes'][0])
    {
        list($response) = $this->getOrganizationWebhooksAlertTypesWithHttpInfo($organization_id, $product_type, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWebhooksAlertTypesWithHttpInfo
     *
     * Return a list of alert types to be used with managing webhook alerts
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $product_type Filter sample alerts to a specific product type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksAlertTypes'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWebhooksAlertTypes200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWebhooksAlertTypesWithHttpInfo($organization_id, $product_type = null, string $contentType = self::contentTypes['getOrganizationWebhooksAlertTypes'][0])
    {
        $request = $this->getOrganizationWebhooksAlertTypesRequest($organization_id, $product_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWebhooksAlertTypes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWebhooksAlertTypes200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWebhooksAlertTypes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWebhooksAlertTypes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWebhooksAlertTypes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWebhooksAlertTypesAsync
     *
     * Return a list of alert types to be used with managing webhook alerts
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $product_type Filter sample alerts to a specific product type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksAlertTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksAlertTypesAsync($organization_id, $product_type = null, string $contentType = self::contentTypes['getOrganizationWebhooksAlertTypes'][0])
    {
        return $this->getOrganizationWebhooksAlertTypesAsyncWithHttpInfo($organization_id, $product_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWebhooksAlertTypesAsyncWithHttpInfo
     *
     * Return a list of alert types to be used with managing webhook alerts
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $product_type Filter sample alerts to a specific product type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksAlertTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksAlertTypesAsyncWithHttpInfo($organization_id, $product_type = null, string $contentType = self::contentTypes['getOrganizationWebhooksAlertTypes'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWebhooksAlertTypes200Response';
        $request = $this->getOrganizationWebhooksAlertTypesRequest($organization_id, $product_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWebhooksAlertTypes'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $product_type Filter sample alerts to a specific product type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksAlertTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWebhooksAlertTypesRequest($organization_id, $product_type = null, string $contentType = self::contentTypes['getOrganizationWebhooksAlertTypes'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWebhooksAlertTypes'
            );
        }



        $resourcePath = '/organizations/{organizationId}/webhooks/alertTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_type,
            'productType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWebhooksCallbacksStatus
     *
     * Return the status of an API callback
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $callback_id Callback ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksCallbacksStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWebhooksCallbacksStatus200Response
     */
    public function getOrganizationWebhooksCallbacksStatus($organization_id, $callback_id, string $contentType = self::contentTypes['getOrganizationWebhooksCallbacksStatus'][0])
    {
        list($response) = $this->getOrganizationWebhooksCallbacksStatusWithHttpInfo($organization_id, $callback_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWebhooksCallbacksStatusWithHttpInfo
     *
     * Return the status of an API callback
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $callback_id Callback ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksCallbacksStatus'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWebhooksCallbacksStatus200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWebhooksCallbacksStatusWithHttpInfo($organization_id, $callback_id, string $contentType = self::contentTypes['getOrganizationWebhooksCallbacksStatus'][0])
    {
        $request = $this->getOrganizationWebhooksCallbacksStatusRequest($organization_id, $callback_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWebhooksCallbacksStatus200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWebhooksCallbacksStatus200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWebhooksCallbacksStatus200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWebhooksCallbacksStatus200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWebhooksCallbacksStatus200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWebhooksCallbacksStatusAsync
     *
     * Return the status of an API callback
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $callback_id Callback ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksCallbacksStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksCallbacksStatusAsync($organization_id, $callback_id, string $contentType = self::contentTypes['getOrganizationWebhooksCallbacksStatus'][0])
    {
        return $this->getOrganizationWebhooksCallbacksStatusAsyncWithHttpInfo($organization_id, $callback_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWebhooksCallbacksStatusAsyncWithHttpInfo
     *
     * Return the status of an API callback
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $callback_id Callback ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksCallbacksStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksCallbacksStatusAsyncWithHttpInfo($organization_id, $callback_id, string $contentType = self::contentTypes['getOrganizationWebhooksCallbacksStatus'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWebhooksCallbacksStatus200Response';
        $request = $this->getOrganizationWebhooksCallbacksStatusRequest($organization_id, $callback_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWebhooksCallbacksStatus'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string $callback_id Callback ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksCallbacksStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWebhooksCallbacksStatusRequest($organization_id, $callback_id, string $contentType = self::contentTypes['getOrganizationWebhooksCallbacksStatus'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWebhooksCallbacksStatus'
            );
        }

        // verify the required parameter 'callback_id' is set
        if ($callback_id === null || (is_array($callback_id) && count($callback_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $callback_id when calling getOrganizationWebhooksCallbacksStatus'
            );
        }


        $resourcePath = '/organizations/{organizationId}/webhooks/callbacks/statuses/{callbackId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($callback_id !== null) {
            $resourcePath = str_replace(
                '{' . 'callbackId' . '}',
                ObjectSerializer::toPathValue($callback_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWebhooksLogs
     *
     * Return the log of webhook POSTs sent
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $url The URL the webhook was sent to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksLogs'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetOrganizationWebhooksLogs200ResponseInner[]
     */
    public function getOrganizationWebhooksLogs($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null, string $contentType = self::contentTypes['getOrganizationWebhooksLogs'][0])
    {
        list($response) = $this->getOrganizationWebhooksLogsWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $url, $contentType);
        return $response;
    }

    /**
     * Operation getOrganizationWebhooksLogsWithHttpInfo
     *
     * Return the log of webhook POSTs sent
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $url The URL the webhook was sent to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksLogs'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetOrganizationWebhooksLogs200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWebhooksLogsWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null, string $contentType = self::contentTypes['getOrganizationWebhooksLogs'][0])
    {
        $request = $this->getOrganizationWebhooksLogsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $url, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetOrganizationWebhooksLogs200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetOrganizationWebhooksLogs200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetOrganizationWebhooksLogs200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetOrganizationWebhooksLogs200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetOrganizationWebhooksLogs200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWebhooksLogsAsync
     *
     * Return the log of webhook POSTs sent
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $url The URL the webhook was sent to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksLogsAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null, string $contentType = self::contentTypes['getOrganizationWebhooksLogs'][0])
    {
        return $this->getOrganizationWebhooksLogsAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $url, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWebhooksLogsAsyncWithHttpInfo
     *
     * Return the log of webhook POSTs sent
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $url The URL the webhook was sent to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksLogsAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null, string $contentType = self::contentTypes['getOrganizationWebhooksLogs'][0])
    {
        $returnType = '\Meraki\Model\GetOrganizationWebhooksLogs200ResponseInner[]';
        $request = $this->getOrganizationWebhooksLogsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $url, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWebhooksLogs'
     *
     * @param  string $organization_id Organization ID (required)
     * @param  string|null $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string|null $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float|null $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int|null $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string|null $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string|null $url The URL the webhook was sent to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrganizationWebhooksLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationWebhooksLogsRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null, string $contentType = self::contentTypes['getOrganizationWebhooksLogs'][0])
    {

        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWebhooksLogs'
            );
        }



        if ($timespan !== null && $timespan > 2678400) {
            throw new \InvalidArgumentException('invalid value for "$timespan" when calling WebhooksApi.getOrganizationWebhooksLogs, must be smaller than or equal to 2678400.');
        }
        





        $resourcePath = '/organizations/{organizationId}/webhooks/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t0,
            't0', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $t1,
            't1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timespan,
            'timespan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'perPage', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $starting_after,
            'startingAfter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ending_before,
            'endingBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWebhooksHttpServer
     *
     * Update an HTTP server
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner
     */
    public function updateNetworkWebhooksHttpServer($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {
        list($response) = $this->updateNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, $update_network_webhooks_http_server_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkWebhooksHttpServerWithHttpInfo
     *
     * Update an HTTP server
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWebhooksHttpServerWithHttpInfo($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {
        $request = $this->updateNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $update_network_webhooks_http_server_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWebhooksHttpServerAsync
     *
     * Update an HTTP server
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWebhooksHttpServerAsync($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {
        return $this->updateNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, $update_network_webhooks_http_server_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWebhooksHttpServerAsyncWithHttpInfo
     *
     * Update an HTTP server
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWebhooksHttpServerAsyncWithHttpInfo($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksHttpServers200ResponseInner';
        $request = $this->updateNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $update_network_webhooks_http_server_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWebhooksHttpServer'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $http_server_id Http server ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksHttpServerRequest|null $update_network_webhooks_http_server_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksHttpServer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkWebhooksHttpServerRequest($network_id, $http_server_id, $update_network_webhooks_http_server_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksHttpServer'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWebhooksHttpServer'
            );
        }

        // verify the required parameter 'http_server_id' is set
        if ($http_server_id === null || (is_array($http_server_id) && count($http_server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_server_id when calling updateNetworkWebhooksHttpServer'
            );
        }



        $resourcePath = '/networks/{networkId}/webhooks/httpServers/{httpServerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($http_server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'httpServerId' . '}',
                ObjectSerializer::toPathValue($http_server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_webhooks_http_server_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_webhooks_http_server_request));
            } else {
                $httpBody = $update_network_webhooks_http_server_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWebhooksPayloadTemplate
     *
     * Update a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner
     */
    public function updateNetworkWebhooksPayloadTemplate($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {
        list($response) = $this->updateNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, $update_network_webhooks_payload_template_request, $contentType);
        return $response;
    }

    /**
     * Operation updateNetworkWebhooksPayloadTemplateWithHttpInfo
     *
     * Update a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \Meraki\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWebhooksPayloadTemplateWithHttpInfo($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {
        $request = $this->updateNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $update_network_webhooks_payload_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWebhooksPayloadTemplateAsync
     *
     * Update a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWebhooksPayloadTemplateAsync($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {
        return $this->updateNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, $update_network_webhooks_payload_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWebhooksPayloadTemplateAsyncWithHttpInfo
     *
     * Update a webhook payload template for a network
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWebhooksPayloadTemplateAsyncWithHttpInfo($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {
        $returnType = '\Meraki\Model\GetNetworkWebhooksPayloadTemplates200ResponseInner';
        $request = $this->updateNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $update_network_webhooks_payload_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWebhooksPayloadTemplate'
     *
     * @param  string $network_id Network ID (required)
     * @param  string $payload_template_id Payload template ID (required)
     * @param  \Meraki\Model\UpdateNetworkWebhooksPayloadTemplateRequest|null $update_network_webhooks_payload_template_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNetworkWebhooksPayloadTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNetworkWebhooksPayloadTemplateRequest($network_id, $payload_template_id, $update_network_webhooks_payload_template_request = null, string $contentType = self::contentTypes['updateNetworkWebhooksPayloadTemplate'][0])
    {

        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWebhooksPayloadTemplate'
            );
        }

        // verify the required parameter 'payload_template_id' is set
        if ($payload_template_id === null || (is_array($payload_template_id) && count($payload_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payload_template_id when calling updateNetworkWebhooksPayloadTemplate'
            );
        }



        $resourcePath = '/networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($payload_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'payloadTemplateId' . '}',
                ObjectSerializer::toPathValue($payload_template_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_network_webhooks_payload_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_network_webhooks_payload_template_request));
            } else {
                $httpBody = $update_network_webhooks_payload_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }
        // this endpoint requires Bearer (API Key) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
